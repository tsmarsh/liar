## Summary

Add a dedicated closure conversion pass that transforms lambdas in the AST BEFORE codegen. This keeps codegen simple.

## Pipeline Position

```
Parse → Resolve → Infer → Ownership → Closures Analysis → Closures Conversion → Codegen
                                              ↑                    ↑
                                          (exists)              (THIS)
```

## Design Decision: Uniform Calling Convention

ALL functions take `env` as first parameter:

```lisp
;; User writes
(defun inc (x) (+ x 1))

;; Conversion emits
(defun inc (__env x) (+ x 1))  ;; env ignored but present
```

This means:
- Function reference `inc` → `{ @inc, null }`
- Lambda `(fn (x) (+ x n))` → `{ @__lambda_0, env_ptr }`
- All calls uniform: `(indirect-call fn_ptr env_ptr args...)`
- NO thunks needed

## Create liar/src/closures/conversion.rs

### Main Entry Point

```rust
pub fn convert(
    program: &mut Program,
    capture_info: HashMap<Span, CaptureInfo>,
) -> Result<()>
```

### What It Does

**Input:**
```lisp
(defun make-adder (n)
  (fn (x) (+ x n)))
```

**Output:**
```lisp
;; Environment struct for lambda
(defstruct __env_0 (n))

;; Lifted lambda with env parameter
(defun __lambda_0 (__env x)
  (+ x (. __env n)))

;; Original function - now takes __env, lambda replaced
(defun make-adder (__env n)
  (let ((env (rc-alloc __env_0)))
    (set! (. env n) n)
    { @__lambda_0, env }))
```

### Closure Representation

All closures are: `{ fn_ptr: ptr, env_ptr: ptr }`

## AST Extensions Needed

Add to `liar/src/ast.rs`:

```rust
/// A closure struct literal (generated by conversion pass)
ClosureStruct {
    fn_name: String,
    env: Option<Box<Spanned<Expr>>>,  // None = null env
},

/// An indirect call through a closure
ClosureCall {
    closure: Box<Spanned<Expr>>,
    args: Vec<Spanned<Expr>>,
},
```

## Update lib.rs Pipeline

```rust
let capture_info = closures::analyze(&program)?;
closures::convert(&mut program, capture_info)?;  // NEW
codegen::generate(&program)
```

## Tests

```rust
#[test]
fn test_convert_lambda_no_captures() {
    // (defun f () (fn (x) x)) should generate __lambda_0
}

#[test]
fn test_convert_lambda_with_capture() {
    // (defun f (n) (fn (x) (+ x n))) should generate __env_0 and __lambda_0
}

#[test]
fn test_all_functions_get_env_param() {
    // Every defun should have __env as first param after conversion
}
```

## Acceptance Criteria

- [ ] conversion.rs < 400 lines
- [ ] No thread-local state
- [ ] All lambdas converted before codegen
- [ ] All functions have __env parameter
- [ ] No thunks generated
- [ ] Integration: `(let ((f (fn (x) x))) (f 5))` evaluates to 5
