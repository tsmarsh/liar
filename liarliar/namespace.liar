;; namespace.liar - Namespace and module loading for liarliar
;;
;; Handles:
;;   - Parsing (ns name (:require ...)) forms
;;   - Module file resolution
;;   - Loading and caching modules
;;   - Symbol visibility across namespaces

(ns liarliar.namespace
  (:require [liar.prelude :refer :all]
            [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]
            [liarliar.io :refer :all]
            [liarliar.strings :refer :all]))

;; ============================================================
;; Require Spec
;; ============================================================

;; A require specification from (:require [mod :refer [...] :as alias])
;; - mod-name: symbol for module name (e.g., liar.prelude)
;; - refer-all: 1 if :refer :all, 0 otherwise
;; - refer-list: list of symbols to refer (nil if :refer :all or none)
;; - alias: symbol for :as alias (nil if none)

(defstruct RequireSpec
  (req-mod-name: ptr
   req-refer-all: i64
   req-refer-list: ptr
   req-alias: ptr))

(defun make-require-spec (mod-name: ptr refer-all: i64 refer-list: ptr alias: ptr) -> ptr
  (share (RequireSpec mod-name refer-all refer-list alias)))

(defun req-mod-name (r: ptr) -> ptr (. r req-mod-name))
(defun req-refer-all? (r: ptr) -> i64 (. r req-refer-all))
(defun req-refer-list (r: ptr) -> ptr (. r req-refer-list))
(defun req-alias (r: ptr) -> ptr (. r req-alias))

;; ============================================================
;; Parsed Namespace
;; ============================================================

;; A parsed namespace declaration
;; - ns-name: symbol for namespace name
;; - ns-requires: list of RequireSpec

(defstruct ParsedNs
  (ns-name: ptr
   ns-requires: ptr))

(defun make-parsed-ns (name: ptr requires: ptr) -> ptr
  (share (ParsedNs name requires)))

(defun parsed-ns-name (pns: ptr) -> ptr (. pns ns-name))
(defun parsed-ns-requires (pns: ptr) -> ptr (. pns ns-requires))

;; ============================================================
;; Keyword Helpers
;; ============================================================

;; Check if a symbol is :require
(defun str-keyword-require () -> ptr
  (let ((sb (string-builder-cap 9))
        (sb (sb-conj sb 58))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 113))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 101)))
    (to-string sb)))

;; Check if a symbol is :refer
(defun str-keyword-refer () -> ptr
  (let ((sb (string-builder-cap 7))
        (sb (sb-conj sb 58))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 114)))
    (to-string sb)))

;; Check if a symbol is :all
(defun str-keyword-all () -> ptr
  (let ((sb (string-builder-cap 5))
        (sb (sb-conj sb 58))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 108)))
    (to-string sb)))

;; Check if a symbol is :as
(defun str-keyword-as () -> ptr
  (let ((sb (string-builder-cap 4))
        (sb (sb-conj sb 58))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 115)))
    (to-string sb)))

(defun keyword-require? (sym: ptr) -> i64
  (if (symbol? sym)
      (streq (symbol-name sym) (str-keyword-require))
      0))

(defun keyword-refer? (sym: ptr) -> i64
  (if (symbol? sym)
      (streq (symbol-name sym) (str-keyword-refer))
      0))

(defun keyword-all? (sym: ptr) -> i64
  (if (symbol? sym)
      (streq (symbol-name sym) (str-keyword-all))
      0))

(defun keyword-as? (sym: ptr) -> i64
  (if (symbol? sym)
      (streq (symbol-name sym) (str-keyword-as))
      0))

;; ============================================================
;; Parse Require Spec
;; ============================================================

;; Parse options after module name: :refer :all, :refer [...], :as alias
;; Returns (refer-all, refer-list, alias)
(defun parse-require-options-loop (opts: ptr refer-all: i64 refer-list: ptr alias: ptr) -> ptr
  (if (nil? opts)
      (pcons (box-int refer-all) (pcons refer-list (pcons alias nil)))
      (let ((opt (car opts))
            (rest (cdr opts)))
        (cond
          ((keyword-refer? opt)
           (if (nil? rest)
               (pcons (box-int refer-all) (pcons refer-list (pcons alias nil)))
               (let ((arg (car rest)))
                 (if (keyword-all? arg)
                     (parse-require-options-loop (cdr rest) 1 nil alias)
                     (if (scons? arg)
                         (parse-require-options-loop (cdr rest) 0 arg alias)
                         (parse-require-options-loop (cdr rest) refer-all refer-list alias))))))
          ((keyword-as? opt)
           (if (nil? rest)
               (pcons (box-int refer-all) (pcons refer-list (pcons alias nil)))
               (parse-require-options-loop (cdr rest) refer-all refer-list (car rest))))
          (else
           (parse-require-options-loop rest refer-all refer-list alias))))))

(defun parse-require-options (opts: ptr) -> ptr
  (parse-require-options-loop opts 0 nil nil))

;; Parse a single require spec: [module-name :refer :all] or [module-name :as m]
(defun parse-require-spec (spec: ptr) -> ptr
  (if (not (scons? spec))
      nil
      (let ((mod-name (car spec))
            (opts (cdr spec))
            (parsed (parse-require-options opts))
            (refer-all (unbox-int (car parsed)))
            (refer-list (cadr parsed))
            (alias (caddr parsed)))
        (make-require-spec mod-name refer-all refer-list alias))))

;; Parse all require specs from (:require [...] [...] ...)
(defun parse-require-specs-loop (specs: ptr acc: ptr) -> ptr
  (if (nil? specs)
      (preverse acc)
      (let ((spec (parse-require-spec (car specs))))
        (if (nil? spec)
            (parse-require-specs-loop (cdr specs) acc)
            (parse-require-specs-loop (cdr specs) (pcons spec acc))))))

(defun parse-require-specs (require-form: ptr) -> ptr
  ;; require-form is (:require [...] [...] ...)
  ;; Skip the :require keyword
  (parse-require-specs-loop (cdr require-form) nil))

;; ============================================================
;; Parse NS Form
;; ============================================================

;; Find the (:require ...) clause in ns body
(defun find-require-clause (clauses: ptr) -> ptr
  (if (nil? clauses)
      nil
      (let ((clause (car clauses)))
        (if (scons? clause)
            (if (keyword-require? (car clause))
                clause
                (find-require-clause (cdr clauses)))
            (find-require-clause (cdr clauses))))))

;; Parse (ns name (:require ...)) form
;; Returns ParsedNs or nil if not an ns form
(defun parse-ns-form (form: ptr) -> ptr
  (if (not (scons? form))
      nil
      (let ((head (car form)))
        (if (not (symbol? head))
            nil
            (if (= 0 (streq (symbol-name head) (str-ns)))
                nil
                (let ((name (cadr form))
                      (body (cddr form))
                      (require-clause (find-require-clause body))
                      (requires (if (nil? require-clause)
                                    nil
                                    (parse-require-specs require-clause))))
                  (make-parsed-ns name requires)))))))

;; Helper to get str-ns (reuse from codegen would be better, but avoid circular dep)
(defun str-ns () -> ptr
  (let ((sb (string-builder-cap 3))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 115)))
    (to-string sb)))

;; ============================================================
;; Module Resolution
;; ============================================================

;; Convert namespace name to file path
;; liar.prelude -> lib/liar.prelude.liar (flat) or lib/liar/prelude.liar (hierarchical)
;; For now, just append .liar

;; Get string name from symbol or return as-is
(defun ns-name-to-string (ns-name: ptr) -> ptr
  (if (symbol? ns-name) (symbol-name ns-name) ns-name))

(defun namespace-to-path (ns-name: ptr lib-path: ptr) -> ptr
  ;; ns-name is a symbol, get its string name
  (namespace-to-path-with-name (ns-name-to-string ns-name) lib-path))

(defun namespace-to-path-with-name (name: ptr lib-path: ptr) -> ptr
  (let ((lib-len (strlen-ptr lib-path))
        (name-len (strlen-ptr name)))
    (let ((total (+ lib-len (+ 1 (+ name-len 6)))))  ;; 1 for /, 5 for .liar, 1 for null
      (let ((sb (string-builder-cap total))
            (sb (append sb lib-path))
            (sb (sb-conj sb 47))
            (sb (append sb name))
            (sb (sb-conj sb 46))
            (sb (sb-conj sb 108))
            (sb (sb-conj sb 105))
            (sb (sb-conj sb 97))
            (sb (sb-conj sb 114)))
        (to-string sb)))))

(defun strcpy-loop (dst: ptr src: ptr idx: i64) -> i64
  (let ((c (load-byte (ptr+ src idx))))
    (if (= c 0)
        idx
        (do
          (store-byte (ptr+ dst idx) c)
          (strcpy-loop dst src (+ idx 1))))))

(defun strlen-ptr (s: ptr) -> i64
  (strlen-loop s 0))

(defun strlen-loop (s: ptr idx) -> i64
  (if (= (load-byte (ptr+ s idx)) 0)
      idx
      (strlen-loop s (+ idx 1))))

;; ============================================================
;; Module Loader State
;; ============================================================

;; Tracks which modules have been loaded to avoid duplicates
;; Uses a simple list of symbol names for now
(defstruct LoaderState
  (loader-lib-path: ptr       ;; Path to lib directory
   loader-loaded: ptr))       ;; List of loaded module names (as strings)

(defun make-loader-state (lib-path: ptr) -> ptr
  (share (LoaderState lib-path nil)))

(defun loader-lib-path (ls: ptr) -> ptr (. ls loader-lib-path))
(defun loader-loaded (ls: ptr) -> ptr (. ls loader-loaded))

(defun loader-is-loaded? (ls: ptr name: ptr) -> i64
  (loader-is-loaded-loop (loader-loaded ls) name))

(defun loader-is-loaded-loop (loaded: ptr name: ptr) -> i64
  (if (nil? loaded)
      0
      (if (= 1 (streq (car loaded) name))
          1
          (loader-is-loaded-loop (cdr loaded) name))))

(defun loader-mark-loaded (ls: ptr name: ptr) -> ptr
  (let ((old-loaded (loader-loaded ls))
        (new-loaded (pcons name old-loaded)))
    (share (LoaderState (loader-lib-path ls) new-loaded))))

;; ============================================================
;; Check for ns form
;; ============================================================

;; Check if a form is an ns form (first element is ns symbol)
(defun ns-form? (form: ptr) -> i64
  (if (not (scons? form))
      0
      (let ((head (car form)))
        (if (not (symbol? head))
            0
            (streq (symbol-name head) (str-ns))))))
