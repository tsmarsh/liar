;; infer.liar - Hindley-Milner type inference with unification
;;
;; Type inference walks AST and assigns types to all expressions.
;; Uses type variables and unification to resolve constraints.
;;
;; Type representation uses tagged structs:
;;   TyInt, TyPtr, TyDouble - concrete types
;;   TyVar - type variable (unification target)
;;   TyFn - function type (params + return)
;;   TyStruct - named struct type
;;
;; Critical for ADR 024: type info drives codegen decisions.
;; When inference produces concrete type, emit primitive ops.
;; When type variable remains, emit protocol dispatch.

(ns liarliar.infer
  (:require [liarliar.symbols :refer :all]
            [liarliar.env :refer :all]
            [liarliar.value :refer :all]))

;; ============================================================
;; Type Tags (for instance? checks)
;; ============================================================

(def TY-INT 10)
(def TY-PTR 11)
(def TY-DOUBLE 12)
(def TY-VAR 13)
(def TY-FN 14)
(def TY-STRUCT 15)
(def TY-VOID 16)

;; ============================================================
;; Type Structs
;; ============================================================

;; Primitive types - no additional data needed, just tag
(defstruct TyInt (ty-int-tag: i64))
(defstruct TyPtr (ty-ptr-tag: i64))
(defstruct TyDouble (ty-double-tag: i64))
(defstruct TyVoid (ty-void-tag: i64))

;; Type variable - has ID for unification tracking
(defstruct TyVar (ty-var-tag: i64 ty-var-id: i64))

;; Function type - list of param types and return type
(defstruct TyFn (ty-fn-tag: i64 ty-fn-params: ptr ty-fn-ret: ptr))

;; Struct type - has name symbol
(defstruct TyStruct (ty-struct-tag: i64 ty-struct-name: ptr))

;; ============================================================
;; Type Constructors
;; ============================================================

;; Note: Using literal values since def constants aren't inlined yet
;; TY-INT=10, TY-PTR=11, TY-DOUBLE=12, TY-VAR=13, TY-FN=14, TY-STRUCT=15, TY-VOID=16

(defun ty-int () -> ptr
  (share (TyInt 10)))  ;; TY-INT

(defun ty-ptr () -> ptr
  (share (TyPtr 11)))  ;; TY-PTR

(defun ty-double () -> ptr
  (share (TyDouble 12)))  ;; TY-DOUBLE

(defun ty-void () -> ptr
  (share (TyVoid 16)))  ;; TY-VOID

(defun ty-var (id) -> ptr
  (share (TyVar 13 id)))  ;; TY-VAR

(defun ty-fn (params: ptr ret: ptr) -> ptr
  (share (TyFn 14 params ret)))  ;; TY-FN

(defun ty-struct (name: ptr) -> ptr
  (share (TyStruct 15 name)))  ;; TY-STRUCT

;; ============================================================
;; Type Predicates
;; ============================================================

;; Tag is at index 1 because index 0 is the __type_id prepended by compiler
(defun ty-tag (t: ptr) -> i64
  (aget t 1))

(defun ty-int? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 10) 1 0)))  ;; TY-INT

(defun ty-ptr? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 11) 1 0)))  ;; TY-PTR

(defun ty-double? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 12) 1 0)))  ;; TY-DOUBLE

(defun ty-void? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 16) 1 0)))  ;; TY-VOID

(defun ty-var? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 13) 1 0)))  ;; TY-VAR

(defun ty-fn? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 14) 1 0)))  ;; TY-FN

(defun ty-struct? (t: ptr) -> i64
  (if (nil? t) 0
      (if (= (ty-tag t) 15) 1 0)))  ;; TY-STRUCT

;; ============================================================
;; Type Accessors
;; ============================================================

(defun ty-var-id (t: ptr) -> i64
  (. t ty-var-id))

(defun ty-fn-params (t: ptr) -> ptr
  (. t ty-fn-params))

(defun ty-fn-ret (t: ptr) -> ptr
  (. t ty-fn-ret))

(defun ty-struct-name (t: ptr) -> ptr
  (. t ty-struct-name))

;; ============================================================
;; Substitution Storage
;; ============================================================
;;
;; Substitutions map type variable IDs to types.
;; Stored as parallel arrays: [var-id1, var-id2, ...] and [type1, type2, ...]
;; This is simpler than a hashmap for small numbers of type variables.

(defstruct Subs
  (subs-ids: ptr      ;; i64 array of var IDs
   subs-types: ptr    ;; ptr array of types
   subs-count: i64
   subs-cap: i64))

(defun make-subs (cap) -> ptr
  (share (Subs
          (heap-array cap)
          (heap-array-ptr cap)
          0
          cap)))

(defun subs-lookup-loop (ids: ptr types: ptr var-id count idx) -> ptr
  (if (>= idx count)
      nil  ;; not found
      (if (= (aget ids idx) var-id)
          (aget-ptr types idx)
          (subs-lookup-loop ids types var-id count (+ idx 1)))))

(defun subs-lookup (subs: ptr var-id) -> ptr
  (subs-lookup-loop
    (. subs subs-ids)
    (. subs subs-types)
    var-id
    (. subs subs-count)
    0))

(defun subs-extend! (subs: ptr var-id type: ptr) -> i64
  (let ((ids (. subs subs-ids))
        (types (. subs subs-types))
        (count (. subs subs-count))
        (cap (. subs subs-cap)))
    ;; TODO: check capacity, grow if needed
    (do
      (aset ids count var-id)
      (aset-ptr types count type)
      ;; Update count - need to mutate the struct
      ;; For now, return new count (caller must handle)
      (+ count 1))))

;; ============================================================
;; Inference Context
;; ============================================================
;;
;; Tracks:
;;   - Type environment: symbol-id -> type mapping
;;   - Substitutions: var-id -> type
;;   - Next var counter: for fresh type variables
;;   - Errors: accumulated type errors

(defstruct InferCtx
  (ictx-env: ptr       ;; Env from env.liar for type bindings
   ictx-subs: ptr      ;; Subs for unification
   ictx-next-var: i64  ;; counter for fresh vars
   ictx-errors: ptr))  ;; list of error messages

(defun make-infer-ctx () -> ptr
  (share (InferCtx
          (make-global-env)   ;; type environment
          (make-subs 64)      ;; substitutions
          0                   ;; next var ID
          nil)))              ;; no errors

;; ============================================================
;; Fresh Type Variables
;; ============================================================

(defun fresh-var! (ctx: ptr) -> ptr
  (let ((id (. ctx ictx-next-var))
        (new-var (ty-var id)))
    ;; Increment counter (mutation)
    ;; TODO: proper struct field mutation
    new-var))

;; ============================================================
;; Apply Substitutions
;; ============================================================

(defun apply-subs (ctx: ptr ty: ptr) -> ptr
  (if (nil? ty)
      ty
      (if (= 1 (ty-var? ty))
          ;; Type variable - look up in subs
          (let ((var-id (ty-var-id ty))
                (bound (subs-lookup (. ctx ictx-subs) var-id)))
            (if (nil? bound)
                ty  ;; unbound var stays as-is
                (apply-subs ctx bound)))  ;; recursive apply
          ;; TODO: recursively apply to TyFn params/ret
          ty)))

;; ============================================================
;; Unification
;; ============================================================

(defun types-equal? (t1: ptr t2: ptr) -> i64
  (if (nil? t1)
      (if (nil? t2) 1 0)
      (if (nil? t2)
          0
          (let ((tag1 (ty-tag t1))
                (tag2 (ty-tag t2)))
            (if (not (= tag1 tag2))
                0
                ;; Same tag - check additional fields
                (if (= tag1 13)  ;; TY-VAR
                    (if (= (ty-var-id t1) (ty-var-id t2)) 1 0)
                    ;; For primitives, same tag = equal
                    ;; TODO: check TyFn params/ret, TyStruct name
                    1))))))

(defun occurs-in? (var-id t: ptr) -> i64
  (if (nil? t)
      0
      (if (= 1 (ty-var? t))
          (if (= var-id (ty-var-id t)) 1 0)
          ;; TODO: check inside TyFn
          0)))

(defun unify (ctx: ptr t1: ptr t2: ptr) -> i64
  (let ((t1 (apply-subs ctx t1))
        (t2 (apply-subs ctx t2)))
    (if (= 1 (types-equal? t1 t2))
        1  ;; already equal
        (if (= 1 (ty-var? t1))
            ;; t1 is a type variable
            (let ((var-id (ty-var-id t1)))
              (if (= 1 (occurs-in? var-id t2))
                  0  ;; occurs check failed
                  (do
                    (subs-extend! (. ctx ictx-subs) var-id t2)
                    1)))
            (if (= 1 (ty-var? t2))
                ;; t2 is a type variable
                (let ((var-id (ty-var-id t2)))
                  (if (= 1 (occurs-in? var-id t1))
                      0  ;; occurs check failed
                      (do
                        (subs-extend! (. ctx ictx-subs) var-id t1)
                        1)))
                ;; TODO: unify TyFn (check params and return)
                0)))))  ;; types don't match

;; ============================================================
;; Builtin Types
;; ============================================================

;; Cache singleton types for efficiency
(def TYPE-INT (ty-int))
(def TYPE-PTR (ty-ptr))
(def TYPE-DOUBLE (ty-double))
(def TYPE-VOID (ty-void))

;; ============================================================
;; AST Helpers
;; ============================================================

;; Get car/cdr of SCons
(defun scar (x: ptr) -> ptr
  (scons-head x))

(defun scdr (x: ptr) -> ptr
  (scons-tail x))

;; Get second element
(defun scadr (x: ptr) -> ptr
  (scar (scdr x)))

;; Get third element
(defun scaddr (x: ptr) -> ptr
  (scar (scdr (scdr x))))

;; Check if symbol matches a name (by comparing symbol IDs)
(defun sym-eq? (sym: ptr name-id) -> i64
  (if (nil? sym)
      0
      (if (symbol? sym)
          (if (= (symbol-id sym) name-id) 1 0)
          0)))

;; ============================================================
;; Builtin Symbol IDs
;; ============================================================
;; These would normally come from interning, but we use fixed IDs for builtins

(def SYM-IF 0)
(def SYM-LET 1)
(def SYM-FN 2)
(def SYM-DO 3)
(def SYM-PLUS 4)
(def SYM-MINUS 5)
(def SYM-TIMES 6)
(def SYM-DIVIDE 7)

;; ============================================================
;; Infer Expressions
;; ============================================================

;; Infer type of a literal integer
(defun infer-int (ctx: ptr val) -> ptr
  (ty-int))

;; Infer type of a literal string
(defun infer-string (ctx: ptr s: ptr) -> ptr
  (ty-ptr))

;; Infer type of a symbol reference
(defun infer-symbol (ctx: ptr sym: ptr) -> ptr
  ;; For now, return fresh type var
  ;; TODO: lookup in type environment (need ptr storage, not i64)
  (fresh-var! ctx))

;; Infer type of if expression: (if cond then else)
(defun infer-if (ctx: ptr form: ptr) -> ptr
  (let ((cond-form (scadr form))
        (then-form (scaddr form))
        (else-form (scar (scdr (scdr (scdr form)))))
        ;; Infer condition (should be bool/int)
        (cond-ty (infer ctx cond-form))
        ;; Infer both branches
        (then-ty (infer ctx then-form))
        (else-ty (infer ctx else-form)))
    ;; Unify branches - they must have same type
    (do
      (unify ctx then-ty else-ty)
      then-ty)))

;; Infer type of arithmetic: (+ a b)
(defun infer-arith (ctx: ptr form: ptr) -> ptr
  (let ((a-form (scadr form))
        (b-form (scaddr form))
        (a-ty (infer ctx a-form))
        (b-ty (infer ctx b-form))
        (int-ty (ty-int)))
    ;; Both operands should be same numeric type
    (do
      (unify ctx a-ty b-ty)
      (unify ctx a-ty int-ty)
      int-ty)))

;; Infer type of do block: (do e1 e2 ... en)
(defun infer-do-loop (ctx: ptr forms: ptr) -> ptr
  (if (nil? forms)
      (ty-void)
      (let ((first-ty (infer ctx (scar forms)))
            (rest (scdr forms)))
        (if (nil? rest)
            first-ty  ;; last expression is result
            (infer-do-loop ctx rest)))))

(defun infer-do (ctx: ptr form: ptr) -> ptr
  (infer-do-loop ctx (scdr form)))

;; Infer type of let: (let ((x e1) ...) body)
(defun infer-let-bindings (ctx: ptr bindings: ptr) -> i64
  (if (nil? bindings)
      0
      (let ((binding (scar bindings))
            (val-form (scadr binding))
            (val-ty (infer ctx val-form)))
        ;; TODO: bind name to val-ty in type env (needs ptr storage)
        (infer-let-bindings ctx (scdr bindings)))))

(defun infer-let (ctx: ptr form: ptr) -> ptr
  (let ((bindings (scadr form))
        (body (scaddr form))
        (ignored (infer-let-bindings ctx bindings)))
    (infer ctx body)))

;; Infer type of function call: (f arg1 arg2 ...)
(defun infer-call (ctx: ptr form: ptr) -> ptr
  ;; For now, return fresh type var (proper impl needs function types)
  (fresh-var! ctx))

;; Main entry point for inference
;; Takes context and S-expression, returns inferred type
(defun infer (ctx: ptr form: ptr) -> ptr
  (if (nil? form)
      (ty-ptr)
      ;; Check what kind of form
      (if (symbol? form)
          ;; Symbol reference
          (infer-symbol ctx form)
          (if (not (scons? form))
              ;; Not a list - assume integer literal
              (ty-int)
              ;; List - check head for special forms
              (let ((head (scar form)))
                (if (not (symbol? head))
                    ;; Head not a symbol - generic call
                    (infer-call ctx form)
                    ;; Check for special forms by symbol ID
                    ;; SYM-IF=0, SYM-LET=1, SYM-FN=2, SYM-DO=3, SYM-PLUS=4, SYM-MINUS=5, SYM-TIMES=6, SYM-DIVIDE=7
                    (let ((head-id (symbol-id head)))
                      (if (= head-id 0)  ;; SYM-IF
                          (infer-if ctx form)
                          (if (= head-id 1)  ;; SYM-LET
                              (infer-let ctx form)
                              (if (= head-id 3)  ;; SYM-DO
                                  (infer-do ctx form)
                                  (if (= head-id 4)  ;; SYM-PLUS
                                      (infer-arith ctx form)
                                      (if (= head-id 5)  ;; SYM-MINUS
                                          (infer-arith ctx form)
                                          (if (= head-id 6)  ;; SYM-TIMES
                                              (infer-arith ctx form)
                                              (if (= head-id 7)  ;; SYM-DIVIDE
                                                  (infer-arith ctx form)
                                                  ;; Default: function call
                                                  (infer-call ctx form)))))))))))))))
