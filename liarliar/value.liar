;; value.liar - Typed cons cells for homogeneous and heterogeneous lists
;;
;; Architecture: Monomorphized typed collections instead of generic tagged pointers.
;; Each value type gets its own cons cell type for type-safe lists.
;;
;; Type prefixes:
;;   i  - i64 (integers)
;;   p  - ptr (pointers to any struct)
;;   s  - ptr (S-expressions specifically)
;;
;; Note: Float cons (FCons) deferred until struct field type support is verified.
;; Note: Field names are prefixed to avoid ambiguity (icons-hd vs pcons-hd).

(ns liarliar.value)

;; --- Integer cons (for homogeneous integer lists) ---
;; [1 2 3] → (icons 1 (icons 2 (icons 3 nil)))

(defstruct ICons (icons-hd: i64 icons-tl: ptr))

(defun icons (h icons-tl: ptr) -> ptr
  (share (ICons h icons-tl)))

(defun icons-head (c: ptr) -> i64
  (. c icons-hd))

(defun icons-tail (c: ptr) -> ptr
  (. c icons-tl))

(defun icons? (x: ptr)
  (instance? x ICons))


;; --- Pointer cons (for heterogeneous pointer lists) ---
;; General-purpose list of any struct pointers
;; [(Box 1) (Box 2)] → (pcons box1 (pcons box2 nil))

(defstruct PCons (pcons-hd: ptr pcons-tl: ptr))

(defun pcons (h: ptr pcons-tl: ptr) -> ptr
  (share (PCons h pcons-tl)))

(defun pcons-head (c: ptr) -> ptr
  (. c pcons-hd))

(defun pcons-tail (c: ptr) -> ptr
  (. c pcons-tl))

(defun pcons? (x: ptr)
  (instance? x PCons))


;; --- S-expression cons (for parsed source code) ---
;; Separate type from PCons so instance? can distinguish AST from data.
;; Includes source location for error messages.
;;
;; (defun foo (x) (+ x 1))
;; → (scons sym-defun (scons sym-foo (scons (scons sym-x nil) (scons ...))))

(defstruct SCons (scons-hd: ptr scons-tl: ptr scons-line: i64 scons-col: i64))

(defun scons (h: ptr scons-tl: ptr) -> ptr
  (share (SCons h scons-tl 0 0)))

(defun scons-loc (h: ptr scons-tl: ptr line col) -> ptr
  (share (SCons h scons-tl line col)))

(defun scons-head (c: ptr) -> ptr
  (. c scons-hd))

(defun scons-tail (c: ptr) -> ptr
  (. c scons-tl))

(defun scons-line (c: ptr) -> i64
  (. c scons-line))

(defun scons-col (c: ptr) -> i64
  (. c scons-col))

(defun scons? (x: ptr)
  (instance? x SCons))


;; --- Boxed primitives for uniform treatment ---
;; When you need to put an integer in a pointer list

(defstruct BoxedInt (boxed-int-val: i64))

(defun box-int (v) -> ptr
  (share (BoxedInt v)))

(defun unbox-int (b: ptr) -> i64
  (. b boxed-int-val))

(defun boxed-int? (x: ptr)
  (instance? x BoxedInt))


;; --- Boxed Float (stored as integer/fractional parts since struct fields don't support double) ---
;; Example: 3.14 → (BoxedFloat 3 14 100) where 3 + 14/100 = 3.14
;; scale is 10^(number of decimal digits)

(defstruct BoxedFloat (boxed-float-int: i64 boxed-float-frac: i64 boxed-float-scale: i64))

(defun box-float (int-part: i64 frac-part: i64 scale: i64) -> ptr
  (share (BoxedFloat int-part frac-part scale)))

(defun boxed-float? (x: ptr)
  (instance? x BoxedFloat))

(defun boxed-float-int (f: ptr) -> i64
  (. f boxed-float-int))

(defun boxed-float-frac (f: ptr) -> i64
  (. f boxed-float-frac))

(defun boxed-float-scale (f: ptr) -> i64
  (. f boxed-float-scale))


;; --- String wrapper (ptr to null-terminated bytes) ---
;; Strings are already pointers in liar, but this provides a distinct type

(defstruct LiarString (liar-str-data: ptr liar-str-len: i64))

(defun liar-string (liar-str-data: ptr liar-str-len) -> ptr
  (share (LiarString liar-str-data liar-str-len)))

(defun liar-string? (x: ptr)
  (instance? x LiarString))

(defun liar-string-data (s: ptr) -> ptr
  (. s liar-str-data))

(defun liar-string-len (s: ptr) -> i64
  (. s liar-str-len))


;; --- Standard list accessors ---
;; Safe car/cdr that return nil for nil/non-cons input

(defun car (lst: ptr) -> ptr
  (if (scons? lst) (scons-head lst) nil))

(defun cdr (lst: ptr) -> ptr
  (if (scons? lst) (scons-tail lst) nil))

(defun cadr (lst: ptr) -> ptr
  (car (cdr lst)))

(defun caddr (lst: ptr) -> ptr
  (car (cdr (cdr lst))))

(defun cadddr (lst: ptr) -> ptr
  (car (cdr (cdr (cdr lst)))))

(defun cddr (lst: ptr) -> ptr
  (cdr (cdr lst)))

(defun cdddr (lst: ptr) -> ptr
  (cdr (cdr (cdr lst))))

;; Reverse an SCons list
(defun reverse-scons-acc (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      acc
      (reverse-scons-acc (cdr lst) (scons (car lst) acc))))

(defun reverse-scons (lst: ptr) -> ptr
  (reverse-scons-acc lst nil))
