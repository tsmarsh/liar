;; value.liar - Typed cons cells for homogeneous and heterogeneous lists
;;
;; Uses stdlib PtrCons for S-expressions and heterogeneous lists.
;; Keeps ICons for integer-only lists (more efficient, no boxing).
;;
;; Type prefixes:
;;   i  - i64 (integers)
;;   p/s - ptr (pointers, S-expressions) - now uses stdlib PtrCons

(ns liarliar.value
  (:require [liar.seq :refer [pcons pfirst prest pcount preverse PtrCons]]))

;; --- Integer cons (for homogeneous integer lists) ---
;; [1 2 3] → (icons 1 (icons 2 (icons 3 nil)))

(defstruct ICons (icons-hd: i64 icons-tl: ptr))

(defun icons (h icons-tl: ptr) -> ptr
  (share (ICons h icons-tl)))

(defun icons-head (c: ptr) -> i64
  (. c icons-hd))

(defun icons-tail (c: ptr) -> ptr
  (. c icons-tl))

(defun icons? (x: ptr)
  (instance? x ICons))


;; --- Pointer cons (uses stdlib PtrCons) ---
;; pcons, pfirst, prest imported from liar.seq

(defun pcons-head (c: ptr) -> ptr
  (pfirst c))

(defun pcons-tail (c: ptr) -> ptr
  (prest c))

(defun pcons? (x: ptr)
  (instance? x PtrCons))


;; --- S-expression cons (uses stdlib PtrCons) ---
;; SCons is now an alias for PtrCons. Source locations were unused.
;;
;; (defun foo (x) (+ x 1))
;; → (scons sym-defun (scons sym-foo (scons (scons sym-x nil) (scons ...))))

(defun scons (h: ptr scons-tl: ptr) -> ptr
  (pcons h scons-tl))

;; scons-loc ignores location for now (PtrCons doesn't store it)
;; TODO: Add LocPtrCons to stdlib if source locations are needed
(defun scons-loc (h: ptr scons-tl: ptr line col) -> ptr
  (pcons h scons-tl))

(defun scons-head (c: ptr) -> ptr
  (pfirst c))

(defun scons-tail (c: ptr) -> ptr
  (prest c))

(defun scons? (x: ptr)
  (instance? x PtrCons))


;; --- Boxed primitives for uniform treatment ---
;; When you need to put an integer in a pointer list

(defstruct BoxedInt (boxed-int-val: i64))

(defun box-int (v) -> ptr
  (share (BoxedInt v)))

(defun unbox-int (b: ptr) -> i64
  (. b boxed-int-val))

(defun boxed-int? (x: ptr)
  (instance? x BoxedInt))


;; --- Boxed Boolean for true/false literals ---
(defstruct BoxedBool (boxed-bool-val: i64))

(defun box-bool (v: i64) -> ptr
  (share (BoxedBool v)))

(defun unbox-bool (b: ptr) -> i64
  (. b boxed-bool-val))

(defun boxed-bool? (x: ptr)
  (instance? x BoxedBool))


;; --- Boxed Float (stored as integer/fractional parts since struct fields don't support double) ---
;; Example: 3.14 → (BoxedFloat 3 14 100) where 3 + 14/100 = 3.14
;; scale is 10^(number of decimal digits)

(defstruct BoxedFloat (boxed-float-int: i64 boxed-float-frac: i64 boxed-float-scale: i64))

(defun box-float (int-part: i64 frac-part: i64 scale: i64) -> ptr
  (share (BoxedFloat int-part frac-part scale)))

(defun boxed-float? (x: ptr)
  (instance? x BoxedFloat))

(defun boxed-float-int (f: ptr) -> i64
  (. f boxed-float-int))

(defun boxed-float-frac (f: ptr) -> i64
  (. f boxed-float-frac))

(defun boxed-float-scale (f: ptr) -> i64
  (. f boxed-float-scale))


;; --- String wrapper (ptr to null-terminated bytes) ---
;; Strings are already pointers in liar, but this provides a distinct type

(defstruct LiarString (liar-str-data: ptr liar-str-len: i64))

(defun liar-string (liar-str-data: ptr liar-str-len) -> ptr
  (share (LiarString liar-str-data liar-str-len)))

(defun liar-string? (x: ptr)
  (instance? x LiarString))

(defun liar-string-data (s: ptr) -> ptr
  (. s liar-str-data))

(defun liar-string-len (s: ptr) -> i64
  (. s liar-str-len))


;; --- Standard list accessors ---
;; car/cdr work on PtrCons (the underlying type for scons)

(defun car (lst: ptr) -> ptr
  (pfirst lst))

(defun cdr (lst: ptr) -> ptr
  (prest lst))

(defun cadr (lst: ptr) -> ptr
  (pfirst (prest lst)))

(defun caddr (lst: ptr) -> ptr
  (pfirst (prest (prest lst))))

(defun cadddr (lst: ptr) -> ptr
  (pfirst (prest (prest (prest lst)))))

(defun cddr (lst: ptr) -> ptr
  (prest (prest lst)))

(defun cdddr (lst: ptr) -> ptr
  (prest (prest (prest lst))))

;; Reverse an SCons list (uses stdlib preverse)
(defun reverse-scons (lst: ptr) -> ptr
  (preverse lst))
