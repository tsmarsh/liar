;; env.liar - Runtime environment for liarliar
;;
;; Environments are the core runtime structure. Everything is an environment:
;;   - Global env: stdlib (map, filter, +, etc.) - always available
;;   - Namespaces: named, exportable environments
;;   - Let/plet: anonymous child environments
;;   - Functions: parameter bindings in child environment
;;
;; Lookup walks up the parent chain. No imports needed for globals.
;;
;; Uses stdlib HashMap for O(1) lookup instead of O(n) linear scan.

(ns liarliar.env
  (:require [liarliar.symbols :refer :all]
            [liar.hashmap :refer [hash-map hm-get hm-assoc hm-contains?]]))

;; --- Environment structure ---
;;
;; Bindings stored in HashMap (sym-id -> value) with mutable wrapper.
;; data[0] = current HashMap pointer
;; Parent is borrowed (not owned) - the parent env must outlive children.

(defstruct Env
  (env-data: ptr      ;; mutable pointer to HashMap
   env-parent: ptr    ;; parent environment (nil for global)
   env-name: ptr))    ;; namespace name symbol (nil for anonymous)

;; --- Constructor ---

(defun make-env (parent: ptr name: ptr) -> ptr
  (let ((data (heap-array-ptr 1))
        (s (aset-ptr data 0 (hash-map))))
    (share (Env data parent name))))

;; Create the global environment (no parent)
(defun make-global-env () -> ptr
  (make-env nil nil))

;; Create a namespace (named, under parent)
(defun make-namespace (parent: ptr name: ptr) -> ptr
  (make-env parent name))

;; Create an anonymous scope (let, fn params)
(defun make-scope (parent: ptr) -> ptr
  (make-env parent nil))

;; --- Internal helpers ---

(defun env-get-map (e: ptr) -> ptr
  (aget-ptr (. e env-data) 0))

(defun env-set-map! (e: ptr m: ptr) -> i64
  (aset-ptr (. e env-data) 0 m))

;; --- Accessors ---

(defun env-parent (e: ptr) -> ptr
  (. e env-parent))

(defun env-name (e: ptr) -> ptr
  (. e env-name))

(defun namespace? (e: ptr) -> i64
  (if (nil? (env-name e)) 0 1))

;; --- Lookup ---

;; Search for sym-id in this env's bindings only (not parent)
;; Returns the value if found, or -1 if not (sentinel)
(defun env-find-local (e: ptr sym-id) -> i64
  (let ((m (env-get-map e))
        (v (hm-get m sym-id)))
    ;; hm-get returns 0 for not found, but 0 could be a valid value
    ;; Use hm-contains? to distinguish
    (if (= 1 (hm-contains? m sym-id))
        v
        -1)))

;; Check if binding exists locally (returns 1 if found, 0 if not)
(defun env-has-local? (e: ptr sym-id) -> i64
  (hm-contains? (env-get-map e) sym-id))

;; Lookup walking the parent chain
;; Returns value or -1 if not found anywhere
(defun env-lookup (e: ptr sym-id) -> i64
  (if (nil? e)
      -1  ;; not found
      (let ((local (env-find-local e sym-id)))
        (if (= local -1)
            (env-lookup (env-parent e) sym-id)
            local))))

;; Check if defined anywhere in chain (returns 1 if found, 0 if not)
(defun env-defined? (e: ptr sym-id) -> i64
  (if (= -1 (env-lookup e sym-id)) 0 1))

;; --- Define (mutating) ---

;; Add or update a binding in this environment
;; For REPL: allows redefinition in same env
(defun env-define! (e: ptr sym-id value) -> i64
  (let ((m (env-get-map e))
        (new-m (hm-assoc m sym-id value))
        (s (env-set-map! e new-m)))
    value))

;; --- Convenience for symbols ---

;; Define using a Symbol struct
(defun env-define-sym! (e: ptr sym: ptr value) -> i64
  (env-define! e (symbol-id sym) value))

;; Lookup using a Symbol struct
(defun env-lookup-sym (e: ptr sym: ptr) -> i64
  (env-lookup e (symbol-id sym)))
