;; env.liar - Runtime environment for liarliar
;;
;; Environments are the core runtime structure. Everything is an environment:
;;   - Global env: stdlib (map, filter, +, etc.) - always available
;;   - Namespaces: named, exportable environments
;;   - Let/plet: anonymous child environments
;;   - Functions: parameter bindings in child environment
;;
;; Lookup walks up the parent chain. No imports needed for globals.

(ns liarliar.env
  (:require [liarliar.symbols :refer :all]))

;; --- Environment structure ---
;;
;; Bindings are stored as a mutable assoc-list for REPL efficiency:
;;   data[0] = count (number of bindings)
;;   data[1] = capacity
;;   data[2..] = pairs: [sym-id, value, sym-id, value, ...]
;;
;; Parent is borrowed (not owned) - the parent env must outlive children.

(defstruct Env
  (env-data: ptr      ;; mutable binding storage
   env-parent: ptr    ;; parent environment (nil for global)
   env-name: ptr))    ;; namespace name symbol (nil for anonymous)

;; --- Constants ---

(defun env-default-cap () 16)  ;; default slots (8 bindings)

;; --- Internal helpers ---

(defun env-get-count (data: ptr) -> i64
  (aget data 0))

(defun env-set-count! (data: ptr n)
  (aset data 0 n))

(defun env-get-cap (data: ptr) -> i64
  (aget data 1))

;; Index into data array for a binding slot
;; Each binding takes 2 slots: sym-id and value
(defun env-slot-idx (slot) -> i64
  (+ 2 (* slot 2)))

;; --- Constructor ---

(defun make-env (parent: ptr name: ptr) -> ptr
  (let ((cap (env-default-cap))
        (data (heap-array (+ 2 cap)))
        (s0 (aset data 0 0))      ;; count = 0
        (s1 (aset data 1 cap)))   ;; capacity
    (share (Env data parent name))))

;; Create the global environment (no parent)
(defun make-global-env () -> ptr
  (make-env nil nil))

;; Create a namespace (named, under parent)
(defun make-namespace (parent: ptr name: ptr) -> ptr
  (make-env parent name))

;; Create an anonymous scope (let, fn params)
(defun make-scope (parent: ptr) -> ptr
  (make-env parent nil))

;; --- Accessors ---

(defun env-parent (e: ptr) -> ptr
  (. e env-parent))

(defun env-name (e: ptr) -> ptr
  (. e env-name))

(defun env-count (e: ptr) -> i64
  (env-get-count (. e env-data)))

(defun namespace? (e: ptr) -> i64
  (if (nil? (env-name e)) 0 1))

;; --- Lookup ---

;; Search for sym-id in this env's bindings only (not parent)
;; Returns the value if found, or a sentinel if not
(defun env-find-local-loop (data: ptr sym-id count idx) -> i64
  (if (>= idx count)
      -1  ;; not found sentinel
      (let ((slot (env-slot-idx idx))
            (stored-id (aget data slot)))
        (if (= stored-id sym-id)
            (aget data (+ slot 1))  ;; return the value
            (env-find-local-loop data sym-id count (+ idx 1))))))

(defun env-find-local (e: ptr sym-id) -> i64
  (let ((data (. e env-data))
        (count (env-get-count data)))
    (env-find-local-loop data sym-id count 0)))

;; Check if binding exists locally (returns 1 if found, 0 if not)
(defun env-has-local? (e: ptr sym-id) -> i64
  (if (= -1 (env-find-local e sym-id)) 0 1))

;; Lookup walking the parent chain
;; Returns value or -1 if not found anywhere
(defun env-lookup (e: ptr sym-id) -> i64
  (if (nil? e)
      -1  ;; not found
      (let ((local (env-find-local e sym-id)))
        (if (= local -1)
            (env-lookup (env-parent e) sym-id)
            local))))

;; Check if defined anywhere in chain (returns 1 if found, 0 if not)
(defun env-defined? (e: ptr sym-id) -> i64
  (if (= -1 (env-lookup e sym-id)) 0 1))

;; --- Define (mutating) ---

;; Add or update a binding in this environment
;; For REPL: allows redefinition in same env
(defun env-define! (e: ptr sym-id value) -> i64
  (let ((data (. e env-data))
        (count (env-get-count data))
        (cap (env-get-cap data)))
    ;; First check if already defined (update case)
    (if (= 1 (env-has-local? e sym-id))
        (env-update-loop data sym-id value count 0)
        ;; New binding - check capacity
        (if (>= (* 2 (+ count 1)) cap)
            ;; TODO: grow array
            -1  ;; error: out of space
            ;; Add new binding
            (let ((slot (env-slot-idx count))
                  (s1 (aset data slot sym-id))
                  (s2 (aset data (+ slot 1) value))
                  (s3 (env-set-count! data (+ count 1))))
              value)))))

;; Update existing binding
(defun env-update-loop (data: ptr sym-id value count idx) -> i64
  (if (>= idx count)
      -1  ;; shouldn't happen
      (let ((slot (env-slot-idx idx)))
        (if (= (aget data slot) sym-id)
            (do (aset data (+ slot 1) value) value)
            (env-update-loop data sym-id value count (+ idx 1))))))

;; --- Convenience for symbols ---

;; Define using a Symbol struct
(defun env-define-sym! (e: ptr sym: ptr value) -> i64
  (env-define! e (symbol-id sym) value))

;; Lookup using a Symbol struct
(defun env-lookup-sym (e: ptr sym: ptr) -> i64
  (env-lookup e (symbol-id sym)))
