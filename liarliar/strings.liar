;; strings.liar - String builder for efficient lIR code generation
;;
;; Uses same data layout as MutVector:
;;   data[0] = length (bytes written)
;;   data[1] = capacity
;;   data[2..] = byte data (as i64 slots, using store-byte/load-byte)

(ns liarliar.strings)

;; Protocol for Collection (only conj needed)
(defprotocol Countable
  (count [self]))

(defprotocol Collection
  (conj [self x]))

;; --- External declarations ---

(extern malloc ptr (i64))
(extern memcpy ptr (ptr ptr i64))

;; --- StringBuilder struct ---

(defstruct StringBuilder (sb-data: ptr))

;; --- Internal helpers ---

(defun sb-growth-factor () 2)

(defun sb-get-len (data: ptr) -> i64 (aget data 0))
(defun sb-get-cap (data: ptr) -> i64 (aget data 1))
(defun sb-set-len! (data: ptr len) (aset data 0 len))

;; Byte offset in the data array (after len and cap slots)
(defun sb-byte-ptr (data: ptr) -> ptr
  (ptr+ data 16))  ;; Skip 2 i64 slots (16 bytes)

;; --- Constructor ---

(defun string-builder-cap (cap) -> ptr
  (let ((data (heap-array (+ 2 (/ cap 8))))
        (s0 (aset data 0 0))
        (s1 (aset data 1 cap)))
    (share (StringBuilder data))))

;; --- Growth ---

(defun sb-copy-bytes-loop (src: ptr dst: ptr i len) -> i64
  (if (>= i len)
      len
      (let ((b (load-byte (ptr+ src i)))
            (s (store-byte (ptr+ dst i) b)))
        (sb-copy-bytes-loop src dst (+ i 1) len))))

(defun sb-grow (sb: ptr needed) -> ptr
  (let ((data (. sb sb-data))
        (old-len (sb-get-len data))
        (old-cap (sb-get-cap data))
        (new-cap (* (+ old-cap needed) (sb-growth-factor)))
        (new-data (heap-array (+ 2 (/ new-cap 8))))
        (s0 (aset new-data 0 old-len))
        (s1 (aset new-data 1 new-cap))
        (s2 (sb-copy-bytes-loop (sb-byte-ptr data) (sb-byte-ptr new-data) 0 old-len)))
    (share (StringBuilder new-data))))

(defun sb-ensure-cap (sb: ptr needed) -> ptr
  (let ((data (. sb sb-data))
        (len (sb-get-len data))
        (cap (sb-get-cap data)))
    (if (<= (+ len needed) cap)
        sb
        (sb-grow sb needed))))

;; --- Protocol implementations ---

(extend-protocol Countable StringBuilder
  (count [self]
    (sb-get-len (. self sb-data))))

(extend-protocol Collection StringBuilder
  (conj [self x]
    (let ((sb (sb-ensure-cap self 1))
          (data (. sb sb-data))
          (len (sb-get-len data))
          (s1 (store-byte (ptr+ (sb-byte-ptr data) len) x))
          (s2 (sb-set-len! data (+ len 1))))
      sb)))

;; --- String operations ---

(defun strlen-loop (s: ptr idx) -> i64
  (if (= (load-byte (ptr+ s idx)) 0)
      idx
      (strlen-loop s (+ idx 1))))

(defun strlen-ptr (s: ptr) -> i64
  (strlen-loop s 0))

(defun sb-append-loop (sb: ptr s: ptr i len) -> ptr
  (if (>= i len)
      sb
      (let ((sb (conj sb (load-byte (ptr+ s i)))))
        (sb-append-loop sb s (+ i 1) len))))

(defun append (sb: ptr s: ptr) -> ptr
  (let ((slen (strlen-ptr s)))
    (sb-append-loop (sb-ensure-cap sb slen) s 0 slen)))

;; --- Integer formatting ---

(defun write-digits-loop (sb: ptr n) -> ptr
  (if (= n 0)
      sb
      (let ((digit (rem n 10))
            (sb (conj sb (+ 48 digit))))  ;; '0' = 48
        (write-digits-loop sb (/ n 10)))))

(defun reverse-last-n-loop (sb: ptr start end) -> ptr
  (if (>= start end)
      sb
      (let ((data (. sb sb-data))
            (buf (sb-byte-ptr data))
            (tmp (load-byte (ptr+ buf start)))
            (s1 (store-byte (ptr+ buf start) (load-byte (ptr+ buf end))))
            (s2 (store-byte (ptr+ buf end) tmp)))
        (reverse-last-n-loop sb (+ start 1) (- end 1)))))

(defun reverse-last-n (sb: ptr n) -> ptr
  (let ((len (count sb)))
    (reverse-last-n-loop sb (- len n) (- len 1))))

(defun append-int (sb: ptr n) -> ptr
  (if (= n 0)
      (conj sb 48)  ;; '0'
      (if (< n 0)
          (let ((sb (conj sb 45))  ;; '-'
                (start-len (count sb))
                (sb (write-digits-loop sb (- 0 n)))
                (digits (- (count sb) start-len)))
            (reverse-last-n sb digits))
          (let ((start-len (count sb))
                (sb (write-digits-loop sb n))
                (digits (- (count sb) start-len)))
            (reverse-last-n sb digits)))))

;; --- Finalize ---

(defun to-string (sb: ptr) -> ptr
  (let ((data (. sb sb-data))
        (len (sb-get-len data))
        (buf (sb-byte-ptr data))
        (s (store-byte (ptr+ buf len) 0)))
    buf))
