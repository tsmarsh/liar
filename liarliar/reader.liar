;; reader.liar - S-expression reader for liar
;;
;; Parses source text into SCons structures (native AST).
;; Uses load-byte and ptr+ for character-by-character parsing.
;;
;; Dependencies: value.liar (SCons, BoxedInt, LiarString, pcons)
;;               symbols.liar (intern)
;;
;; Note: All functions that take 'src' or 'name' use ptr type, not string.
;; String literals in liar have type 'string', which is incompatible with ptr.
;; The reader expects ptr to raw byte data (from slurp or heap-array).

(ns liarliar.reader
  (:require [liar.core :refer :all]
            [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]))

;; ============================================================================
;; Lexer State
;; ============================================================================

(defstruct Lexer (lex-src: ptr lex-pos: i64 lex-len: i64 lex-line: i64 lex-col: i64))

;; Create a new lexer from source bytes
;; Note: src must be ptr (from slurp or heap-array), not string literal
(defun make-lexer (src len: i64) -> ptr
  (share (Lexer src 0 len 1 1)))

(defun lexer-src (lex: ptr) -> ptr (. lex lex-src))
(defun lexer-pos (lex: ptr) -> i64 (. lex lex-pos))
(defun lexer-len (lex: ptr) -> i64 (. lex lex-len))
(defun lexer-line (lex: ptr) -> i64 (. lex lex-line))
(defun lexer-col (lex: ptr) -> i64 (. lex lex-col))

;; ============================================================================
;; Character Operations
;; ============================================================================

;; Peek at current character without consuming
;; Returns -1 for EOF
(defun peek-char (lex: ptr) -> i64
  (if (>= (lexer-pos lex) (lexer-len lex))
      -1
      (zext i64 (load-byte (ptr+ (lexer-src lex) (lexer-pos lex))))))

;; Peek at character at offset from current position
(defun peek-char-at (lex: ptr offset: i64) -> i64
  (let ((pos (+ (lexer-pos lex) offset)))
    (if (>= pos (lexer-len lex))
        -1
        (zext i64 (load-byte (ptr+ (lexer-src lex) pos))))))

;; Advance lexer by one character, updating line/col
;; Returns a new Lexer (functional style for bootstrap simplicity)
(defun advance-char (lex: ptr) -> ptr
  (let ((c (peek-char lex))
        (pos (+ (lexer-pos lex) 1)))
    (if (= c 10)  ;; newline
        (share (Lexer (lexer-src lex) pos (lexer-len lex)
                      (+ (lexer-line lex) 1) 1))
        (share (Lexer (lexer-src lex) pos (lexer-len lex)
                      (lexer-line lex) (+ (lexer-col lex) 1))))))

;; Advance lexer by n characters
(defun advance-n (lex: ptr n: i64) -> ptr
  (if (<= n 0)
      lex
      (advance-n (advance-char lex) (- n 1))))

;; ============================================================================
;; Character Classification
;; ============================================================================

;; Note: predicate functions don't specify return type - compiler infers bool (i1)

(defun eof? (c: i64) (= c -1))

(defun whitespace? (c: i64)
  (cond
    ((= c 32) true)   ;; space
    ((= c 10) true)   ;; newline
    ((= c 9)  true)   ;; tab
    ((= c 13) true)   ;; carriage return
    (else false)))

(defun digit? (c: i64)
  (if (>= c 48) (if (<= c 57) true false) false))

(defun alpha? (c: i64)
  (if (>= c 97)
      (if (<= c 122) true (if (>= c 65) (if (<= c 90) true false) false))
      (if (>= c 65) (if (<= c 90) true false) false)))

;; Symbol start: alpha, _, +, -, *, /, <, >, =, ?, !, &, .
(defun symbol-start? (c: i64)
  (cond
    ((alpha? c) true)
    ((= c 95) true)   ;; _
    ((= c 43) true)   ;; +
    ((= c 45) true)   ;; -
    ((= c 42) true)   ;; *
    ((= c 47) true)   ;; /
    ((= c 60) true)   ;; <
    ((= c 62) true)   ;; >
    ((= c 61) true)   ;; =
    ((= c 63) true)   ;; ?
    ((= c 33) true)   ;; !
    ((= c 38) true)   ;; &
    ((= c 37) true)   ;; %
    ((= c 46) true)   ;; .
    (else false)))

;; Symbol continue: symbol-start, digit, or .
(defun symbol-char? (c: i64)
  (cond
    ((symbol-start? c) true)
    ((digit? c) true)
    ((= c 46) true)   ;; .
    (else false)))

;; ============================================================================
;; Whitespace and Comment Skipping
;; ============================================================================

;; Skip to end of line (for comments)
(defun skip-to-eol (lex: ptr) -> ptr
  (let ((c (peek-char lex)))
    (if (eof? c) lex
        (if (= c 10) (advance-char lex)  ;; consume newline
            (skip-to-eol (advance-char lex))))))

;; Skip whitespace and comments
(defun skip-ws (lex: ptr) -> ptr
  (let ((c (peek-char lex)))
    (if (eof? c) lex
        (if (whitespace? c) (skip-ws (advance-char lex))
            (if (= c 59)  ;; semicolon starts comment
                (skip-ws (skip-to-eol lex))
                lex)))))

;; ============================================================================
;; Number Parsing
;; ============================================================================

;; Accumulate digits into a number, returning (lexer . boxed-int)
;; Uses icons (i64 cons) for the intermediate result since we need i64 value
(defun read-digits-raw (lex: ptr acc: i64) -> ptr
  (let ((c (peek-char lex)))
    (if (digit? c)
        (read-digits-raw (advance-char lex) (+ (* acc 10) (- c 48)))
        (icons acc lex))))  ;; icons: (i64-head, ptr-tail)

;; Read fractional digits, also tracking scale (10^n)
;; Returns icons (frac, icons (scale, lexer))
(defun read-frac-digits (lex: ptr frac: i64 scale: i64) -> ptr
  (let ((c (peek-char lex)))
    (if (digit? c)
        (read-frac-digits (advance-char lex)
                          (+ (* frac 10) (- c 48))
                          (* scale 10))
        (icons frac (icons scale lex)))))

;; Read a number (integer or float)
;; Helper to negate if needed
(defun negate-if (is-negative: i64 val: i64) -> i64
  (if (= is-negative 1) (- 0 val) val))

;; Helper for read-number after parsing integer part
(defun read-number-finish (int-lex: ptr int-val: i64 is-negative: i64) -> ptr
  (let ((next-c (peek-char int-lex)))
    (if (= next-c 46)  ;; . - float
        (let ((frac-result (read-frac-digits (advance-char int-lex) 0 1))
              (frac-val (icons-head frac-result))
              (scale-lex (icons-tail frac-result))
              (scale (icons-head scale-lex))
              (frac-lex (icons-tail scale-lex))
              (final-int (negate-if is-negative int-val))
              (final-frac (if (= is-negative 1)
                              (if (= int-val 0)
                                  (negate-if is-negative frac-val)
                                  frac-val)
                              frac-val)))
          (pcons frac-lex (box-float final-int final-frac scale)))
        ;; Integer
        (pcons int-lex (box-int (negate-if is-negative int-val))))))

;; Helper to read digits from start position
(defun read-number-from (start-lex: ptr is-neg: i64) -> ptr
  (let ((int-result (read-digits-raw start-lex 0))
        (int-val (icons-head int-result))
        (int-lex (icons-tail int-result)))
    (read-number-finish int-lex int-val is-neg)))

;; Returns (new-lexer . value) where value is BoxedInt or BoxedFloat
(defun read-number (lex: ptr) -> ptr
  (let ((c (peek-char lex)))
    (if (= c 45)  ;; -
        (read-number-from (advance-char lex) 1)
        (read-number-from lex 0))))

;; ============================================================================
;; Symbol Parsing
;; ============================================================================

;; Count symbol length from current position
(defun count-symbol-len (lex: ptr len: i64) -> i64
  (let ((c (peek-char-at lex len)))
    (if (symbol-char? c)
        (count-symbol-len lex (+ len 1))
        len)))

;; Copy n bytes from source to dest
(defun copy-bytes-loop (src: ptr dest: ptr n: i64 idx: i64) -> i64
  (if (>= idx n)
      n
      (let ((b (load-byte (ptr+ src idx)))
            (s (store-byte (ptr+ dest idx) b)))
        (copy-bytes-loop src dest n (+ idx 1)))))

(defun copy-bytes (src: ptr dest: ptr n: i64) -> i64
  (copy-bytes-loop src dest n 0))

;; Check if buffer matches "true" (4 chars: 116 114 117 101)
(defun is-true-str? (buf: ptr len: i64) -> i64
  (if (= len 4)
      (if (= (zext i64 (load-byte buf)) 116)           ;; t
          (if (= (zext i64 (load-byte (ptr+ buf 1))) 114) ;; r
              (if (= (zext i64 (load-byte (ptr+ buf 2))) 117) ;; u
                  (if (= (zext i64 (load-byte (ptr+ buf 3))) 101) ;; e
                      1
                      0)
                  0)
              0)
          0)
      0))

;; Check if buffer matches "false" (5 chars: 102 97 108 115 101)
(defun is-false-str? (buf: ptr len: i64) -> i64
  (if (= len 5)
      (if (= (zext i64 (load-byte buf)) 102)           ;; f
          (if (= (zext i64 (load-byte (ptr+ buf 1))) 97)  ;; a
              (if (= (zext i64 (load-byte (ptr+ buf 2))) 108) ;; l
                  (if (= (zext i64 (load-byte (ptr+ buf 3))) 115) ;; s
                      (if (= (zext i64 (load-byte (ptr+ buf 4))) 101) ;; e
                          1
                          0)
                      0)
                  0)
              0)
          0)
      0))

;; Read a symbol and intern it
;; Returns (new-lexer . symbol)
;; Special handling: "true" and "false" return BoxedBool values
(defun read-symbol (lex: ptr table: ptr) -> ptr
  (let ((start-pos (lexer-pos lex))
        (len (count-symbol-len lex 0))
        ;; Allocate buffer for symbol name + null terminator
        (buf (heap-array (+ len 1)))
        (c (copy-bytes (ptr+ (lexer-src lex) start-pos) buf len))
        ;; Null-terminate
        (s (store-byte (ptr+ buf len) 0))
        ;; Advance lexer past the symbol
        (new-lex (advance-n lex len)))
    ;; Check for boolean literals
    (if (= 1 (is-true-str? buf len))
        (pcons new-lex (box-bool 1))
        (if (= 1 (is-false-str? buf len))
            (pcons new-lex (box-bool 0))
            ;; Regular symbol - intern it
            (pcons new-lex (intern table buf))))))

;; ============================================================================
;; String Parsing
;; ============================================================================

;; Count string length (stopping at closing quote or EOF)
;; Handles escape sequences for length calculation
(defun count-string-len (lex: ptr len: i64) -> i64
  (let ((c (peek-char-at lex len)))
    (if (eof? c) len  ;; unclosed string
        (if (= c 34) len  ;; closing quote
            (if (= c 92)  ;; backslash escape
                (count-string-len lex (+ len 2))  ;; skip escape sequence
                (count-string-len lex (+ len 1)))))))

;; Decode escape character
(defun decode-escape (next: i64) -> i64
  (cond
    ((= next 110) 10)    ;; \n -> newline
    ((= next 116) 9)     ;; \t -> tab
    ((= next 114) 13)    ;; \r -> CR
    ((= next 34) 34)     ;; \" -> "
    ((= next 92) 92)     ;; \\ -> \
    (else next)))        ;; unknown: keep as-is

;; Copy string with escape processing
(defun copy-string-loop (src: ptr dest: ptr src-idx dest-idx end) -> i64
  (if (>= src-idx end)
      dest-idx  ;; return final length
      (let ((c (zext i64 (load-byte (ptr+ src src-idx)))))
        (if (= c 92)  ;; backslash
            (let ((next (zext i64 (load-byte (ptr+ src (+ src-idx 1)))))
                  (escaped (decode-escape next))
                  (s (store-byte (ptr+ dest dest-idx) (trunc i8 escaped))))
              (copy-string-loop src dest (+ src-idx 2) (+ dest-idx 1) end))
            (let ((s (store-byte (ptr+ dest dest-idx) (trunc i8 c))))
              (copy-string-loop src dest (+ src-idx 1) (+ dest-idx 1) end))))))

;; Read a string literal
;; Returns (new-lexer . liar-string)
(defun read-string (lex: ptr) -> ptr
  (let ((start-lex (advance-char lex))  ;; skip opening quote
        (start-pos (lexer-pos start-lex))
        (raw-len (count-string-len start-lex 0))
        ;; Allocate buffer (may be smaller after escape processing)
        (buf (heap-array (+ raw-len 1)))
        (actual-len (copy-string-loop (ptr+ (lexer-src start-lex) 0)
                                       buf start-pos (+ start-pos raw-len) 0))
        ;; Null-terminate
        (s (store-byte (ptr+ buf actual-len) 0))
        ;; Advance past string content and closing quote
        (end-lex (advance-n start-lex (+ raw-len 1))))
    (pcons end-lex (liar-string buf actual-len))))

;; ============================================================================
;; List Parsing
;; ============================================================================

;; Read list elements until )
;; Returns (new-lexer . scons-list)
;; Note: Uses forward reference to read-value (defined later)
(defun read-list-elements (lex: ptr table: ptr) -> ptr
  (let ((lex2 (skip-ws lex))
        (c (peek-char lex2))
        (line (lexer-line lex2))
        (col (lexer-col lex2)))
    (if (= c 41)  ;; )
        (pcons (advance-char lex2) nil)  ;; end of list
        (if (eof? c)
            (pcons lex2 nil)  ;; unclosed list (error case)
            (let ((elem-result (read-value lex2 table))
                  (elem-lex (pcons-head elem-result))
                  (elem-val (pcons-tail elem-result))
                  (rest-result (read-list-elements elem-lex table))
                  (rest-lex (pcons-head rest-result))
                  (rest-list (pcons-tail rest-result)))
              (pcons rest-lex (scons-loc elem-val rest-list line col)))))))

;; Read a list: ( ... )
;; Returns (new-lexer . scons-list)
(defun read-list (lex: ptr table: ptr) -> ptr
  (let ((start-lex (advance-char lex)))  ;; skip (
    (read-list-elements start-lex table)))

;; ============================================================================
;; Vector Parsing - parsed as lists for bootstrap
;; ============================================================================

;; Read vector elements until ]
;; Returns (new-lexer . scons-list)
(defun read-vector-elements (lex: ptr table: ptr) -> ptr
  (let ((lex2 (skip-ws lex))
        (c (peek-char lex2))
        (line (lexer-line lex2))
        (col (lexer-col lex2)))
    (if (= c 93)  ;; ]
        (pcons (advance-char lex2) nil)  ;; end of vector
        (if (eof? c)
            (pcons lex2 nil)  ;; unclosed vector
            (let ((elem-result (read-value lex2 table))
                  (elem-lex (pcons-head elem-result))
                  (elem-val (pcons-tail elem-result))
                  (rest-result (read-vector-elements elem-lex table))
                  (rest-lex (pcons-head rest-result))
                  (rest-list (pcons-tail rest-result)))
              (pcons rest-lex (scons-loc elem-val rest-list line col)))))))

;; Read a vector: [ ... ]
;; Parsed as a list for now (sufficient for protocol param lists).
(defun read-vector (lex: ptr table: ptr) -> ptr
  (let ((start-lex (advance-char lex)))  ;; skip [
    (read-vector-elements start-lex table)))

;; ============================================================================
;; Quote Handling
;; ============================================================================

;; Create the "quote" string as a ptr (since string literals are type 'string', not 'ptr')
;; "quote" = 113, 117, 111, 116, 101, 0
(defun make-quote-str () -> ptr
  (let ((buf (heap-array 6))
        (s1 (store-byte buf 113))         ;; q
        (s2 (store-byte (ptr+ buf 1) 117)) ;; u
        (s3 (store-byte (ptr+ buf 2) 111)) ;; o
        (s4 (store-byte (ptr+ buf 3) 116)) ;; t
        (s5 (store-byte (ptr+ buf 4) 101)) ;; e
        (s6 (store-byte (ptr+ buf 5) 0)))  ;; null
    buf))

;; Read 'x -> (quote x)
(defun read-quote (lex: ptr table: ptr) -> ptr
  (let ((start-lex (advance-char lex))  ;; skip '
        (line (lexer-line lex))
        (col (lexer-col lex))
        ;; Create "quote" string as ptr
        (quote-str (make-quote-str))
        (quote-sym (intern table quote-str))
        ;; Read the quoted value
        (val-result (read-value start-lex table))
        (val-lex (pcons-head val-result))
        (val (pcons-tail val-result)))
    (pcons val-lex (scons-loc quote-sym (scons-loc val nil line col) line col))))

;; ============================================================================
;; Keyword Parsing
;; ============================================================================

;; Read :keyword
;; Returns (new-lexer . keyword-symbol)
(defun read-keyword (lex: ptr table: ptr) -> ptr
  (let ((start-lex (advance-char lex))  ;; skip :
        (start-pos (lexer-pos start-lex))
        (len (count-symbol-len start-lex 0))
        ;; Allocate buffer with : prefix
        (buf (heap-array (+ len 2)))
        (s1 (store-byte buf 58))  ;; :
        (c (copy-bytes (ptr+ (lexer-src start-lex) start-pos) (ptr+ buf 1) len))
        (s2 (store-byte (ptr+ buf (+ len 1)) 0))  ;; null terminate
        (new-lex (advance-n start-lex len))
        (sym (intern table buf)))
    (pcons new-lex sym)))

;; ============================================================================
;; Map Parsing - STUB for bootstrap
;; ============================================================================

;; Skip until closing brace
(defun skip-until-brace (lex: ptr) -> ptr
  (let ((c (peek-char lex)))
    (if (= c 125)  ;; }
        (advance-char lex)
        (if (eof? c)
            lex
            (skip-until-brace (advance-char lex))))))

;; Read a map: { k1 v1 k2 v2 ... } - STUB returns nil
;; Map literals not supported in bootstrap compiler
(defun read-map (lex: ptr table: ptr) -> ptr
  (let ((end-lex (skip-until-brace (advance-char lex))))
    (pcons end-lex nil)))

;; ============================================================================
;; Quasiquote / Unquote Handling
;; ============================================================================

;; Create "quasiquote" string as ptr
;; "quasiquote" = 113 117 97 115 105 113 117 111 116 101 0
(defun make-quasiquote-str () -> ptr
  (let ((buf (heap-array 11))
        (s0 (store-byte buf 113))          ;; q
        (s1 (store-byte (ptr+ buf 1) 117)) ;; u
        (s2 (store-byte (ptr+ buf 2) 97))  ;; a
        (s3 (store-byte (ptr+ buf 3) 115)) ;; s
        (s4 (store-byte (ptr+ buf 4) 105)) ;; i
        (s5 (store-byte (ptr+ buf 5) 113)) ;; q
        (s6 (store-byte (ptr+ buf 6) 117)) ;; u
        (s7 (store-byte (ptr+ buf 7) 111)) ;; o
        (s8 (store-byte (ptr+ buf 8) 116)) ;; t
        (s9 (store-byte (ptr+ buf 9) 101)) ;; e
        (sa (store-byte (ptr+ buf 10) 0))) ;; null
    buf))

;; Create "unquote" string as ptr
;; "unquote" = 117 110 113 117 111 116 101 0
(defun make-unquote-str () -> ptr
  (let ((buf (heap-array 8))
        (s0 (store-byte buf 117))          ;; u
        (s1 (store-byte (ptr+ buf 1) 110)) ;; n
        (s2 (store-byte (ptr+ buf 2) 113)) ;; q
        (s3 (store-byte (ptr+ buf 3) 117)) ;; u
        (s4 (store-byte (ptr+ buf 4) 111)) ;; o
        (s5 (store-byte (ptr+ buf 5) 116)) ;; t
        (s6 (store-byte (ptr+ buf 6) 101)) ;; e
        (s7 (store-byte (ptr+ buf 7) 0)))  ;; null
    buf))

;; Create "unquote-splicing" string as ptr
;; "unquote-splicing" = 117 110 113 117 111 116 101 45 115 112 108 105 99 105 110 103 0
(defun make-unquote-splicing-str () -> ptr
  (let ((buf (heap-array 17))
        (s00 (store-byte buf 117))          ;; u
        (s01 (store-byte (ptr+ buf 1) 110)) ;; n
        (s02 (store-byte (ptr+ buf 2) 113)) ;; q
        (s03 (store-byte (ptr+ buf 3) 117)) ;; u
        (s04 (store-byte (ptr+ buf 4) 111)) ;; o
        (s05 (store-byte (ptr+ buf 5) 116)) ;; t
        (s06 (store-byte (ptr+ buf 6) 101)) ;; e
        (s07 (store-byte (ptr+ buf 7) 45))  ;; -
        (s08 (store-byte (ptr+ buf 8) 115)) ;; s
        (s09 (store-byte (ptr+ buf 9) 112)) ;; p
        (s10 (store-byte (ptr+ buf 10) 108)) ;; l
        (s11 (store-byte (ptr+ buf 11) 105)) ;; i
        (s12 (store-byte (ptr+ buf 12) 99))  ;; c
        (s13 (store-byte (ptr+ buf 13) 105)) ;; i
        (s14 (store-byte (ptr+ buf 14) 110)) ;; n
        (s15 (store-byte (ptr+ buf 15) 103)) ;; g
        (s16 (store-byte (ptr+ buf 16) 0)))  ;; null
    buf))

;; Read `x -> (quasiquote x)
(defun read-quasiquote (lex: ptr table: ptr) -> ptr
  (let ((start-lex (advance-char lex))  ;; skip `
        (line (lexer-line lex))
        (col (lexer-col lex))
        (qq-str (make-quasiquote-str))
        (qq-sym (intern table qq-str))
        (val-result (read-value start-lex table))
        (val-lex (pcons-head val-result))
        (val (pcons-tail val-result)))
    (pcons val-lex (scons-loc qq-sym (scons-loc val nil line col) line col))))

;; Helper for unquote dispatch
(defun read-unquote-inner (start-lex: ptr table: ptr line: i64 col: i64 next-c: i64) -> ptr
  (if (= next-c 64)  ;; @ - unquote-splicing
      (let ((lex2 (advance-char start-lex))  ;; skip @
            (us-str (make-unquote-splicing-str))
            (us-sym (intern table us-str))
            (val-result (read-value lex2 table))
            (val-lex (pcons-head val-result))
            (val (pcons-tail val-result)))
        (pcons val-lex (scons-loc us-sym (scons-loc val nil line col) line col)))
      ;; Regular unquote
      (let ((uq-str (make-unquote-str))
            (uq-sym (intern table uq-str))
            (val-result (read-value start-lex table))
            (val-lex (pcons-head val-result))
            (val (pcons-tail val-result)))
        (pcons val-lex (scons-loc uq-sym (scons-loc val nil line col) line col)))))

;; Read ~x -> (unquote x) or ~@x -> (unquote-splicing x)
(defun read-unquote (lex: ptr table: ptr) -> ptr
  (let ((start-lex (advance-char lex))  ;; skip ~
        (line (lexer-line lex))
        (col (lexer-col lex))
        (next-c (peek-char start-lex)))
    (read-unquote-inner start-lex table line col next-c)))

;; ============================================================================
;; Main Dispatcher
;; ============================================================================

;; Read a single value from the lexer
;; Returns (new-lexer . value) as a pcons pair
(defun read-value (lex: ptr table: ptr) -> ptr
  (let ((lex2 (skip-ws lex))
        (c (peek-char lex2)))
    (cond
      ((eof? c)         (pcons lex2 nil))
      ((= c 40)         (read-list lex2 table))        ;; (
      ((= c 91)         (read-vector lex2 table))      ;; [
      ((= c 123)        (read-map lex2 table))         ;; {
      ((= c 34)         (read-string lex2))            ;; "
      ((= c 58)         (read-keyword lex2 table))     ;; :
      ((= c 39)         (read-quote lex2 table))       ;; '
      ((= c 96)         (read-quasiquote lex2 table))  ;; `
      ((= c 126)        (read-unquote lex2 table))     ;; ~
      ((= c 44)         (read-unquote lex2 table))     ;; , (comma also means unquote)
      ((digit? c)       (read-number lex2))
      ((= c 45)         (if (digit? (peek-char-at lex2 1))   ;; - number or symbol
                            (read-number lex2)
                            (read-symbol lex2 table)))
      ((symbol-start? c) (read-symbol lex2 table))
      (else             (pcons (advance-char lex2) nil)))))

;; ============================================================================
;; Top-Level Interface
;; ============================================================================

;; Read all expressions from source text
;; Returns a list of SCons expressions (in reverse order)
(defun read-all-loop (lex: ptr table: ptr acc: ptr) -> ptr
  (let ((lex2 (skip-ws lex))
        (c (peek-char lex2)))
    (if (eof? c)
        acc  ;; done - return accumulated list
        (let ((result (read-value lex2 table))
              (new-lex (pcons-head result))
              (val (pcons-tail result)))
          (if (nil? val)
              acc  ;; no value read, done
              (read-all-loop new-lex table (scons val acc)))))))

;; Reverse a list
(defun reverse-list-loop (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      acc
      (reverse-list-loop (scons-tail lst)
                         (scons (scons-head lst) acc))))

(defun reverse-list (lst: ptr) -> ptr
  (reverse-list-loop lst nil))

;; Read all expressions from source
;; Returns a list of SCons expressions in correct order
(defun read-all (src: ptr len: i64 table: ptr) -> ptr
  (let ((lex (make-lexer src len))
        (exprs (read-all-loop lex table nil)))
    (reverse-list exprs)))

;; Note: strlen is declared as extern in main.liar and io.liar
;; We used to have a liar implementation here but it's not needed
