;; symbols.liar - Symbol interning for the liar reader
;;
;; Symbols are interned so that identical symbol names share the same id.
;; This enables fast equality checks (compare ids instead of strings).
;;
;; Architecture:
;;   - Symbol struct holds the interned id and a pointer to the name string
;;   - StringMap provides O(1) lookup by name -> Symbol
;;   - Counter tracks next symbol id for new symbols

(ns liarliar.symbols
  (:require [liar.stringmap :refer [string-map sm-get sm-assoc streq]]))

;; --- Symbol struct ---

(defstruct Symbol (sym-id: i64 sym-name: ptr))

(defun symbol-id (s: ptr) -> i64
  (. s sym-id))

(defun symbol-name (s: ptr) -> ptr
  (. s sym-name))

(defun symbol? (x: ptr)
  (instance? x Symbol))


;; --- Symbol table using StringMap ---
;; Uses StringMap for O(1) average-case lookup instead of O(n) linear scan.
;; Stores: mutable pointer to map, next-id counter
;; Both are stored in a data array: [map-ptr, next-id]

(defstruct SymbolTable (sym-tab-data: ptr))

;; Create a new symbol table
;; The capacity parameter is ignored (StringMap handles sizing internally)
(defun make-symbol-table (cap) -> ptr
  (let ((data (heap-array-ptr 2))
        (s0 (aset-ptr data 0 (string-map)))  ;; map pointer
        (s1 (aset data 1 0)))                ;; next id starts at 0
    (share (SymbolTable data))))

(defun sym-table-count (t: ptr) -> i64
  (aget (. t sym-tab-data) 1))

;; Get current map from mutable slot
(defun sym-table-map (t: ptr) -> ptr
  (aget-ptr (. t sym-tab-data) 0))

;; Update map in mutable slot
(defun sym-table-set-map! (t: ptr m: ptr) -> i64
  (aset-ptr (. t sym-tab-data) 0 m))


;; --- Interning ---

;; Intern a symbol: return existing or create new
;; Returns a Symbol struct pointer
(defun intern (table: ptr name) -> ptr
  (let ((m (sym-table-map table))
        (existing (sm-get m name)))
    (if (nil? existing)
        ;; Not found - create new symbol and update map
        (let ((data (. table sym-tab-data))
              (new-id (aget data 1))
              (sym (share (Symbol new-id name)))
              (new-map (sm-assoc m name sym))
              (s1 (sym-table-set-map! table new-map))
              (s2 (aset data 1 (+ new-id 1))))
          sym)
        ;; Found - return existing symbol
        existing)))
