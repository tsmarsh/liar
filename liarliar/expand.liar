;; expand.liar - Macro expansion for the liarliar compiler
;;
;; Expands macros by pattern matching on S-expression structure.
;; Handles quasiquote, unquote, unquote-splicing, and user-defined macros.
;;
;; Dependencies: value.liar, symbols.liar

(ns liarliar.expand
  (:require [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]
            [liarliar.strings :refer :all]))

;; ============================================================================
;; Expansion Context
;; ============================================================================

;; Context holds macro definitions, struct info, and gensym counter
;; Macros are stored as a list of (name params body) triples
;; Structs are stored as a list of (name fields) entries
(defstruct ExpandContext
  (ctx-macros: ptr
   ctx-gensym: i64
   ctx-symbols: ptr
   ctx-structs: ptr))

(defun make-expand-context (symbols: ptr) -> ptr
  (share (ExpandContext nil 0 symbols nil)))

(defun ctx-macros (ctx: ptr) -> ptr
  (. ctx ctx-macros))

(defun ctx-gensym-counter (ctx: ptr) -> i64
  (. ctx ctx-gensym))

(defun ctx-symbols (ctx: ptr) -> ptr
  (. ctx ctx-symbols))

(defun ctx-structs (ctx: ptr) -> ptr
  (. ctx ctx-structs))

;; ============================================================================
;; Symbol Comparison Helpers
;; ============================================================================

;; Check if a symbol has a given name (null-terminated string)
;; Returns i64: 1 if equal, 0 otherwise (matches streq return type)
(defun symbol-name-eq (sym: ptr name: ptr) -> i64
  (if (symbol? sym)
      (streq (symbol-name sym) name)
      0))

;; Build well-known symbol names as byte arrays
;; "quote" = 113 117 111 116 101 0
(defun make-quote-name () -> ptr
  (let ((sb (string-builder-cap 6))
        (sb (sb-conj sb 113))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 111))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 101)))
    (to-string sb)))

;; "quasiquote" = 113 117 97 115 105 113 117 111 116 101 0
(defun make-quasiquote-name () -> ptr
  (let ((sb (string-builder-cap 11))
        (sb (sb-conj sb 113))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 113))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 111))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 101)))
    (to-string sb)))

;; "unquote" = 117 110 113 117 111 116 101 0
(defun make-unquote-name () -> ptr
  (let ((sb (string-builder-cap 8))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 113))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 111))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 101)))
    (to-string sb)))

;; "unquote-splicing" = 117 110 113 117 111 116 101 45 115 112 108 105 99 105 110 103 0
(defun make-unquote-splicing-name () -> ptr
  (let ((sb (string-builder-cap 17))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 113))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 111))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 45))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 112))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 103)))
    (to-string sb)))

;; "defmacro" = 100 101 102 109 97 99 114 111 0
(defun make-defmacro-name () -> ptr
  (let ((sb (string-builder-cap 9))
        (sb (sb-conj sb 100))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 109))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 111)))
    (to-string sb)))

;; "defstruct" = 100 101 102 115 116 114 117 99 116 0
(defun make-defstruct-name () -> ptr
  (let ((sb (string-builder-cap 10))
        (sb (sb-conj sb 100))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 116)))
    (to-string sb)))

;; "..." = 46 46 46 0
(defun make-ellipsis-name () -> ptr
  (let ((sb (string-builder-cap 4))
        (sb (sb-conj sb 46))
        (sb (sb-conj sb 46))
        (sb (sb-conj sb 46)))
    (to-string sb)))

;; ============================================================================
;; Form Predicates
;; ============================================================================

;; Check if form is a list starting with a symbol matching the given name
;; Returns i64: 1 if matches, 0 otherwise
(defun form-starts-with (form: ptr name: ptr) -> i64
  (if (nil? form)
      0
      (if (scons? form)
          (let ((head (scons-head form)))
            (symbol-name-eq head name))
          0)))

;; Predicate: is this (quote ...)?
(defun quote-form? (form: ptr)
  (form-starts-with form (make-quote-name)))

;; Predicate: is this (quasiquote ...)?
(defun quasiquote-form? (form: ptr)
  (form-starts-with form (make-quasiquote-name)))

;; Predicate: is this (unquote ...)?
(defun unquote-form? (form: ptr)
  (form-starts-with form (make-unquote-name)))

;; Predicate: is this (unquote-splicing ...)?
(defun unquote-splicing-form? (form: ptr)
  (form-starts-with form (make-unquote-splicing-name)))

;; Predicate: is this (defmacro ...)?
(defun defmacro-form? (form: ptr)
  (form-starts-with form (make-defmacro-name)))

;; Predicate: is this (defstruct ...)?
(defun defstruct-form? (form: ptr)
  (form-starts-with form (make-defstruct-name)))

;; Predicate: is this "..."?
(defun ellipsis-sym? (sym: ptr)
  (symbol-name-eq sym (make-ellipsis-name)))

;; ============================================================================
;; Macro Table Operations
;; ============================================================================

;; Macro entry: (pcons name (pcons params body))
(defstruct MacroEntry (macro-name: ptr macro-params: ptr macro-body: ptr))

(defun make-macro-entry (name: ptr params: ptr body: ptr) -> ptr
  (share (MacroEntry name params body)))

(defun macro-entry-name (e: ptr) -> ptr
  (. e macro-name))

(defun macro-entry-params (e: ptr) -> ptr
  (. e macro-params))

(defun macro-entry-body (e: ptr) -> ptr
  (. e macro-body))

;; Find a macro by name in the context
(defun find-macro-loop (macros: ptr name: ptr) -> ptr
  (if (nil? macros)
      nil
      (let ((entry (pcons-head macros)))
        (if (symbol-name-eq (macro-entry-name entry) (symbol-name name))
            entry
            (find-macro-loop (pcons-tail macros) name)))))

(defun find-macro (ctx: ptr name: ptr) -> ptr
  (find-macro-loop (ctx-macros ctx) name))

;; Struct entry: (name fields)
(defstruct StructEntry (struct-name: ptr struct-fields: ptr))

(defun make-struct-entry (name: ptr fields: ptr) -> ptr
  (share (StructEntry name fields)))

(defun struct-entry-name (e: ptr) -> ptr
  (. e struct-name))

(defun struct-entry-fields (e: ptr) -> ptr
  (. e struct-fields))

(defun find-struct-loop (structs: ptr name: ptr) -> ptr
  (if (nil? structs)
      nil
      (let ((entry (pcons-head structs)))
        (if (symbol-name-eq (struct-entry-name entry) (symbol-name name))
            entry
            (find-struct-loop (pcons-tail structs) name)))))

(defun find-struct (ctx: ptr name: ptr) -> ptr
  (find-struct-loop (ctx-structs ctx) name))

;; Check if a form is a macro call
(defun macro-call? (ctx: ptr form: ptr)
  (if (scons? form)
      (let ((head (scons-head form)))
        (if (symbol? head)
            (not (nil? (find-macro ctx head)))
            false))
      false))

;; ============================================================================
;; Quasiquote Expansion (Compile-Time Template Substitution)
;; ============================================================================
;;
;; Quasiquote (`x) is a compile-time template mechanism for macros.
;; It produces the actual S-expression structure directly, not code to build it.
;;
;; Example: `(+ ,x 1) with x=5 produces the S-expression (+ 5 1)
;;          NOT (cons (quote +) (cons 5 (cons 1 nil)))

;; Append two scons lists at compile time
(defun append-scons (a: ptr b: ptr) -> ptr
  (if (nil? a)
      b
      (scons (scons-head a) (append-scons (scons-tail a) b))))

;; Expand quasiquote on a list element by element
;; Returns the actual S-expression structure (compile-time)
(defun expand-qq-list (ctx: ptr form: ptr) -> ptr
  (if (nil? form)
      nil
      (let ((head (scons-head form))
            (tail (scons-tail form)))
        (if (unquote-splicing-form? head)
            ;; ~@xs - splice elements directly into the list
            (let ((spliced (cadr head))
                  (rest (expand-qq-list ctx tail)))
              (if (nil? spliced)
                  rest
                  (if (scons? spliced)
                      (append-scons spliced rest)
                      ;; spliced is not a list - just include it
                      (scons spliced rest))))
            ;; Regular element: build scons with expanded head
            (scons (expand-qq ctx head)
                   (expand-qq-list ctx tail))))))

;; Main quasiquote expansion - compile-time template substitution
;; `x where x may contain ~y and ~@z
(defun expand-qq (ctx: ptr form: ptr) -> ptr
  (if (unquote-form? form)
      ;; ~x - return x directly (already substituted by macro expansion)
      (cadr form)
      (if (unquote-splicing-form? form)
          ;; ~@x at top level is an error (can't splice into non-list context)
          nil
          (if (scons? form)
              ;; List: expand each element, building scons structure
              (expand-qq-list ctx form)
              ;; Atom (symbol, number, etc.): return as-is
              form))))

;; ============================================================================
;; Struct Registration (for compile-time reflection)
;; ============================================================================

;; Extract field names from (x: i64 y: i64) -> (x y)
(defun extract-struct-field-names (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (extract-struct-field-names (cdr rest2) (scons name acc))))))))

;; Register a struct definition, return updated context
(defun register-struct (ctx: ptr form: ptr) -> ptr
  ;; (defstruct Name (x: i64 y: i64))
  (let ((name (cadr form))
        (fields (caddr form))
        (field-names (extract-struct-field-names fields nil))
        (entry (make-struct-entry name field-names))
        (new-structs (pcons entry (ctx-structs ctx))))
    (share (ExpandContext (ctx-macros ctx)
                          (ctx-gensym-counter ctx)
                          (ctx-symbols ctx)
                          new-structs))))

;; ============================================================================
;; Macro Evaluation (compile-time interpreter)
;; ============================================================================

(defstruct MacroClosure (closure-env: ptr closure-params: ptr closure-body: ptr))

(defun make-closure (env: ptr params: ptr body: ptr) -> ptr
  (share (MacroClosure env params body)))

(defun closure? (v: ptr) -> i64
  (instance? v MacroClosure))

(defun closure-env (c: ptr) -> ptr (. c closure-env))
(defun closure-params (c: ptr) -> ptr (. c closure-params))
(defun closure-body (c: ptr) -> ptr (. c closure-body))

(defun truthy? (v: ptr) -> i64
  (if (nil? v)
      0
      (if (boxed-bool? v)
          (unbox-bool v)
          1)))

(defun env-lookup (sym: ptr env: ptr) -> ptr
  (let ((binding (lookup-env sym env)))
    (if (nil? binding) nil (pcons-tail binding))))

(defun env-extend (env: ptr sym: ptr val: ptr) -> ptr
  (pcons (pcons sym val) env))

;; --- Builtin name helpers ---

(defun make-if-name () -> ptr
  (let ((sb (string-builder-cap 3))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 102)))
    (to-string sb)))

(defun make-let-name () -> ptr
  (let ((sb (string-builder-cap 4))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 116)))
    (to-string sb)))

(defun make-fn-name () -> ptr
  (let ((sb (string-builder-cap 3))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 110)))
    (to-string sb)))

(defun make-do-name () -> ptr
  (let ((sb (string-builder-cap 3))
        (sb (sb-conj sb 100))
        (sb (sb-conj sb 111)))
    (to-string sb)))

(defun make-list-name () -> ptr
  (let ((sb (string-builder-cap 5))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 116)))
    (to-string sb)))

(defun make-cons-name () -> ptr
  (let ((sb (string-builder-cap 5))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 111))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 115)))
    (to-string sb)))

(defun make-first-name () -> ptr
  (let ((sb (string-builder-cap 6))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 116)))
    (to-string sb)))

(defun make-rest-name () -> ptr
  (let ((sb (string-builder-cap 5))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 116)))
    (to-string sb)))

(defun make-map-name () -> ptr
  (let ((sb (string-builder-cap 4))
        (sb (sb-conj sb 109))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 112)))
    (to-string sb)))

(defun make-nil?-name () -> ptr
  (let ((sb (string-builder-cap 5))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 63)))
    (to-string sb)))

(defun make-list?-name () -> ptr
  (let ((sb (string-builder-cap 6))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 63)))
    (to-string sb)))

(defun make-eq-name () -> ptr
  (let ((sb (string-builder-cap 2))
        (sb (sb-conj sb 61)))
    (to-string sb)))

(defun make-struct-fields-name () -> ptr
  (let ((sb (string-builder-cap 14))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 116))
        (sb (sb-conj sb 45))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 100))
        (sb (sb-conj sb 115)))
    (to-string sb)))

(defun make-make-field-access-name () -> ptr
  (let ((sb (string-builder-cap 18))
        (sb (sb-conj sb 109))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 107))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 45))
        (sb (sb-conj sb 102))
        (sb (sb-conj sb 105))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 100))
        (sb (sb-conj sb 45))
        (sb (sb-conj sb 97))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 115)))
    (to-string sb)))

(defun make-dot-name () -> ptr
  (let ((sb (string-builder-cap 2))
        (sb (sb-conj sb 46)))
    (to-string sb)))

(defun eval-symbol (env: ptr sym: ptr) -> ptr
  (let ((binding (env-lookup sym env)))
    (if (nil? binding) sym binding)))

(defun eval-args (ctx: ptr env: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (reverse-scons acc)
      (let ((val (eval-form ctx env (scons-head args))))
        (eval-args ctx env (scons-tail args) (scons val acc)))))

(defun eval-qq-list (ctx: ptr env: ptr form: ptr) -> ptr
  (if (nil? form)
      nil
      (let ((head (scons-head form))
            (tail (scons-tail form)))
        (if (unquote-splicing-form? head)
            (let ((spliced (eval-form ctx env (cadr head)))
                  (rest (eval-qq-list ctx env tail)))
              (if (nil? spliced)
                  rest
                  (if (scons? spliced)
                      (append-scons spliced rest)
                      (scons spliced rest))))
            (scons (eval-qq ctx env head)
                   (eval-qq-list ctx env tail))))))

(defun eval-qq (ctx: ptr env: ptr form: ptr) -> ptr
  (if (unquote-form? form)
      (eval-form ctx env (cadr form))
      (if (unquote-splicing-form? form)
          nil
          (if (scons? form)
              (eval-qq-list ctx env form)
              form))))

(defun eval-eq (a: ptr b: ptr) -> i64
  (if (and (symbol? a) (symbol? b))
      (symbol-name-eq a (symbol-name b))
      (if (and (boxed-int? a) (boxed-int? b))
          (if (= (unbox-int a) (unbox-int b)) 1 0)
          (if (and (boxed-bool? a) (boxed-bool? b))
              (if (= (unbox-bool a) (unbox-bool b)) 1 0)
              (if (= a b) 1 0)))))

(defun apply-closure (ctx: ptr env: ptr clo: ptr args: ptr) -> ptr
  (let ((params (closure-params clo))
        (body (closure-body clo)))
    (let ((new-env (bind-params env params args)))
      (eval-form ctx new-env body))))

(defun bind-params (env: ptr params: ptr args: ptr) -> ptr
  (if (nil? params)
      env
      (let ((param (scons-head params))
            (arg (if (nil? args) nil (scons-head args))))
        (bind-params (env-extend env param arg)
                     (scons-tail params)
                     (if (nil? args) nil (scons-tail args))))))

(defun eval-map-loop (ctx: ptr env: ptr f: ptr lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((item (scons-head lst))
            (rest (scons-tail lst)))
        (let ((result (apply-closure ctx env f (scons item nil))))
          (eval-map-loop ctx env f rest (scons result acc))))))

(defun eval-builtin (ctx: ptr env: ptr head: ptr args: ptr) -> ptr
  (cond
    ((symbol-name-eq head (make-list-name))
     (eval-args ctx env args nil))
    ((symbol-name-eq head (make-cons-name))
     (let ((a (eval-form ctx env (scons-head args)))
           (d (eval-form ctx env (cadr args))))
       (scons a d)))
    ((symbol-name-eq head (make-first-name))
     (let ((lst (eval-form ctx env (scons-head args))))
       (if (scons? lst) (scons-head lst) nil)))
    ((symbol-name-eq head (make-rest-name))
     (let ((lst (eval-form ctx env (scons-head args))))
       (if (scons? lst) (scons-tail lst) nil)))
    ((symbol-name-eq head (make-list?-name))
     (let ((lst (eval-form ctx env (scons-head args))))
       (box-bool (if (or (nil? lst) (scons? lst)) 1 0))))
    ((symbol-name-eq head (make-nil?-name))
     (let ((v (eval-form ctx env (scons-head args))))
       (box-bool (if (nil? v) 1 0))))
    ((symbol-name-eq head (make-eq-name))
     (let ((a (eval-form ctx env (scons-head args)))
           (b (eval-form ctx env (cadr args))))
       (box-bool (eval-eq a b))))
    ((symbol-name-eq head (make-map-name))
     (let ((f (eval-form ctx env (scons-head args)))
           (lst (eval-form ctx env (cadr args))))
       (if (and (closure? f) (scons? lst))
           (eval-map-loop ctx env f lst nil)
           nil)))
    ((symbol-name-eq head (make-struct-fields-name))
     (let ((name (eval-form ctx env (scons-head args)))
           (entry (if (symbol? name) (find-struct ctx name) nil)))
       (if (nil? entry) nil (struct-entry-fields entry))))
    ((symbol-name-eq head (make-make-field-access-name))
     (let ((inst (eval-form ctx env (scons-head args)))
           (field (eval-form ctx env (cadr args)))
           (dot (intern (ctx-symbols ctx) (make-dot-name))))
       (scons dot (scons inst (scons field nil)))))
    (else nil)))

(defun eval-list (ctx: ptr env: ptr form: ptr) -> ptr
  (let ((head (scons-head form))
        (args (scons-tail form)))
    (if (symbol? head)
        (cond
          ((symbol-name-eq head (make-quote-name)) (cadr form))
          ((symbol-name-eq head (make-quasiquote-name)) (eval-qq ctx env (cadr form)))
          ((symbol-name-eq head (make-if-name))
           (let ((cond-val (eval-form ctx env (cadr form))))
             (if (= 1 (truthy? cond-val))
                 (eval-form ctx env (caddr form))
                 (eval-form ctx env (cadddr form)))))
          ((symbol-name-eq head (make-let-name))
           (let ((bindings (cadr form))
                 (body (caddr form)))
             (eval-form ctx (eval-let ctx env bindings) body)))
          ((symbol-name-eq head (make-fn-name))
           (make-closure env (cadr form) (caddr form)))
          ((symbol-name-eq head (make-do-name))
           (eval-do ctx env args))
          ((macro-call? ctx form)
           (expand-macro ctx form))
          (else
           (let ((builtin (eval-builtin ctx env head args)))
             (if (nil? builtin)
                 (let ((val (eval-symbol env head)))
                   (if (closure? val)
                       (apply-closure ctx env val (eval-args ctx env args nil))
                       form))
                 builtin))))
        form)))

(defun eval-let (ctx: ptr env: ptr bindings: ptr) -> ptr
  (if (nil? bindings)
      env
      (let ((binding (scons-head bindings))
            (rest (scons-tail bindings)))
        (let ((name (scons-head binding))
              (value (eval-form ctx env (cadr binding))))
          (eval-let ctx (env-extend env name value) rest)))))

(defun eval-do (ctx: ptr env: ptr exprs: ptr) -> ptr
  (if (nil? exprs)
      nil
      (let ((result (eval-form ctx env (scons-head exprs))))
        (if (nil? (scons-tail exprs))
            result
            (eval-do ctx env (scons-tail exprs))))))

(defun eval-form (ctx: ptr env: ptr form: ptr) -> ptr
  (cond
    ((nil? form) nil)
    ((boxed-int? form) form)
    ((boxed-bool? form) form)
    ((boxed-float? form) form)
    ((liar-string? form) form)
    ((symbol? form) (eval-symbol env form))
    ((scons? form) (eval-list ctx env form))
    (else form)))

;; ============================================================================
;; Macro Expansion
;; ============================================================================

;; Substitute macro parameters with arguments in body
;; env is a list of (param . arg) pairs
(defun substitute (body: ptr env: ptr) -> ptr
  (if (nil? body)
      nil
      (if (symbol? body)
          ;; Look up symbol in environment
          (let ((binding (lookup-env body env)))
            (if (nil? binding)
                body  ;; not a parameter, keep as-is
                (pcons-tail binding)))  ;; found, return the argument
          (if (scons? body)
              ;; Recurse into list
              (scons (substitute (scons-head body) env)
                     (substitute (scons-tail body) env))
              ;; Other atoms: keep as-is
              body))))

;; Look up a symbol in the environment
(defun lookup-env (sym: ptr env: ptr) -> ptr
  (if (nil? env)
      nil
      (let ((binding (pcons-head env)))
        (let ((param (pcons-head binding)))
          (if (symbol-name-eq param (symbol-name sym))
              binding
              (lookup-env sym (pcons-tail env)))))))

;; Build environment from params list and args list
(defun build-env (params: ptr args: ptr) -> ptr
  (if (nil? params)
      nil
      (let ((param (scons-head params)))
        (if (ellipsis-sym? param)
            (let ((rest-param (scons-head (scons-tail params))))
              (if (nil? rest-param)
                  nil
                  (pcons (pcons rest-param args) nil)))
            (if (nil? args)
                nil
                (let ((arg (scons-head args))
                      (rest-env (build-env (scons-tail params) (scons-tail args))))
                  (pcons (pcons param arg) rest-env)))))))

;; Expand a macro call
(defun expand-macro (ctx: ptr form: ptr) -> ptr
  (let ((head (scons-head form))
        (args (scons-tail form))
        (entry (find-macro ctx head)))
    (if (nil? entry)
        form  ;; not a macro, return unchanged
        (let ((params (macro-entry-params entry))
              (body (macro-entry-body entry))
              (env (build-env params args))
              (result (eval-form ctx env body)))
          ;; Recursively expand the result
          (expand ctx result)))))

;; ============================================================================
;; Main Expander
;; ============================================================================

;; Register a macro definition, return updated context
(defun register-macro (ctx: ptr form: ptr) -> ptr
  ;; (defmacro name (params...) body)
  (let ((name (cadr form))
        (params (caddr form))
        (body (cadddr form))
        (entry (make-macro-entry name params body))
        (new-macros (pcons entry (ctx-macros ctx))))
    (share (ExpandContext new-macros
                          (ctx-gensym-counter ctx)
                          (ctx-symbols ctx)
                          (ctx-structs ctx)))))

;; Expand a single form (main entry point)
(defun expand (ctx: ptr form: ptr) -> ptr
  (if (nil? form)
      nil
      (if (quote-form? form)
          ;; 'x - return x unchanged
          (cadr form)
          (if (quasiquote-form? form)
              ;; `x - expand quasiquote, then expand result for nested macros
              (expand ctx (expand-qq ctx (cadr form)))
              (if (scons? form)
                  ;; List - could be macro call or regular form
                  (if (macro-call? ctx form)
                      (expand-macro ctx form)
                      ;; Not a macro - expand children
                      (expand-list ctx form))
                  ;; Atom - return unchanged
                  form)))))

;; Expand all elements of a list
(defun expand-list (ctx: ptr form: ptr) -> ptr
  (if (nil? form)
      nil
      (scons (expand ctx (scons-head form))
             (expand-list ctx (scons-tail form)))))

;; ============================================================================
;; Top-level: Expand all forms, collecting macro definitions
;; ============================================================================

;; Process a list of top-level forms
;; Returns (ctx . expanded-forms) as pcons
(defun expand-toplevel-loop (ctx: ptr forms: ptr acc: ptr) -> ptr
  (if (nil? forms)
      (pcons ctx (reverse-scons acc))
      (let ((form (scons-head forms))
            (rest (scons-tail forms)))
        (if (defmacro-form? form)
            ;; Register macro, don't include in output
            (let ((new-ctx (register-macro ctx form)))
              (expand-toplevel-loop new-ctx rest acc))
            (if (defstruct-form? form)
                ;; Register struct, then expand and include
                (let ((new-ctx (register-struct ctx form))
                      (expanded (expand new-ctx form)))
                  (expand-toplevel-loop new-ctx rest (scons expanded acc)))
                ;; Expand and include in output
                (let ((expanded (expand ctx form)))
                  (expand-toplevel-loop ctx rest (scons expanded acc))))))))

;; Main entry: expand all top-level forms
;; Returns pcons of (final-context . expanded-forms)
(defun expand-toplevel (symbols: ptr forms: ptr) -> ptr
  (let ((ctx (make-expand-context symbols)))
    (expand-toplevel-loop ctx forms nil)))

;; Expand all top-level forms with an existing context
(defun expand-toplevel-with-ctx (ctx: ptr forms: ptr) -> ptr
  (expand-toplevel-loop ctx forms nil))
