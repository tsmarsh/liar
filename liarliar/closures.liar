;; closures.liar - Closure conversion with capture analysis
;;
;; Closure conversion transforms lambdas into top-level functions with
;; explicit environment passing. This module:
;;
;; 1. Finds free variables in lambda bodies
;; 2. Determines capture mode (move/borrow/clone) per ADR 005
;; 3. Generates environment structs for captured variables
;; 4. Lifts lambdas to top-level functions
;; 5. Tracks closure color (let/plet/pure) per ADR 010
;;
;; Key insight: closures are just functions with a hidden first parameter
;; (the environment struct) that holds captured values.

(ns liarliar.closures
  (:require [liarliar.symbols :refer :all]
            [liarliar.env :refer :all]
            [liarliar.value :refer :all]
            [liarliar.strings :refer :all]))

;; ============================================================
;; Capture Modes (per ADR 005)
;; ============================================================

(def CAPTURE-MOVE 0)    ;; Transfer ownership into closure
(def CAPTURE-BORROW 1)  ;; Borrow reference (closure cannot escape)
(def CAPTURE-CLONE 2)   ;; Clone value into closure

;; ============================================================
;; Closure Colors (per ADR 010)
;; ============================================================
;;
;; Pure closures: No captures, can be called anywhere
;; Let closures: Captures from let/defun, single-threaded
;; Plet closures: Captures from plet (atoms), thread-safe

(def COLOR-PURE 0)
(def COLOR-LET 1)
(def COLOR-PLET 2)

;; ============================================================
;; Capture Info
;; ============================================================
;;
;; Tracks captured variables for a closure

(defstruct CaptureInfo
  (cap-sym-id: i64      ;; Symbol ID of captured var
   cap-mode: i64        ;; CAPTURE-* mode
   cap-next: ptr))      ;; Next capture (linked list)

(defun make-capture (sym-id mode: i64) -> ptr
  (share (CaptureInfo sym-id mode nil)))

(defun capture-sym-id (c: ptr) -> i64
  (. c cap-sym-id))

(defun capture-mode (c: ptr) -> i64
  (. c cap-mode))

(defun capture-next (c: ptr) -> ptr
  (. c cap-next))

;; Add capture to list
(defun captures-cons (c: ptr rest: ptr) -> ptr
  (share (CaptureInfo (capture-sym-id c) (capture-mode c) rest)))

;; ============================================================
;; Closure Info
;; ============================================================
;;
;; Complete closure conversion result

(defstruct ClosureInfo
  (clos-name: ptr       ;; Generated function name (symbol)
   clos-env-name: ptr   ;; Generated env struct name (symbol)
   clos-captures: ptr   ;; CaptureInfo list
   clos-color: i64      ;; COLOR-* value
   clos-escapes: i64))  ;; 1 if closure escapes, 0 if local

(defun make-closure-info (fn-name: ptr envstruct-name: ptr) -> ptr
  (share (ClosureInfo fn-name envstruct-name nil COLOR-PURE 0)))

(defun closure-info-name (c: ptr) -> ptr
  (. c clos-name))

(defun closure-info-env-name (c: ptr) -> ptr
  (. c clos-env-name))

(defun closure-info-captures (c: ptr) -> ptr
  (. c clos-captures))

(defun closure-info-color (c: ptr) -> i64
  (. c clos-color))

(defun closure-info-escapes (c: ptr) -> i64
  (. c clos-escapes))

;; ============================================================
;; Keyword Symbol Recognition
;; ============================================================
;;
;; Check if a symbol matches a known keyword by name.
;; Used to identify special forms (fn, let, if, do, etc.)

(defun sym-name-eq-2 (name: ptr c0 c1: i64) -> i64
  (if (!= (load-byte name) c0)
      0
      (if (!= (load-byte (ptr+ name 1)) c1)
          0
          (if (= 0 (load-byte (ptr+ name 2))) 1 0))))

(defun sym-name-eq-3 (name: ptr c0 c1 c2: i64) -> i64
  (if (!= (load-byte name) c0)
      0
      (if (!= (load-byte (ptr+ name 1)) c1)
          0
          (if (!= (load-byte (ptr+ name 2)) c2)
              0
              (if (= 0 (load-byte (ptr+ name 3))) 1 0)))))

(defun sym-name-eq-4 (name: ptr c0 c1 c2 c3: i64) -> i64
  (if (!= (load-byte name) c0)
      0
      (if (!= (load-byte (ptr+ name 1)) c1)
          0
          (if (!= (load-byte (ptr+ name 2)) c2)
              0
              (if (!= (load-byte (ptr+ name 3)) c3)
                  0
                  (if (= 0 (load-byte (ptr+ name 4))) 1 0))))))

;; Check keyword names
(defun is-fn-sym? (sym: ptr) -> i64
  (sym-name-eq-2 (symbol-name sym) 102 110))  ;; f n

(defun is-let-sym? (sym: ptr) -> i64
  (sym-name-eq-3 (symbol-name sym) 108 101 116))  ;; l e t

(defun is-plet-sym? (sym: ptr) -> i64
  (sym-name-eq-4 (symbol-name sym) 112 108 101 116))  ;; p l e t

(defun is-if-sym? (sym: ptr) -> i64
  (sym-name-eq-2 (symbol-name sym) 105 102))  ;; i f

(defun is-do-sym? (sym: ptr) -> i64
  (sym-name-eq-2 (symbol-name sym) 100 111))  ;; d o

;; ============================================================
;; Free Variable Analysis
;; ============================================================
;;
;; Find variables used but not defined within a form.
;; Uses environment to track bound variables.
;;
;; Strategy: Walk the AST, maintaining a local environment of bound vars.
;; Any symbol reference not in local env is a free variable.

(defun is-bound? (env: ptr sym-id: i64) -> i64
  (env-defined? env sym-id))

;; Add symbol to free set (simple list of sym-ids)
;; Returns new list with sym-id prepended (if not already present)
(defun add-free-loop (lst: ptr sym-id: i64) -> i64
  (if (nil? lst)
      0  ;; not found
      (if (= sym-id (icons-head lst))
          1  ;; already present
          (add-free-loop (icons-tail lst) sym-id))))

(defun add-free (free: ptr sym-id: i64) -> ptr
  (if (= 1 (add-free-loop free sym-id))
      free  ;; already present
      (icons sym-id free)))

;; Merge two free variable lists
(defun merge-free (a: ptr b: ptr) -> ptr
  (if (nil? a)
      b
      (merge-free (icons-tail a) (add-free b (icons-head a)))))

;; Count free variables
(defun count-free (lst: ptr) -> i64
  (if (nil? lst)
      0
      (+ 1 (count-free (icons-tail lst)))))

;; ============================================================
;; AST Walking for Free Variables
;; ============================================================
;;
;; find-free-in: Main entry point for finding free variables in an expr
;; Returns icons list of sym-ids that are free in the expression.
;;
;; Arguments:
;;   expr - the expression to analyze
;;   local - environment of locally bound variables (not free)
;;   free - accumulator of found free variables

;; Add params to local environment
(defun add-params-to-env (local: ptr params: ptr) -> ptr
  (if (nil? params)
      local
      (if (symbol? params)
          ;; Single rest param
          (do (env-define! local (symbol-id params) 1) local)
          ;; List of params
          (if (scons? params)
              (let ((param (scons-head params)))
                (do
                  (if (symbol? param)
                      (env-define! local (symbol-id param) 1)
                      0)
                  (add-params-to-env local (scons-tail params))))
              local))))

;; Process let bindings: ((name val) ...)
;; Adds names to local env, returns free vars from values
(defun find-free-in-bindings (bindings: ptr local: ptr free: ptr) -> ptr
  (if (nil? bindings)
      free
      (if (scons? bindings)
          (let ((binding (scons-head bindings)))
            (if (scons? binding)
                (let ((name (scons-head binding))
                      (val-form (scons-head (scons-tail binding)))
                      (free2 (find-free-in val-form local free)))
                  (do
                    (if (symbol? name)
                        (env-define! local (symbol-id name) 1)
                        0)
                    (find-free-in-bindings (scons-tail bindings) local free2)))
                free))
          free)))

;; Find free vars in a list of expressions
(defun find-free-in-list (exprs: ptr local: ptr free: ptr) -> ptr
  (if (nil? exprs)
      free
      (if (scons? exprs)
          (let ((free2 (find-free-in (scons-head exprs) local free)))
            (find-free-in-list (scons-tail exprs) local free2))
          free)))

;; Find free vars in a list form (dispatches on head)
(defun find-free-in-list-form (expr: ptr local: ptr free: ptr) -> ptr
  (let ((head (scons-head expr))
        (tail (scons-tail expr)))
    (if (symbol? head)
        (if (= 1 (is-fn-sym? head))
            ;; fn form: (fn (params...) body)
            (let ((params (scons-head tail))
                  (body (scons-head (scons-tail tail)))
                  (inner-local (make-scope local)))
              (do
                (add-params-to-env inner-local params)
                (find-free-in body inner-local free)))
            (if (= 1 (is-let-sym? head))
                ;; let form
                (let ((bindings (scons-head tail))
                      (body (scons-head (scons-tail tail)))
                      (inner-local (make-scope local))
                      (free2 (find-free-in-bindings bindings inner-local free)))
                  (find-free-in body inner-local free2))
                (if (= 1 (is-plet-sym? head))
                    ;; plet form
                    (let ((bindings (scons-head tail))
                          (body (scons-head (scons-tail tail)))
                          (inner-local (make-scope local))
                          (free2 (find-free-in-bindings bindings inner-local free)))
                      (find-free-in body inner-local free2))
                    (if (= 1 (is-if-sym? head))
                        ;; if form: (if cond then else)
                        (let ((cond-expr (scons-head tail))
                              (then-expr (scons-head (scons-tail tail)))
                              (else-expr (scons-head (scons-tail (scons-tail tail))))
                              (free2 (find-free-in cond-expr local free))
                              (free3 (find-free-in then-expr local free2)))
                          (find-free-in else-expr local free3))
                        (if (= 1 (is-do-sym? head))
                            ;; do form: (do expr1 expr2 ...)
                            (find-free-in-list tail local free)
                            ;; Function call: process all parts
                            (let ((free2 (find-free-in head local free)))
                              (find-free-in-list tail local free2)))))))
        ;; Head is not a symbol - function call with expr as callee
        (let ((free2 (find-free-in head local free)))
          (find-free-in-list tail local free2)))))

;; Main free variable finder
(defun find-free-in (expr: ptr local: ptr free: ptr) -> ptr
  (if (nil? expr)
      free  ;; Nil - no free vars
      (if (boxed-int? expr)
          free  ;; Boxed int - no free vars
          (if (boxed-float? expr)
              free  ;; Boxed float - no free vars
              (if (symbol? expr)
                  ;; Symbol - check if bound
                  (let ((sid (symbol-id expr)))
                    (if (= 1 (is-bound? local sid))
                        free  ;; bound locally, not free
                        (add-free free sid)))
                  (if (scons? expr)
                      ;; List - dispatch on head
                      (find-free-in-list-form expr local free)
                      ;; Unknown - no free vars
                      free))))))

;; Find free variables in an expression given an outer environment
(defun find-free-vars (expr: ptr outer-env: ptr) -> ptr
  (let ((local (make-scope outer-env)))
    (find-free-in expr local nil)))

;; ============================================================
;; Closure Conversion Context
;; ============================================================

(defstruct ClosureCtx
  (cctx-syms: ptr       ;; SymbolTable for gensym
   cctx-counter: i64    ;; Counter for unique names
   cctx-lifted: ptr))   ;; List of lifted functions

(defun make-closure-ctx (syms: ptr) -> ptr
  (share (ClosureCtx syms 0 nil)))

(defun cctx-syms (ctx: ptr) -> ptr
  (. ctx cctx-syms))

(defun cctx-counter (ctx: ptr) -> i64
  (. ctx cctx-counter))

(defun cctx-inc-counter (ctx: ptr) -> ptr
  (share (ClosureCtx (cctx-syms ctx) (+ 1 (cctx-counter ctx)) (. ctx cctx-lifted))))

(defun cctx-add-lifted (ctx: ptr fn-def: ptr) -> ptr
  (share (ClosureCtx (cctx-syms ctx) (cctx-counter ctx) (pcons fn-def (. ctx cctx-lifted)))))

(defun cctx-lifted (ctx: ptr) -> ptr
  (. ctx cctx-lifted))

;; ============================================================
;; Gensym - Generate unique symbols
;; ============================================================
;;
;; Creates symbols like __closure_0, __closure_1, etc.

;; Generate a unique symbol: __closure_N or __env_N
(defun gensym-closure (ctx: ptr) -> ptr
  (let ((sb (string-builder-cap 20))
        (counter (cctx-counter ctx))
        (sb (sb-conj sb 95))
        (sb (sb-conj sb 95))
        (sb (sb-conj sb 99))
        (sb (sb-conj sb 108))
        (sb (sb-conj sb 111))
        (sb (sb-conj sb 115))
        (sb (sb-conj sb 117))
        (sb (sb-conj sb 114))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 95))
        (sb (append-int sb counter)))
    (intern (cctx-syms ctx) (to-string sb))))

(defun gensym-env (ctx: ptr) -> ptr
  (let ((sb (string-builder-cap 20))
        (counter (cctx-counter ctx))
        (sb (sb-conj sb 95))
        (sb (sb-conj sb 95))
        (sb (sb-conj sb 101))
        (sb (sb-conj sb 110))
        (sb (sb-conj sb 118))
        (sb (sb-conj sb 95))
        (sb (append-int sb counter)))
    (intern (cctx-syms ctx) (to-string sb))))

;; ============================================================
;; Capture Mode Determination
;; ============================================================
;;
;; Per ADR 005, capture mode depends on how the variable is used:
;; - If mutated in closure body: needs ownership (move or clone)
;; - If only read and closure doesn't escape: can borrow
;; - Default: move (safest)

(defun determine-capture-mode (escapes body: ptr sym-id) -> i64
  ;; For now, default to move semantics
  ;; A proper implementation would analyze:
  ;; 1. Is the variable mutated?
  ;; 2. Does the closure escape?
  ;; 3. Is the variable copyable?
  (if (= 0 escapes)
      CAPTURE-BORROW  ;; Non-escaping can borrow
      CAPTURE-MOVE))  ;; Escaping needs to move/clone

;; ============================================================
;; Escape Analysis
;; ============================================================
;;
;; Determines if a closure escapes its defining scope:
;; - Returned from function -> escapes
;; - Stored in struct -> escapes
;; - Passed to unknown function -> escapes
;; - Only called locally -> doesn't escape

(defun closure-escapes? (ctx: ptr form: ptr) -> i64
  ;; For now, conservatively assume all closures escape
  ;; A proper implementation would do data flow analysis
  1)

;; ============================================================
;; Closure Color Tracking
;; ============================================================
;;
;; Per ADR 010, closure color determined by capture context:
;; - No captures -> pure
;; - Captures from let -> let-closure
;; - Captures from plet (atoms) -> plet-closure

(defun determine-color (captures: ptr env: ptr) -> i64
  (if (nil? captures)
      COLOR-PURE
      ;; TODO: check if any capture is from plet (atom)
      ;; For now, assume let-closure
      COLOR-LET))

;; ============================================================
;; Build Captures List
;; ============================================================

(defun build-captures-loop (free: ptr env: ptr escapes acc: ptr) -> ptr
  (if (nil? free)
      acc
      (let ((sym-id (icons-head free))
            (mode (determine-capture-mode escapes nil sym-id))
            (cap (make-capture sym-id mode)))
        (build-captures-loop (icons-tail free) env escapes (captures-cons cap acc)))))

(defun build-captures (free: ptr env: ptr escapes) -> ptr
  (build-captures-loop free env escapes nil))

;; ============================================================
;; Get Lambda Parts
;; ============================================================
;;
;; Extract params and body from (fn (params...) body)

(defun lambda-params (form: ptr) -> ptr
  (if (scons? form)
      (let ((tail (scons-tail form)))
        (if (scons? tail)
            (scons-head tail)
            nil))
      nil))

(defun lambda-body (form: ptr) -> ptr
  (if (scons? form)
      (let ((tail (scons-tail form)))
        (if (scons? tail)
            (let ((tail2 (scons-tail tail)))
              (if (scons? tail2)
                  (scons-head tail2)
                  nil))
            nil))
      nil))

;; ============================================================
;; Main Conversion Entry Point
;; ============================================================
;;
;; convert-closure: Takes a lambda form and returns a pair (ctx . ClosureInfo)
;; with all the information needed for code generation.
;;
;; Lambda form: (fn (params...) body)
;;
;; Returns: (new-ctx . ClosureInfo)
;;   - new-ctx has incremented counter
;;   - ClosureInfo has all capture information

(defun convert-closure (ctx: ptr env: ptr form: ptr) -> ptr
  (let ((params (lambda-params form))
        (body (lambda-body form))
        ;; Create local env with params bound
        (local (make-scope env)))
    (do
      ;; Bind params in local env
      (add-params-to-env local params)
      ;; Find free variables in body
      (let ((free (find-free-in body local nil))
            ;; Check if closure escapes
            (escapes (closure-escapes? ctx form))
            ;; Build captures from free vars
            (captures (build-captures free env escapes))
            ;; Determine color from captures
            (color (determine-color captures env))
            ;; Generate unique names
            (fn-name (gensym-closure ctx))
            (env-struct-name (gensym-env ctx))  ;; renamed to avoid conflict with env-name function
            ;; Build ClosureInfo
            (info (share (ClosureInfo fn-name env-struct-name captures color escapes)))
            ;; Increment counter for next gensym
            (new-ctx (cctx-inc-counter ctx)))
        (pcons new-ctx info)))))
