;; codegen.liar - lIR code generation for liarliar
;;
;; Walks the AST (SCons trees from reader.liar) and emits lIR as SCons trees.
;; The lIR is then serialized by a printer.
;;
;; Per ADR 019: lIR is the universal backend - all liar code emits lIR.
;; Per ADR 024: Type-directed codegen uses inferred types for optimal output.
;;
;; Design: Build lIR as data (cons cells), then print. This is cleaner than
;; string building and allows lIR-level transformations before output.

(ns liarliar.codegen
  (:require [liar.core :refer :all]
            [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]
            [liarliar.env :refer :all]))

;; ============================================================
;; Codegen Context
;; ============================================================

(defstruct CodegenCtx
  (cg-temp: i64        ;; Counter for unique temps (%0, %1, etc.)
   cg-syms: ptr        ;; SymbolTable for interning
   cg-env: ptr         ;; Current environment for name lookup
   cg-fns: ptr         ;; List of generated function definitions
   cg-block-counter: i64  ;; Counter for unique block labels
   cg-blocks: ptr      ;; List of accumulated blocks (for branching)
   cg-merge-label: ptr ;; Label for merge block (set by if)
   cg-structs: ptr     ;; NEW: List of struct definitions (unused)
   cg-type-id: i64     ;; NEW: Counter for type IDs (unused)
   cg-struct-defs: ptr)) ;; NEW: List of struct defs (unused)

(defun make-codegen-ctx (syms: ptr) -> ptr
  (share (CodegenCtx 0 syms (make-global-env) nil 0 nil nil nil 1 nil)))

(defun cg-temp (ctx: ptr) -> i64 (. ctx cg-temp))
(defun cg-syms (ctx: ptr) -> ptr (. ctx cg-syms))
(defun cg-env (ctx: ptr) -> ptr (. ctx cg-env))
(defun cg-fns (ctx: ptr) -> ptr (. ctx cg-fns))
(defun cg-block-counter (ctx: ptr) -> i64 (. ctx cg-block-counter))
(defun cg-blocks (ctx: ptr) -> ptr (. ctx cg-blocks))
(defun cg-merge-label (ctx: ptr) -> ptr (. ctx cg-merge-label))
(defun cg-structs (ctx: ptr) -> ptr (. ctx cg-structs))
(defun cg-type-id (ctx: ptr) -> i64 (. ctx cg-type-id))
(defun cg-struct-defs (ctx: ptr) -> ptr (. ctx cg-struct-defs))

;; Register a struct (returns updated context with new type_id)
;; Entry is stored as (name fields type_id) - a 3-element scons list
(defun cg-register-struct (ctx: ptr name: ptr fields: ptr) -> ptr
  (let ((type-id (cg-type-id ctx))
        (entry (scons name (scons fields (scons (box-int type-id) nil)))))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (scons entry (cg-structs ctx)) (+ type-id 1) (cg-struct-defs ctx)))))

;; Add defstruct definition to list
(defun cg-add-struct-def (ctx: ptr sdef: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (scons sdef (cg-struct-defs ctx)))))

;; Compare two interned symbols by their IDs
(defun sym-eq? (a: ptr b: ptr) -> i64
  (if (= (symbol-id a) (symbol-id b)) 1 0))

;; Lookup struct by name - returns entry (name fields type_id) scons list or nil
(defun cg-lookup-struct (ctx: ptr name: ptr) -> ptr
  (lookup-struct-loop (cg-structs ctx) name))

(defun lookup-struct-loop (lst: ptr name: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (car lst))
            (entry-name (car entry)))  ;; name is first element
        (if (= 1 (sym-eq? entry-name name))
            entry  ;; return full entry (name fields type_id)
            (lookup-struct-loop (cdr lst) name)))))

;; Helper to get fields from struct entry
(defun struct-entry-fields (entry: ptr) -> ptr
  (cadr entry))

;; Helper to get type_id from struct entry
(defun struct-entry-type-id (entry: ptr) -> i64
  (unbox-int (caddr entry)))

;; Get next temp and increment counter
(defun cg-next-temp (ctx: ptr) -> ptr
  (share (CodegenCtx (+ (cg-temp ctx) 1) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; Update environment
(defun cg-with-env (ctx: ptr new-env: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) new-env (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; Add function to list
(defun cg-add-fn (ctx: ptr fn-def: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx)
                     (scons fn-def (cg-fns ctx))
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; ============================================================
;; Block Management Helpers
;; ============================================================

;; Increment block counter and return updated context
(defun cg-inc-block-counter (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (+ (cg-block-counter ctx) 1) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; Add a block to the accumulated blocks list
(defun cg-add-block (ctx: ptr block: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (scons block (cg-blocks ctx)) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; Set the merge label for the if expression
(defun cg-set-merge-label (ctx: ptr label: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) label
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; Reset block state for new function
(defun cg-reset-blocks (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))

;; ============================================================
;; Symbol/String Helpers
;; ============================================================

;; Create a symbol from bytes (for lIR keywords)
;; Always allocate 9 bytes (8 chars + null), write all, null-terminate at len
(defun make-sym (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 len: i64) -> ptr
  (let ((buf (heap-array 9)))  ;; 8 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf len) 0)  ;; null terminate at len
      (intern syms buf))))

;; Helper for symbols up to 12 chars
(defun make-sym-long (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 len: i64) -> ptr
  (let ((buf (heap-array 13)))  ;; 12 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf len) 0)
      (intern syms buf))))

;; Helper for symbols of exactly 13 chars
(defun make-sym-13 (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12: i64) -> ptr
  (let ((buf (heap-array 14)))  ;; 13 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf 12) b12)
      (store-byte (ptr+ buf 13) 0)
      (intern syms buf))))

;; Common lIR symbols
(defun sym-i64 (s: ptr) -> ptr     (make-sym s 105 54 52 0 0 0 0 0 3))       ;; i64
(defun sym-i1 (s: ptr) -> ptr      (make-sym s 105 49 0 0 0 0 0 0 2))        ;; i1
(defun sym-ptr (s: ptr) -> ptr     (make-sym s 112 116 114 0 0 0 0 0 3))     ;; ptr
(defun sym-double (s: ptr) -> ptr  (make-sym s 100 111 117 98 108 101 0 0 6)) ;; double
(defun sym-add (s: ptr) -> ptr     (make-sym s 97 100 100 0 0 0 0 0 3))      ;; add
(defun sym-sub (s: ptr) -> ptr     (make-sym s 115 117 98 0 0 0 0 0 3))      ;; sub
(defun sym-mul (s: ptr) -> ptr     (make-sym s 109 117 108 0 0 0 0 0 3))     ;; mul
(defun sym-sdiv (s: ptr) -> ptr    (make-sym s 115 100 105 118 0 0 0 0 4))   ;; sdiv
(defun sym-srem (s: ptr) -> ptr    (make-sym s 115 114 101 109 0 0 0 0 4))   ;; srem
(defun sym-icmp (s: ptr) -> ptr    (make-sym s 105 99 109 112 0 0 0 0 4))    ;; icmp
(defun sym-eq (s: ptr) -> ptr      (make-sym s 101 113 0 0 0 0 0 0 2))       ;; eq
(defun sym-slt (s: ptr) -> ptr     (make-sym s 115 108 116 0 0 0 0 0 3))     ;; slt
(defun sym-sgt (s: ptr) -> ptr     (make-sym s 115 103 116 0 0 0 0 0 3))     ;; sgt
(defun sym-sle (s: ptr) -> ptr     (make-sym s 115 108 101 0 0 0 0 0 3))     ;; sle
(defun sym-sge (s: ptr) -> ptr     (make-sym s 115 103 101 0 0 0 0 0 3))     ;; sge
(defun sym-select (s: ptr) -> ptr  (make-sym s 115 101 108 101 99 116 0 0 6)) ;; select
(defun sym-call (s: ptr) -> ptr    (make-sym s 99 97 108 108 0 0 0 0 4))     ;; call
(defun sym-ret (s: ptr) -> ptr     (make-sym s 114 101 116 0 0 0 0 0 3))     ;; ret
(defun sym-define (s: ptr) -> ptr  (make-sym s 100 101 102 105 110 101 0 0 6)) ;; define
(defun sym-block (s: ptr) -> ptr   (make-sym s 98 108 111 99 107 0 0 0 5))   ;; block
(defun sym-entry (s: ptr) -> ptr   (make-sym s 101 110 116 114 121 0 0 0 5)) ;; entry
(defun sym-let (s: ptr) -> ptr     (make-sym s 108 101 116 0 0 0 0 0 3))     ;; let
(defun sym-string (s: ptr) -> ptr  (make-sym s 115 116 114 105 110 103 0 0 6)) ;; string
(defun sym-br (s: ptr) -> ptr      (make-sym s 98 114 0 0 0 0 0 0 2))        ;; br
(defun sym-phi (s: ptr) -> ptr     (make-sym s 112 104 105 0 0 0 0 0 3))     ;; phi

;; Float arithmetic lIR symbols
(defun sym-fadd (s: ptr) -> ptr    (make-sym s 102 97 100 100 0 0 0 0 4))    ;; fadd
(defun sym-fsub (s: ptr) -> ptr    (make-sym s 102 115 117 98 0 0 0 0 4))    ;; fsub
(defun sym-fmul (s: ptr) -> ptr    (make-sym s 102 109 117 108 0 0 0 0 4))   ;; fmul
(defun sym-fdiv (s: ptr) -> ptr    (make-sym s 102 100 105 118 0 0 0 0 4))   ;; fdiv
(defun sym-frem (s: ptr) -> ptr    (make-sym s 102 114 101 109 0 0 0 0 4))   ;; frem

;; Type conversion lIR symbols
(defun sym-trunc (s: ptr) -> ptr   (make-sym s 116 114 117 110 99 0 0 0 5))  ;; trunc
(defun sym-zext (s: ptr) -> ptr    (make-sym s 122 101 120 116 0 0 0 0 4))   ;; zext
(defun sym-sext (s: ptr) -> ptr    (make-sym s 115 101 120 116 0 0 0 0 4))   ;; sext
(defun sym-fptosi (s: ptr) -> ptr  (make-sym s 102 112 116 111 115 105 0 0 6)) ;; fptosi
(defun sym-fptoui (s: ptr) -> ptr  (make-sym s 102 112 116 111 117 105 0 0 6)) ;; fptoui
(defun sym-sitofp (s: ptr) -> ptr  (make-sym s 115 105 116 111 102 112 0 0 6)) ;; sitofp
(defun sym-uitofp (s: ptr) -> ptr  (make-sym s 117 105 116 111 102 112 0 0 6)) ;; uitofp
(defun sym-fpext (s: ptr) -> ptr   (make-sym s 102 112 101 120 116 0 0 0 5))  ;; fpext
(defun sym-fptrunc (s: ptr) -> ptr (make-sym s 102 112 116 114 117 110 99 0 7)) ;; fptrunc

;; Pointer and null
(defun sym-null (s: ptr) -> ptr    (make-sym s 110 117 108 108 0 0 0 0 4))     ;; null

;; Struct-related lIR symbols
(defun sym-defstruct (s: ptr) -> ptr   (make-sym-long s 100 101 102 115 116 114 117 99 116 0 0 0 9)) ;; defstruct
(defun sym-heap-struct (s: ptr) -> ptr (make-sym-long s 104 101 97 112 45 115 116 114 117 99 116 0 11)) ;; heap-struct
(defun sym-getelementptr (s: ptr) -> ptr (make-sym-13 s 103 101 116 101 108 101 109 101 110 116 112 116 114)) ;; getelementptr
(defun sym-load (s: ptr) -> ptr    (make-sym s 108 111 97 100 0 0 0 0 4))      ;; load
(defun sym-inbounds (s: ptr) -> ptr (make-sym s 105 110 98 111 117 110 100 115 8)) ;; inbounds
(defun sym-alloca (s: ptr) -> ptr  (make-sym s 97 108 108 111 99 97 0 0 6))    ;; alloca
(defun sym-store (s: ptr) -> ptr   (make-sym s 115 116 111 114 101 0 0 0 5))   ;; store

;; Liar special forms (for dispatch)
(defun str-if () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 102) (store-byte (ptr+ b 2) 0) b)))

(defun str-let () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 108) (store-byte (ptr+ b 1) 101)
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 0) b)))

(defun str-defun () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 117) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 0) b)))

(defun str-do () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 0) b)))

(defun str-fn () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 0) b)))

(defun str-plus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 43) (store-byte (ptr+ b 1) 0) b)))

(defun str-minus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 45) (store-byte (ptr+ b 1) 0) b)))

(defun str-star () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 42) (store-byte (ptr+ b 1) 0) b)))

(defun str-slash () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 47) (store-byte (ptr+ b 1) 0) b)))

(defun str-rem () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 109)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-eq () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 61) (store-byte (ptr+ b 1) 0) b)))

(defun str-lt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 60) (store-byte (ptr+ b 1) 0) b)))

(defun str-gt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 62) (store-byte (ptr+ b 1) 0) b)))

(defun str-lte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 60) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-gte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 62) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

;; Float operator strings (+., -., *., /., %.)
(defun str-plus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 43) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-minus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 45) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-star-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 42) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-slash-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 47) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-percent-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 37) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

;; Named float operator strings (fadd, fsub, fmul, fdiv, frem)
(defun str-fadd () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 97) (store-byte (ptr+ b 2) 100)
        (store-byte (ptr+ b 3) 100) (store-byte (ptr+ b 4) 0) b)))

(defun str-fsub () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 98) (store-byte (ptr+ b 4) 0) b)))

(defun str-fmul () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 109) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 108) (store-byte (ptr+ b 4) 0) b)))

(defun str-fdiv () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 100) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 118) (store-byte (ptr+ b 4) 0) b)))

(defun str-frem () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 109) (store-byte (ptr+ b 4) 0) b)))

;; Type conversion operator strings
(defun str-trunc () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 99) (store-byte (ptr+ b 5) 0) b)))

(defun str-zext () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 122) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 120)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-sext () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 120)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-fptosi () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-fptoui () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 117) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-sitofp () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 102) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-uitofp () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 117) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 102) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-fpext () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 120) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 0) b)))

(defun str-fptrunc () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 117) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 0) b)))

;; Builtin operator strings
(defun str-nil? () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 108)
        (store-byte (ptr+ b 3) 63) (store-byte (ptr+ b 4) 0) b)))

(defun str-defstruct () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 115) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 114)
        (store-byte (ptr+ b 6) 117) (store-byte (ptr+ b 7) 99) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-share () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 97)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

(defun str-instance? () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 97) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 63)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-dot () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 46) (store-byte (ptr+ b 1) 0) b)))

;; ============================================================
;; AST Predicates
;; ============================================================

(defun ast-symbol? (form: ptr) (symbol? form))
(defun ast-int? (form: ptr) (boxed-int? form))
(defun ast-float? (form: ptr) (boxed-float? form))
(defun ast-string? (form: ptr) (liar-string? form))
(defun ast-list? (form: ptr) (scons? form))

;; ============================================================
;; lIR Construction Helpers
;; ============================================================

;; Build: (i64 N)
(defun lir-int (syms: ptr val: i64) -> ptr
  (scons (sym-i64 syms) (scons (box-int val) nil)))

;; Build: %N (temp reference as symbol)
(defun lir-temp (syms: ptr n: i64) -> ptr
  ;; Create %N symbol - for now just use the number as a boxed int marker
  ;; Real impl would create "%0", "%1" etc symbols
  (box-int n))

;; Build: (op left right)
(defun lir-binop (syms: ptr op: ptr left: ptr right: ptr) -> ptr
  (scons op (scons left (scons right nil))))

;; Build: (icmp pred left right)
(defun lir-icmp (syms: ptr pred: ptr left: ptr right: ptr) -> ptr
  (scons (sym-icmp syms) (scons pred (scons left (scons right nil)))))

;; Build: (select cond then else)
(defun lir-select (syms: ptr cond-v: ptr then-v: ptr else-v: ptr) -> ptr
  (scons (sym-select syms) (scons cond-v (scons then-v (scons else-v nil)))))

;; Build: (ptr null)
(defun lir-null (syms: ptr) -> ptr
  (scons (sym-ptr syms) (scons (sym-null syms) nil)))

;; Helper: prepend @ to a string and intern it as a symbol
(extern strlen i64 (ptr))

(defun prepend-at (syms: ptr name: ptr) -> ptr
  (let ((name-len (strlen name))
        (new-len (+ name-len 2))  ;; @ + name + null
        (buf (heap-array new-len)))
    (do
      (store-byte buf 64)  ;; '@' = 64
      (copy-str-loop buf 1 name 0 name-len)
      (store-byte (ptr+ buf (+ name-len 1)) 0)  ;; null terminator
      (sym/intern syms buf))))

(defun copy-str-loop (dst: ptr dst-idx: i64 src: ptr src-idx: i64 len: i64) -> i64
  (if (>= src-idx len)
      0
      (do
        (store-byte (ptr+ dst dst-idx) (load-byte (ptr+ src src-idx)))
        (copy-str-loop dst (+ dst-idx 1) src (+ src-idx 1) len))))

;; Build: (call @fn args...)
(defun lir-call (syms: ptr fn-name: ptr args: ptr) -> ptr
  (let ((at-name (prepend-at syms (sym/symbol-name fn-name))))
    (scons (sym-call syms) (scons at-name args))))

;; Build: (ret val)
(defun lir-ret (syms: ptr val: ptr) -> ptr
  (scons (sym-ret syms) (scons val nil)))

;; Build: (let ((name val)) body)
(defun lir-let1 (syms: ptr name: ptr val: ptr body: ptr) -> ptr
  (scons (sym-let syms)
         (scons (scons (scons name (scons val nil)) nil)
                (scons body nil))))

;; Build: (br label) - unconditional branch
(defun lir-br (syms: ptr label: ptr) -> ptr
  (scons (sym-br syms) (scons label nil)))

;; Build: (br cond then-label else-label) - conditional branch
(defun lir-br-cond (syms: ptr cond-v: ptr then-lbl: ptr else-lbl: ptr) -> ptr
  (scons (sym-br syms) (scons cond-v (scons then-lbl (scons else-lbl nil)))))

;; Build: (phi type (label val) (label val))
(defun lir-phi (syms: ptr ty: ptr lbl1: ptr val1: ptr lbl2: ptr val2: ptr) -> ptr
  (scons (sym-phi syms)
         (scons ty
                (scons (scons lbl1 (scons val1 nil))
                       (scons (scons lbl2 (scons val2 nil)) nil)))))

;; Build: (block label body...)
(defun lir-block (syms: ptr label: ptr body: ptr) -> ptr
  (scons (sym-block syms) (scons label body)))

;; ============================================================
;; Block Label Generation
;; ============================================================

;; Helper to write a digit to buffer
(defun write-digit (buf: ptr idx: i64 n: i64) -> i64
  (do (store-byte (ptr+ buf idx) (+ 48 n)) (+ idx 1)))

;; Write number to buffer, return new index
(defun write-number (buf: ptr idx: i64 n: i64) -> i64
  (if (< n 10)
      (write-digit buf idx n)
      (let ((idx2 (write-number buf idx (/ n 10))))
        (write-digit buf idx2 (- n (* (/ n 10) 10))))))

;; Generate fresh block label like "then.0", "else.1", "merge.2"
;; Returns (ctx . label-symbol)
(defun cg-fresh-label (ctx: ptr prefix: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (counter (cg-block-counter ctx))
        (prefix-len (strlen prefix))
        (buf (heap-array 20)))  ;; enough for prefix.NNNN
    (do
      ;; Copy prefix to buffer
      (copy-str-loop buf 0 prefix 0 prefix-len)
      ;; Add dot separator
      (store-byte (ptr+ buf prefix-len) 46)  ;; '.' = 46
      ;; Write the counter number
      (let ((end-idx (write-number buf (+ prefix-len 1) counter)))
        (do
          ;; Null terminate
          (store-byte (ptr+ buf end-idx) 0)
          ;; Intern as symbol and return with incremented counter
          (pcons (cg-inc-block-counter ctx) (intern syms buf)))))))

;; String constants for label prefixes
(defun str-then-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 0) b)))

(defun str-else-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 0) b)))

(defun str-merge-prefix () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 109) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 103) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

;; ============================================================
;; Expression Codegen
;; ============================================================

;; Returns (ctx . lir-expr)
(defun codegen-expr (ctx: ptr form: ptr) -> ptr
  (cond
    ((ast-int? form)    (codegen-int ctx form))
    ((ast-float? form)  (codegen-float ctx form))
    ((ast-symbol? form) (codegen-symbol ctx form))
    ((ast-string? form) (codegen-string ctx form))
    ((ast-list? form)   (codegen-list ctx form))
    ((pcons? form)      (pcons ctx (box-int 0)))
    ((icons? form)      (pcons ctx (box-int 0)))
    ((nil? form)        (pcons ctx (box-int 0)))
    (else               (pcons ctx (box-int 0)))))

;; Integer literal: (i64 N)
(defun codegen-int (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (val (unbox-int form)))
    (pcons ctx (lir-int syms val))))

;; Float literal: (double N.M)
;; BoxedFloat stores: int-part, frac-part, scale (10^digits in frac)
;; E.g., 3.14 => int=3, frac=14, scale=100
;; We emit (double ...) with the reconstructed float value
(defun codegen-float (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; Emit the BoxedFloat directly - the lIR printer will handle it
    (pcons ctx (scons (sym-double syms) (scons form nil)))))

;; Symbol reference - pass through for now
(defun codegen-symbol (ctx: ptr form: ptr) -> ptr
  (pcons ctx form))

;; String literal - emit (string "...")
(defun codegen-string (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; form is a LiarString - wrap it in (string ...)
    (pcons ctx (scons (sym-string syms) (scons form nil)))))

;; ============================================================
;; List Form Dispatch
;; ============================================================

(defun codegen-list (ctx: ptr form: ptr) -> ptr
  (let ((head (car form)))
    (if (symbol? head)
        (let ((name (symbol-name head)))
          (cond
            ((streq name (str-if))     (codegen-if ctx form))
            ((streq name (str-let))    (codegen-let ctx form))
            ((streq name (str-defun))  (codegen-defun ctx form))
            ((streq name (str-do))     (codegen-do ctx form))
            ((streq name (str-fn))     (codegen-fn ctx form))
            ((streq name (str-plus))   (codegen-binop ctx form (sym-add (cg-syms ctx))))
            ((streq name (str-minus))  (codegen-binop ctx form (sym-sub (cg-syms ctx))))
            ((streq name (str-star))   (codegen-binop ctx form (sym-mul (cg-syms ctx))))
            ((streq name (str-slash))  (codegen-binop ctx form (sym-sdiv (cg-syms ctx))))
            ((streq name (str-rem))    (codegen-binop ctx form (sym-srem (cg-syms ctx))))
            ((streq name (str-eq))     (codegen-cmp ctx form (sym-eq (cg-syms ctx))))
            ((streq name (str-lt))     (codegen-cmp ctx form (sym-slt (cg-syms ctx))))
            ((streq name (str-gt))     (codegen-cmp ctx form (sym-sgt (cg-syms ctx))))
            ((streq name (str-lte))    (codegen-cmp ctx form (sym-sle (cg-syms ctx))))
            ((streq name (str-gte))    (codegen-cmp ctx form (sym-sge (cg-syms ctx))))
            ;; Float arithmetic operators
            ((streq name (str-plus-dot))    (codegen-float-binop ctx form (sym-fadd (cg-syms ctx))))
            ((streq name (str-minus-dot))   (codegen-float-binop ctx form (sym-fsub (cg-syms ctx))))
            ((streq name (str-star-dot))    (codegen-float-binop ctx form (sym-fmul (cg-syms ctx))))
            ((streq name (str-slash-dot))   (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx))))
            ((streq name (str-percent-dot)) (codegen-float-binop ctx form (sym-frem (cg-syms ctx))))
            ((streq name (str-fadd))        (codegen-float-binop ctx form (sym-fadd (cg-syms ctx))))
            ((streq name (str-fsub))        (codegen-float-binop ctx form (sym-fsub (cg-syms ctx))))
            ((streq name (str-fmul))        (codegen-float-binop ctx form (sym-fmul (cg-syms ctx))))
            ((streq name (str-fdiv))        (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx))))
            ((streq name (str-frem))        (codegen-float-binop ctx form (sym-frem (cg-syms ctx))))
            ;; Type conversion operators
            ((streq name (str-trunc))       (codegen-conv ctx form (sym-trunc (cg-syms ctx))))
            ((streq name (str-zext))        (codegen-conv ctx form (sym-zext (cg-syms ctx))))
            ((streq name (str-sext))        (codegen-conv ctx form (sym-sext (cg-syms ctx))))
            ((streq name (str-fptosi))      (codegen-conv ctx form (sym-fptosi (cg-syms ctx))))
            ((streq name (str-fptoui))      (codegen-conv ctx form (sym-fptoui (cg-syms ctx))))
            ((streq name (str-sitofp))      (codegen-conv ctx form (sym-sitofp (cg-syms ctx))))
            ((streq name (str-uitofp))      (codegen-conv ctx form (sym-uitofp (cg-syms ctx))))
            ((streq name (str-fpext))       (codegen-conv ctx form (sym-fpext (cg-syms ctx))))
            ((streq name (str-fptrunc))     (codegen-conv ctx form (sym-fptrunc (cg-syms ctx))))
            ;; Builtin predicates
            ((streq name (str-nil?))        (codegen-nil? ctx form))
            ;; Struct operations
            ((streq name (str-defstruct))   (codegen-defstruct ctx form))
            ((streq name (str-share))       (codegen-share ctx form))
            ((streq name (str-instance?))   (codegen-instance? ctx form))
            ((streq name (str-dot))         (codegen-field-access ctx form))
            (else                      (codegen-call-or-struct ctx form))))
        (codegen-call ctx form))))

;; ============================================================
;; Binary Operations
;; ============================================================

(defun codegen-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

(defun codegen-cmp (ctx: ptr form: ptr pred: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-icmp syms pred left-v right-v))))

;; Float binary operations - same as codegen-binop but for float ops
(defun codegen-float-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

;; Type conversion operations - emit (op target-type value)
;; Form: (trunc i8 value) or (fptosi i64 value)
(defun codegen-conv (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((target-type (cadr form))    ;; e.g., i8, i64, double
        (value-form (caddr form))
        (value-result (codegen-expr ctx value-form))
        (ctx (pcons-head value-result))
        (value-v (pcons-tail value-result))
        (syms (cg-syms ctx)))
    ;; Emit: (op target-type value)
    (pcons ctx (scons op (scons target-type (scons value-v nil))))))

;; ============================================================
;; Builtin Predicates
;; ============================================================

;; nil? - check if a pointer is null
;; Form: (nil? expr)
;; Emits: (icmp eq arg (ptr null))
(defun codegen-nil? (ctx: ptr form: ptr) -> ptr
  (let ((arg-form (cadr form))
        (arg-result (codegen-expr ctx arg-form))
        (ctx (pcons-head arg-result))
        (arg-v (pcons-tail arg-result))
        (syms (cg-syms ctx)))
    ;; Emit: (icmp eq arg (ptr null))
    (pcons ctx (lir-icmp syms (sym-eq syms) arg-v (lir-null syms)))))

;; ============================================================
;; Struct Operations
;; ============================================================

;; Try to codegen as struct constructor, fall back to function call
(defun codegen-call-or-struct (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (struct-info (if (symbol? head) (cg-lookup-struct ctx head) nil)))
    (if (nil? struct-info)
        (codegen-call ctx form)
        (codegen-struct-constructor ctx form struct-info))))

;; Helper to count scons list length
(defun scons-length (lst: ptr) -> i64
  (scons-length-loop lst 0))

(defun scons-length-loop (lst: ptr acc: i64) -> i64
  (if (nil? lst)
      acc
      (scons-length-loop (cdr lst) (+ acc 1))))

;; Helper string for __type_id
(defun str-type-id () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95)   ;; __
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 121) ;; ty
        (store-byte (ptr+ b 4) 112) (store-byte (ptr+ b 5) 101) ;; pe
        (store-byte (ptr+ b 6) 95) (store-byte (ptr+ b 7) 105)  ;; _i
        (store-byte (ptr+ b 8) 100) (store-byte (ptr+ b 9) 0) b))) ;; d

;; Helper to build %struct.Name symbol
(defun make-struct-type-sym (syms: ptr name: ptr) -> ptr
  (let ((name-str (symbol-name name))
        (name-len (strlen name-str))
        (buf-len (+ 9 name-len))  ;; "%struct." + name + null
        (buf (heap-array buf-len)))
    (do
      (store-byte buf 37)           ;; %
      (store-byte (ptr+ buf 1) 115) ;; s
      (store-byte (ptr+ buf 2) 116) ;; t
      (store-byte (ptr+ buf 3) 114) ;; r
      (store-byte (ptr+ buf 4) 117) ;; u
      (store-byte (ptr+ buf 5) 99)  ;; c
      (store-byte (ptr+ buf 6) 116) ;; t
      (store-byte (ptr+ buf 7) 46)  ;; .
      (copy-str-loop buf 8 name-str 0 name-len)
      (store-byte (ptr+ buf (+ 8 name-len)) 0)
      (intern syms buf))))

;; Parse defstruct field types (x: i64 y: i64) -> (i64 i64)
(defun parse-struct-fields (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((colon (car rest))
                  (rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2)))
                    (parse-struct-fields rest3 (scons typ acc)))))))))

;; Build field list for struct registry: ((field-name . type) ...)
(defun build-field-info (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((colon (car rest))
                  (rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2)))
                    (build-field-info rest3 (scons (pcons name typ) acc)))))))))

;; Codegen for defstruct: (defstruct Name (x: i64 y: i64))
(defun codegen-defstruct (ctx: ptr form: ptr) -> ptr
  (let ((name (cadr form))
        (raw-fields (caddr form))
        (field-types (parse-struct-fields raw-fields nil))
        (field-info (build-field-info raw-fields nil))
        (syms (cg-syms ctx))
        ;; Prepend i64 for type_id field
        (all-types (scons (sym-i64 syms) field-types))
        ;; Build defstruct form
        (lir-def (scons (sym-defstruct syms) (scons name (scons all-types nil))))
        ;; Register struct with prepended __type_id field
        (type-id-field (pcons (intern syms (str-type-id)) (sym-i64 syms)))
        (all-fields (scons type-id-field field-info))
        (ctx (cg-register-struct ctx name all-fields))
        (ctx (cg-add-struct-def ctx lir-def)))
    (pcons ctx nil)))

;; Helper to codegen a list of args
(defun codegen-args-list (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx (reverse-scons acc))
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args-list ctx (cdr args) (scons v acc)))))

;; Codegen for share: (share (Point 10 20))
;; Emits: (heap-struct Point type-id arg1 arg2 ...)
(defun codegen-share (ctx: ptr form: ptr) -> ptr
  (let ((inner (cadr form)))
    (if (scons? inner)
        (let ((struct-name (car inner))
              (struct-info (cg-lookup-struct ctx struct-name)))
          (if (nil? struct-info)
              ;; Not a struct constructor - error
              (pcons ctx (box-int 0))
              (let ((args (cdr inner))
                    (type-id (struct-entry-type-id struct-info))
                    (syms (cg-syms ctx))
                    ;; Generate argument expressions
                    (args-result (codegen-args-list ctx args nil))
                    (ctx (pcons-head args-result))
                    (arg-vals (pcons-tail args-result))
                    ;; Prepend type-id to field values
                    (all-vals (scons (lir-int syms type-id) arg-vals)))
                (pcons ctx (scons (sym-heap-struct syms)
                                 (scons struct-name all-vals))))))
        (pcons ctx (box-int 0)))))

;; Find field index in struct fields list (0-indexed)
(defun find-field-index (fields: ptr field-name: ptr idx: i64) -> i64
  (if (nil? fields)
      -1
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            idx
            (find-field-index (cdr fields) field-name (+ idx 1))))))

;; Find struct that has a given field
(defun find-struct-with-field (ctx: ptr field-name: ptr) -> ptr
  (find-struct-loop (cg-structs ctx) field-name))

(defun find-struct-loop (structs: ptr field-name: ptr) -> ptr
  (if (nil? structs)
      nil
      (let ((entry (car structs))
            (fields (struct-entry-fields entry)))
        (if (= 1 (struct-has-field? fields field-name))
            entry
            (find-struct-loop (cdr structs) field-name)))))

(defun struct-has-field? (fields: ptr field-name: ptr) -> i64
  (if (nil? fields)
      0
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            1
            (struct-has-field? (cdr fields) field-name)))))

;; Codegen for field access: (. obj field)
(defun codegen-field-access (ctx: ptr form: ptr) -> ptr
  (let ((obj-form (cadr form))
        (field-name (caddr form))
        (obj-result (codegen-expr ctx obj-form))
        (ctx (pcons-head obj-result))
        (obj-v (pcons-tail obj-result))
        (syms (cg-syms ctx))
        (struct-info (find-struct-with-field ctx field-name)))
    (if (nil? struct-info)
        (pcons ctx (lir-int syms -999))
        (codegen-field-access-found ctx obj-v field-name struct-info))))

(defun codegen-field-access-found (ctx: ptr obj-v: ptr field-name: ptr struct-info: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (struct-name (car struct-info))
        (fields (struct-entry-fields struct-info))
        (field-idx (find-field-index fields field-name 0))
        (struct-ty (make-struct-type-sym syms struct-name)))
    ;; Emit: (load i64 (getelementptr inbounds %struct.X obj (i64 0) (i64 idx)))
    (pcons ctx (scons (sym-load syms)
                     (scons (sym-i64 syms)
                            (scons (scons (sym-getelementptr syms)
                                         (scons (sym-inbounds syms)
                                                (scons struct-ty
                                                       (scons obj-v
                                                              (scons (lir-int syms 0)
                                                                     (scons (lir-int syms field-idx) nil))))))
                                   nil))))))

;; Codegen for struct constructor: (Point 10 20)
(defun codegen-struct-constructor (ctx: ptr form: ptr struct-info: ptr) -> ptr
  (let ((name (car form))
        (args (cdr form))
        (fields (struct-entry-fields struct-info))
        (type-id (struct-entry-type-id struct-info))
        (num-fields (scons-length fields))
        (syms (cg-syms ctx))
        ;; Generate argument expressions
        (args-result (codegen-args-list ctx args nil))
        (ctx (pcons-head args-result))
        (arg-vals (pcons-tail args-result))
        (struct-ty (make-struct-type-sym syms name))
        (ptr-sym (sym-ptr syms))
        ;; Build the alloca + stores + ptr return expression
        (body (build-struct-stores syms struct-ty arg-vals type-id 1 nil)))
    ;; Wrap in let with alloca
    (pcons ctx (scons (sym-let syms)
                      (scons (scons (scons ptr-sym
                                          (scons (scons (sym-alloca syms)
                                                       (scons (sym-i64 syms)
                                                              (scons (lir-int syms num-fields) nil)))
                                                nil))
                                   nil)
                            (scons (scons (sym-store syms)
                                         (scons (lir-int syms type-id)
                                                (scons (make-gep-idx0 syms struct-ty ptr-sym 0) nil)))
                                   body))))))

;; Helper to generate GEP for field index 0,N
(defun make-gep-idx0 (syms: ptr struct-ty: ptr ptr-sym: ptr idx: i64) -> ptr
  (scons (sym-getelementptr syms)
         (scons (sym-inbounds syms)
                (scons struct-ty
                       (scons ptr-sym
                              (scons (lir-int syms 0)
                                     (scons (lir-int syms idx) nil)))))))

;; Build store expressions for struct fields
(defun build-struct-stores (syms: ptr struct-ty: ptr args: ptr type-id: i64 idx: i64 acc: ptr) -> ptr
  (if (nil? args)
      (reverse-scons (scons (sym-ptr syms) acc))
      (let ((arg (car args))
            (store-expr (scons (sym-store syms)
                              (scons arg
                                     (scons (make-gep-idx0 syms struct-ty (sym-ptr syms) idx) nil)))))
        (build-struct-stores syms struct-ty (cdr args) type-id (+ idx 1) (scons store-expr acc)))))

;; Codegen for instance?: (instance? obj Type)
(defun codegen-instance? (ctx: ptr form: ptr) -> ptr
  (let ((obj-form (cadr form))
        (type-name (caddr form))
        (struct-info (cg-lookup-struct ctx type-name)))
    (if (nil? struct-info)
        ;; Type not found - return false
        (pcons ctx (lir-int (cg-syms ctx) 0))
        ;; Generate runtime check
        (let ((obj-result (codegen-expr ctx obj-form))
              (ctx (pcons-head obj-result))
              (obj-v (pcons-tail obj-result))
              (type-id (struct-entry-type-id struct-info))
              (syms (cg-syms ctx)))
          ;; Emit: (icmp eq (load i64 (gep obj 0 0)) type-id)
          (pcons ctx (lir-icmp syms (sym-eq syms)
                              (scons (sym-load syms)
                                    (scons (sym-i64 syms)
                                           (scons (make-gep-idx0 syms (make-struct-type-sym syms type-name) obj-v 0) nil)))
                              (lir-int syms type-id)))))))

;; ============================================================
;; If Expression (with proper branching)
;; ============================================================

;; Emit proper control flow using br/phi for short-circuit evaluation
;; This enables recursion to work correctly (unlike select which evaluates both branches)
;;
;; For (if cond then else), we generate:
;;   (block entry (br cond-v then-label else-label))
;;   (block then-label (let ((then-var then-v)) (br merge-label)))
;;   (block else-label (let ((else-var else-v)) (br merge-label)))
;;   (block merge-label (ret (phi i64 (then-label then-var) (else-label else-var))))
;;
;; The then-var/else-var let bindings ensure values are computed in their blocks
;; before being referenced by phi in the merge block.

(defun codegen-if (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))

        ;; Generate unique block labels
        (then-result (cg-fresh-label ctx (str-then-prefix)))
        (ctx (pcons-head then-result))
        (then-lbl (pcons-tail then-result))

        (else-result (cg-fresh-label ctx (str-else-prefix)))
        (ctx (pcons-head else-result))
        (else-lbl (pcons-tail else-result))

        (merge-result (cg-fresh-label ctx (str-merge-prefix)))
        (ctx (pcons-head merge-result))
        (merge-lbl (pcons-tail merge-result))

        ;; Compile condition expression
        (cond-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head cond-result))
        (cond-v (pcons-tail cond-result))

        ;; Compile then expression
        (then-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head then-result))
        (then-v (pcons-tail then-result))

        ;; Compile else expression
        (else-result (codegen-expr ctx (cadddr form)))
        (ctx (pcons-head else-result))
        (else-v (pcons-tail else-result))

        ;; Build entry block: (block entry (br cond then else))
        (entry-block (lir-block syms (sym-entry syms)
                                (scons (lir-br-cond syms cond-v then-lbl else-lbl) nil)))

        ;; Build then block: (block then (let ((then-var then-v)) (br merge)))
        ;; We wrap then-v in a let to ensure it's computed in the then block
        (then-block (lir-block syms then-lbl
                               (scons (lir-let1 syms then-lbl then-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Build else block: (block else (let ((else-var else-v)) (br merge)))
        (else-block (lir-block syms else-lbl
                               (scons (lir-let1 syms else-lbl else-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Add blocks to context (in reverse order so they come out right)
        (ctx (cg-add-block ctx else-block))
        (ctx (cg-add-block ctx then-block))
        (ctx (cg-add-block ctx entry-block))

        ;; Set merge label for defun to use
        (ctx (cg-set-merge-label ctx merge-lbl))

        ;; Build phi expression that will be in the merge block
        (phi-expr (lir-phi syms (sym-i64 syms) then-lbl then-lbl else-lbl else-lbl)))

    (pcons ctx phi-expr)))

;; ============================================================
;; Let Bindings
;; ============================================================

(defun codegen-let-body (ctx: ptr bindings: ptr body: ptr) -> ptr
  (if (nil? bindings)
      (codegen-expr ctx body)
      (let ((binding (car bindings))
            (name (car binding))
            (val-form (cadr binding))
            (val-result (codegen-expr ctx val-form))
            (ctx (pcons-head val-result))
            (val-v (pcons-tail val-result))
            (rest-result (codegen-let-body ctx (cdr bindings) body))
            (ctx (pcons-head rest-result))
            (rest-v (pcons-tail rest-result))
            (syms (cg-syms ctx)))
        (pcons ctx (lir-let1 syms name val-v rest-v)))))

(defun codegen-let (ctx: ptr form: ptr) -> ptr
  (let ((bindings (cadr form))
        (body (caddr form)))
    (codegen-let-body ctx bindings body)))

;; ============================================================
;; Do Block
;; ============================================================

(defun codegen-do-loop (ctx: ptr exprs: ptr last-v: ptr) -> ptr
  (if (nil? exprs)
      (pcons ctx last-v)
      (let ((result (codegen-expr ctx (car exprs)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-do-loop ctx (cdr exprs) v))))

(defun codegen-do (ctx: ptr form: ptr) -> ptr
  (codegen-do-loop ctx (cdr form) (box-int 0)))

;; ============================================================
;; Function Call
;; ============================================================

(defun codegen-args (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx acc)
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args ctx (cdr args) (scons v acc)))))

(defun codegen-call (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (args (cdr form))
        (args-result (codegen-args ctx args nil))
        (ctx (pcons-head args-result))
        (args-rev (pcons-tail args-result))
        (args-v (reverse-scons args-rev))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-call syms head args-v))))

;; ============================================================
;; Function Definition
;; ============================================================

;; Get the nth element of a list (0-indexed)
(defun list-nth (lst: ptr n: i64) -> ptr
  (if (<= n 0)
      (car lst)
      (list-nth (cdr lst) (- n 1))))

;; Check if element at index 3 is the arrow symbol ->
(defun has-return-type? (form: ptr) -> i64
  (let ((elem3 (list-nth form 3)))
    (if (symbol? elem3)
        (let ((name (symbol-name elem3)))
          (if (= (load-byte name) 45)           ;; '-'
              (if (= (load-byte (ptr+ name 1)) 62)   ;; '>'
                  1
                  0)
              0))
        0)))

;; Extract function body from defun form
(defun get-defun-body (form: ptr) -> ptr
  (if (= (has-return-type? form) 1)
      (list-nth form 5)
      (cadddr form)))

;; Transform params from (name : type name : type) to ((type name) (type name))
;; Skip colons, pair up names with types, swap order
(defun transform-params (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      ;; lst is: name : type rest...
      (let ((name (car lst))
            (rest (cdr lst)))  ;; should be (: type rest...)
        (if (nil? rest)
            (reverse-scons acc)  ;; malformed, just return what we have
            (let ((colon (car rest))
                  (rest2 (cdr rest)))  ;; should be (type rest...)
              (if (nil? rest2)
                  (reverse-scons acc)  ;; malformed
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2))  ;; remaining params
                        ;; Build (type name) pair
                        (pair (scons typ (scons name nil))))
                    (transform-params rest3 (scons pair acc)))))))))

;; Build the list of blocks for a function with branching
;; Blocks are already in correct order [entry, then, else], just append merge
(defun build-function-blocks (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (let ((merge-block (lir-block syms merge-lbl
                                (scons (lir-ret syms body-v) nil))))
    ;; Append merge block to the end
    (append-scons blocks (scons merge-block nil))))

;; Append two scons lists
(defun append-scons (lst1: ptr lst2: ptr) -> ptr
  (if (nil? lst1)
      lst2
      (scons (car lst1) (append-scons (cdr lst1) lst2))))

;; Helper to build function body based on whether there are blocks
(defun build-fn-body (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (if (nil? blocks)
      ;; No branching: simple single-block function
      (scons (scons (sym-block syms)
                    (scons (sym-entry syms)
                           (scons (lir-ret syms body-v) nil)))
             nil)
      ;; Has branching: use accumulated blocks + merge block
      (build-function-blocks syms blocks merge-lbl body-v)))

(defun codegen-defun (ctx: ptr form: ptr) -> ptr
  ;; (defun name (params) body) OR (defun name (params) -> type body)
  (let ((name (cadr form))
        (raw-params (caddr form))
        (lir-params (transform-params raw-params nil))
        (body (get-defun-body form))
        (syms (cg-syms ctx))
        ;; Reset temp and block counters for function body
        (fn-ctx (share (CodegenCtx 0 syms (cg-env ctx) nil 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx))))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        ;; Check if body generated any blocks (from if expressions)
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        ;; Build function signature: (name return-type)
        (fn-sig (scons name (scons (sym-i64 syms) nil)))
        ;; Build function body - call helper to avoid if in let binding
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        ;; Build complete function definition
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        ;; Add function to context
        (ctx (cg-add-fn ctx fn-def)))
    (pcons ctx fn-def)))

;; Lambda - stub for now
(defun codegen-fn (ctx: ptr form: ptr) -> ptr
  (pcons ctx (box-int 0)))

;; ============================================================
;; Top-Level
;; ============================================================

(defun codegen-toplevel (ctx: ptr forms: ptr) -> ptr
  (if (nil? forms)
      ctx
      (let ((result (codegen-expr ctx (car forms)))
            (ctx (pcons-head result)))
        (codegen-toplevel ctx (cdr forms)))))

(defun codegen-module (forms: ptr syms: ptr) -> ptr
  (let ((ctx (make-codegen-ctx syms))
        (ctx (codegen-toplevel ctx forms))
        (struct-defs (cg-struct-defs ctx))
        (fn-defs (cg-fns ctx)))
    ;; Combine struct defs and function defs
    (append-scons (reverse-scons struct-defs) fn-defs)))

