;; codegen.liar - lIR code generation for liarliar
;;
;; Walks the AST (SCons trees from reader.liar) and emits lIR as SCons trees.
;; The lIR is then serialized by a printer.
;;
;; Per ADR 019: lIR is the universal backend - all liar code emits lIR.
;; Per ADR 024: Type-directed codegen uses inferred types for optimal output.
;;
;; Design: Build lIR as data (cons cells), then print. This is cleaner than
;; string building and allows lIR-level transformations before output.

(ns liarliar.codegen
  (:require [liar.core :refer :all]
            [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]
            [liarliar.env :refer :all]))

;; ============================================================
;; Codegen Context
;; ============================================================

(defstruct CodegenCtx
  (cg-temp: i64        ;; Counter for unique temps (%0, %1, etc.)
   cg-syms: ptr        ;; SymbolTable for interning
   cg-env: ptr         ;; Current environment for name lookup
   cg-fns: ptr         ;; List of generated function definitions
   cg-block-counter: i64  ;; Counter for unique block labels
   cg-blocks: ptr      ;; List of accumulated blocks (for branching)
   cg-merge-label: ptr)) ;; Label for merge block (set by if)

(defun make-codegen-ctx (syms: ptr) -> ptr
  (share (CodegenCtx 0 syms (make-global-env) nil 0 nil nil)))

(defun cg-temp (ctx: ptr) -> i64 (. ctx cg-temp))
(defun cg-syms (ctx: ptr) -> ptr (. ctx cg-syms))
(defun cg-env (ctx: ptr) -> ptr (. ctx cg-env))
(defun cg-fns (ctx: ptr) -> ptr (. ctx cg-fns))
(defun cg-block-counter (ctx: ptr) -> i64 (. ctx cg-block-counter))
(defun cg-blocks (ctx: ptr) -> ptr (. ctx cg-blocks))
(defun cg-merge-label (ctx: ptr) -> ptr (. ctx cg-merge-label))

;; Get next temp and increment counter
(defun cg-next-temp (ctx: ptr) -> ptr
  (share (CodegenCtx (+ (cg-temp ctx) 1) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx))))

;; Update environment
(defun cg-with-env (ctx: ptr new-env: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) new-env (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx))))

;; Add function to list
(defun cg-add-fn (ctx: ptr fn-def: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx)
                     (scons fn-def (cg-fns ctx))
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx))))

;; ============================================================
;; Block Management Helpers
;; ============================================================

;; Increment block counter and return updated context
(defun cg-inc-block-counter (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (+ (cg-block-counter ctx) 1) (cg-blocks ctx) (cg-merge-label ctx))))

;; Add a block to the accumulated blocks list
(defun cg-add-block (ctx: ptr block: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (scons block (cg-blocks ctx)) (cg-merge-label ctx))))

;; Set the merge label for the if expression
(defun cg-set-merge-label (ctx: ptr label: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) label)))

;; Reset block state for new function
(defun cg-reset-blocks (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     0 nil nil)))

;; ============================================================
;; Symbol/String Helpers
;; ============================================================

;; Create a symbol from bytes (for lIR keywords)
;; Always allocate 9 bytes (8 chars + null), write all, null-terminate at len
(defun make-sym (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 len: i64) -> ptr
  (let ((buf (heap-array 9)))  ;; 8 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf len) 0)  ;; null terminate at len
      (intern syms buf))))

;; Common lIR symbols
(defun sym-i64 (s: ptr) -> ptr     (make-sym s 105 54 52 0 0 0 0 0 3))       ;; i64
(defun sym-i1 (s: ptr) -> ptr      (make-sym s 105 49 0 0 0 0 0 0 2))        ;; i1
(defun sym-ptr (s: ptr) -> ptr     (make-sym s 112 116 114 0 0 0 0 0 3))     ;; ptr
(defun sym-double (s: ptr) -> ptr  (make-sym s 100 111 117 98 108 101 0 0 6)) ;; double
(defun sym-add (s: ptr) -> ptr     (make-sym s 97 100 100 0 0 0 0 0 3))      ;; add
(defun sym-sub (s: ptr) -> ptr     (make-sym s 115 117 98 0 0 0 0 0 3))      ;; sub
(defun sym-mul (s: ptr) -> ptr     (make-sym s 109 117 108 0 0 0 0 0 3))     ;; mul
(defun sym-sdiv (s: ptr) -> ptr    (make-sym s 115 100 105 118 0 0 0 0 4))   ;; sdiv
(defun sym-srem (s: ptr) -> ptr    (make-sym s 115 114 101 109 0 0 0 0 4))   ;; srem
(defun sym-icmp (s: ptr) -> ptr    (make-sym s 105 99 109 112 0 0 0 0 4))    ;; icmp
(defun sym-eq (s: ptr) -> ptr      (make-sym s 101 113 0 0 0 0 0 0 2))       ;; eq
(defun sym-slt (s: ptr) -> ptr     (make-sym s 115 108 116 0 0 0 0 0 3))     ;; slt
(defun sym-sgt (s: ptr) -> ptr     (make-sym s 115 103 116 0 0 0 0 0 3))     ;; sgt
(defun sym-sle (s: ptr) -> ptr     (make-sym s 115 108 101 0 0 0 0 0 3))     ;; sle
(defun sym-sge (s: ptr) -> ptr     (make-sym s 115 103 101 0 0 0 0 0 3))     ;; sge
(defun sym-select (s: ptr) -> ptr  (make-sym s 115 101 108 101 99 116 0 0 6)) ;; select
(defun sym-call (s: ptr) -> ptr    (make-sym s 99 97 108 108 0 0 0 0 4))     ;; call
(defun sym-ret (s: ptr) -> ptr     (make-sym s 114 101 116 0 0 0 0 0 3))     ;; ret
(defun sym-define (s: ptr) -> ptr  (make-sym s 100 101 102 105 110 101 0 0 6)) ;; define
(defun sym-block (s: ptr) -> ptr   (make-sym s 98 108 111 99 107 0 0 0 5))   ;; block
(defun sym-entry (s: ptr) -> ptr   (make-sym s 101 110 116 114 121 0 0 0 5)) ;; entry
(defun sym-let (s: ptr) -> ptr     (make-sym s 108 101 116 0 0 0 0 0 3))     ;; let
(defun sym-string (s: ptr) -> ptr  (make-sym s 115 116 114 105 110 103 0 0 6)) ;; string
(defun sym-br (s: ptr) -> ptr      (make-sym s 98 114 0 0 0 0 0 0 2))        ;; br
(defun sym-phi (s: ptr) -> ptr     (make-sym s 112 104 105 0 0 0 0 0 3))     ;; phi

;; Float arithmetic lIR symbols
(defun sym-fadd (s: ptr) -> ptr    (make-sym s 102 97 100 100 0 0 0 0 4))    ;; fadd
(defun sym-fsub (s: ptr) -> ptr    (make-sym s 102 115 117 98 0 0 0 0 4))    ;; fsub
(defun sym-fmul (s: ptr) -> ptr    (make-sym s 102 109 117 108 0 0 0 0 4))   ;; fmul
(defun sym-fdiv (s: ptr) -> ptr    (make-sym s 102 100 105 118 0 0 0 0 4))   ;; fdiv
(defun sym-frem (s: ptr) -> ptr    (make-sym s 102 114 101 109 0 0 0 0 4))   ;; frem

;; Liar special forms (for dispatch)
(defun str-if () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 102) (store-byte (ptr+ b 2) 0) b)))

(defun str-let () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 108) (store-byte (ptr+ b 1) 101)
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 0) b)))

(defun str-defun () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 117) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 0) b)))

(defun str-do () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 0) b)))

(defun str-fn () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 0) b)))

(defun str-plus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 43) (store-byte (ptr+ b 1) 0) b)))

(defun str-minus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 45) (store-byte (ptr+ b 1) 0) b)))

(defun str-star () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 42) (store-byte (ptr+ b 1) 0) b)))

(defun str-slash () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 47) (store-byte (ptr+ b 1) 0) b)))

(defun str-rem () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 109)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-eq () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 61) (store-byte (ptr+ b 1) 0) b)))

(defun str-lt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 60) (store-byte (ptr+ b 1) 0) b)))

(defun str-gt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 62) (store-byte (ptr+ b 1) 0) b)))

(defun str-lte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 60) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-gte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 62) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

;; Float operator strings (+., -., *., /., %.)
(defun str-plus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 43) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-minus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 45) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-star-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 42) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-slash-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 47) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-percent-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 37) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

;; Named float operator strings (fadd, fsub, fmul, fdiv, frem)
(defun str-fadd () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 97) (store-byte (ptr+ b 2) 100)
        (store-byte (ptr+ b 3) 100) (store-byte (ptr+ b 4) 0) b)))

(defun str-fsub () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 98) (store-byte (ptr+ b 4) 0) b)))

(defun str-fmul () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 109) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 108) (store-byte (ptr+ b 4) 0) b)))

(defun str-fdiv () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 100) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 118) (store-byte (ptr+ b 4) 0) b)))

(defun str-frem () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 109) (store-byte (ptr+ b 4) 0) b)))

;; ============================================================
;; AST Predicates
;; ============================================================

(defun ast-symbol? (form: ptr) (symbol? form))
(defun ast-int? (form: ptr) (boxed-int? form))
(defun ast-float? (form: ptr) (boxed-float? form))
(defun ast-string? (form: ptr) (liar-string? form))
(defun ast-list? (form: ptr) (scons? form))

;; ============================================================
;; lIR Construction Helpers
;; ============================================================

;; Build: (i64 N)
(defun lir-int (syms: ptr val: i64) -> ptr
  (scons (sym-i64 syms) (scons (box-int val) nil)))

;; Build: %N (temp reference as symbol)
(defun lir-temp (syms: ptr n: i64) -> ptr
  ;; Create %N symbol - for now just use the number as a boxed int marker
  ;; Real impl would create "%0", "%1" etc symbols
  (box-int n))

;; Build: (op left right)
(defun lir-binop (syms: ptr op: ptr left: ptr right: ptr) -> ptr
  (scons op (scons left (scons right nil))))

;; Build: (icmp pred left right)
(defun lir-icmp (syms: ptr pred: ptr left: ptr right: ptr) -> ptr
  (scons (sym-icmp syms) (scons pred (scons left (scons right nil)))))

;; Build: (select cond then else)
(defun lir-select (syms: ptr cond-v: ptr then-v: ptr else-v: ptr) -> ptr
  (scons (sym-select syms) (scons cond-v (scons then-v (scons else-v nil)))))

;; Helper: prepend @ to a string and intern it as a symbol
(extern strlen i64 (ptr))

(defun prepend-at (syms: ptr name: ptr) -> ptr
  (let ((name-len (strlen name))
        (new-len (+ name-len 2))  ;; @ + name + null
        (buf (heap-array new-len)))
    (do
      (store-byte buf 64)  ;; '@' = 64
      (copy-str-loop buf 1 name 0 name-len)
      (store-byte (ptr+ buf (+ name-len 1)) 0)  ;; null terminator
      (sym/intern syms buf))))

(defun copy-str-loop (dst: ptr dst-idx: i64 src: ptr src-idx: i64 len: i64) -> i64
  (if (>= src-idx len)
      0
      (do
        (store-byte (ptr+ dst dst-idx) (load-byte (ptr+ src src-idx)))
        (copy-str-loop dst (+ dst-idx 1) src (+ src-idx 1) len))))

;; Build: (call @fn args...)
(defun lir-call (syms: ptr fn-name: ptr args: ptr) -> ptr
  (let ((at-name (prepend-at syms (sym/symbol-name fn-name))))
    (scons (sym-call syms) (scons at-name args))))

;; Build: (ret val)
(defun lir-ret (syms: ptr val: ptr) -> ptr
  (scons (sym-ret syms) (scons val nil)))

;; Build: (let ((name val)) body)
(defun lir-let1 (syms: ptr name: ptr val: ptr body: ptr) -> ptr
  (scons (sym-let syms)
         (scons (scons (scons name (scons val nil)) nil)
                (scons body nil))))

;; Build: (br label) - unconditional branch
(defun lir-br (syms: ptr label: ptr) -> ptr
  (scons (sym-br syms) (scons label nil)))

;; Build: (br cond then-label else-label) - conditional branch
(defun lir-br-cond (syms: ptr cond-v: ptr then-lbl: ptr else-lbl: ptr) -> ptr
  (scons (sym-br syms) (scons cond-v (scons then-lbl (scons else-lbl nil)))))

;; Build: (phi type (label val) (label val))
(defun lir-phi (syms: ptr ty: ptr lbl1: ptr val1: ptr lbl2: ptr val2: ptr) -> ptr
  (scons (sym-phi syms)
         (scons ty
                (scons (scons lbl1 (scons val1 nil))
                       (scons (scons lbl2 (scons val2 nil)) nil)))))

;; Build: (block label body...)
(defun lir-block (syms: ptr label: ptr body: ptr) -> ptr
  (scons (sym-block syms) (scons label body)))

;; ============================================================
;; Block Label Generation
;; ============================================================

;; Helper to write a digit to buffer
(defun write-digit (buf: ptr idx: i64 n: i64) -> i64
  (do (store-byte (ptr+ buf idx) (+ 48 n)) (+ idx 1)))

;; Write number to buffer, return new index
(defun write-number (buf: ptr idx: i64 n: i64) -> i64
  (if (< n 10)
      (write-digit buf idx n)
      (let ((idx2 (write-number buf idx (/ n 10))))
        (write-digit buf idx2 (- n (* (/ n 10) 10))))))

;; Generate fresh block label like "then.0", "else.1", "merge.2"
;; Returns (ctx . label-symbol)
(defun cg-fresh-label (ctx: ptr prefix: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (counter (cg-block-counter ctx))
        (prefix-len (strlen prefix))
        (buf (heap-array 20)))  ;; enough for prefix.NNNN
    (do
      ;; Copy prefix to buffer
      (copy-str-loop buf 0 prefix 0 prefix-len)
      ;; Add dot separator
      (store-byte (ptr+ buf prefix-len) 46)  ;; '.' = 46
      ;; Write the counter number
      (let ((end-idx (write-number buf (+ prefix-len 1) counter)))
        (do
          ;; Null terminate
          (store-byte (ptr+ buf end-idx) 0)
          ;; Intern as symbol and return with incremented counter
          (pcons (cg-inc-block-counter ctx) (intern syms buf)))))))

;; String constants for label prefixes
(defun str-then-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 0) b)))

(defun str-else-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 0) b)))

(defun str-merge-prefix () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 109) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 103) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

;; ============================================================
;; Expression Codegen
;; ============================================================

;; Returns (ctx . lir-expr)
(defun codegen-expr (ctx: ptr form: ptr) -> ptr
  (cond
    ((ast-int? form)    (codegen-int ctx form))
    ((ast-float? form)  (codegen-float ctx form))
    ((ast-symbol? form) (codegen-symbol ctx form))
    ((ast-string? form) (codegen-string ctx form))
    ((ast-list? form)   (codegen-list ctx form))
    ((pcons? form)      (pcons ctx (box-int 0)))
    ((icons? form)      (pcons ctx (box-int 0)))
    ((nil? form)        (pcons ctx (box-int 0)))
    (else               (pcons ctx (box-int 0)))))

;; Integer literal: (i64 N)
(defun codegen-int (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (val (unbox-int form)))
    (pcons ctx (lir-int syms val))))

;; Float literal: (double N.M)
;; BoxedFloat stores: int-part, frac-part, scale (10^digits in frac)
;; E.g., 3.14 => int=3, frac=14, scale=100
;; We emit (double ...) with the reconstructed float value
(defun codegen-float (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; Emit the BoxedFloat directly - the lIR printer will handle it
    (pcons ctx (scons (sym-double syms) (scons form nil)))))

;; Symbol reference - pass through for now
(defun codegen-symbol (ctx: ptr form: ptr) -> ptr
  (pcons ctx form))

;; String literal - emit (string "...")
(defun codegen-string (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; form is a LiarString - wrap it in (string ...)
    (pcons ctx (scons (sym-string syms) (scons form nil)))))

;; ============================================================
;; List Form Dispatch
;; ============================================================

(defun codegen-list (ctx: ptr form: ptr) -> ptr
  (let ((head (car form)))
    (if (symbol? head)
        (let ((name (symbol-name head)))
          (cond
            ((streq name (str-if))     (codegen-if ctx form))
            ((streq name (str-let))    (codegen-let ctx form))
            ((streq name (str-defun))  (codegen-defun ctx form))
            ((streq name (str-do))     (codegen-do ctx form))
            ((streq name (str-fn))     (codegen-fn ctx form))
            ((streq name (str-plus))   (codegen-binop ctx form (sym-add (cg-syms ctx))))
            ((streq name (str-minus))  (codegen-binop ctx form (sym-sub (cg-syms ctx))))
            ((streq name (str-star))   (codegen-binop ctx form (sym-mul (cg-syms ctx))))
            ((streq name (str-slash))  (codegen-binop ctx form (sym-sdiv (cg-syms ctx))))
            ((streq name (str-rem))    (codegen-binop ctx form (sym-srem (cg-syms ctx))))
            ((streq name (str-eq))     (codegen-cmp ctx form (sym-eq (cg-syms ctx))))
            ((streq name (str-lt))     (codegen-cmp ctx form (sym-slt (cg-syms ctx))))
            ((streq name (str-gt))     (codegen-cmp ctx form (sym-sgt (cg-syms ctx))))
            ((streq name (str-lte))    (codegen-cmp ctx form (sym-sle (cg-syms ctx))))
            ((streq name (str-gte))    (codegen-cmp ctx form (sym-sge (cg-syms ctx))))
            ;; Float arithmetic operators
            ((streq name (str-plus-dot))    (codegen-float-binop ctx form (sym-fadd (cg-syms ctx))))
            ((streq name (str-minus-dot))   (codegen-float-binop ctx form (sym-fsub (cg-syms ctx))))
            ((streq name (str-star-dot))    (codegen-float-binop ctx form (sym-fmul (cg-syms ctx))))
            ((streq name (str-slash-dot))   (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx))))
            ((streq name (str-percent-dot)) (codegen-float-binop ctx form (sym-frem (cg-syms ctx))))
            ((streq name (str-fadd))        (codegen-float-binop ctx form (sym-fadd (cg-syms ctx))))
            ((streq name (str-fsub))        (codegen-float-binop ctx form (sym-fsub (cg-syms ctx))))
            ((streq name (str-fmul))        (codegen-float-binop ctx form (sym-fmul (cg-syms ctx))))
            ((streq name (str-fdiv))        (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx))))
            ((streq name (str-frem))        (codegen-float-binop ctx form (sym-frem (cg-syms ctx))))
            (else                      (codegen-call ctx form))))
        (codegen-call ctx form))))

;; ============================================================
;; Binary Operations
;; ============================================================

(defun codegen-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

(defun codegen-cmp (ctx: ptr form: ptr pred: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-icmp syms pred left-v right-v))))

;; Float binary operations - same as codegen-binop but for float ops
(defun codegen-float-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

;; ============================================================
;; If Expression (with proper branching)
;; ============================================================

;; Emit proper control flow using br/phi for short-circuit evaluation
;; This enables recursion to work correctly (unlike select which evaluates both branches)
;;
;; For (if cond then else), we generate:
;;   (block entry (br cond-v then-label else-label))
;;   (block then-label (let ((then-var then-v)) (br merge-label)))
;;   (block else-label (let ((else-var else-v)) (br merge-label)))
;;   (block merge-label (ret (phi i64 (then-label then-var) (else-label else-var))))
;;
;; The then-var/else-var let bindings ensure values are computed in their blocks
;; before being referenced by phi in the merge block.

(defun codegen-if (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))

        ;; Generate unique block labels
        (then-result (cg-fresh-label ctx (str-then-prefix)))
        (ctx (pcons-head then-result))
        (then-lbl (pcons-tail then-result))

        (else-result (cg-fresh-label ctx (str-else-prefix)))
        (ctx (pcons-head else-result))
        (else-lbl (pcons-tail else-result))

        (merge-result (cg-fresh-label ctx (str-merge-prefix)))
        (ctx (pcons-head merge-result))
        (merge-lbl (pcons-tail merge-result))

        ;; Compile condition expression
        (cond-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head cond-result))
        (cond-v (pcons-tail cond-result))

        ;; Compile then expression
        (then-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head then-result))
        (then-v (pcons-tail then-result))

        ;; Compile else expression
        (else-result (codegen-expr ctx (cadddr form)))
        (ctx (pcons-head else-result))
        (else-v (pcons-tail else-result))

        ;; Build entry block: (block entry (br cond then else))
        (entry-block (lir-block syms (sym-entry syms)
                                (scons (lir-br-cond syms cond-v then-lbl else-lbl) nil)))

        ;; Build then block: (block then (let ((then-var then-v)) (br merge)))
        ;; We wrap then-v in a let to ensure it's computed in the then block
        (then-block (lir-block syms then-lbl
                               (scons (lir-let1 syms then-lbl then-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Build else block: (block else (let ((else-var else-v)) (br merge)))
        (else-block (lir-block syms else-lbl
                               (scons (lir-let1 syms else-lbl else-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Add blocks to context (in reverse order so they come out right)
        (ctx (cg-add-block ctx else-block))
        (ctx (cg-add-block ctx then-block))
        (ctx (cg-add-block ctx entry-block))

        ;; Set merge label for defun to use
        (ctx (cg-set-merge-label ctx merge-lbl))

        ;; Build phi expression that will be in the merge block
        (phi-expr (lir-phi syms (sym-i64 syms) then-lbl then-lbl else-lbl else-lbl)))

    (pcons ctx phi-expr)))

;; ============================================================
;; Let Bindings
;; ============================================================

(defun codegen-let-body (ctx: ptr bindings: ptr body: ptr) -> ptr
  (if (nil? bindings)
      (codegen-expr ctx body)
      (let ((binding (car bindings))
            (name (car binding))
            (val-form (cadr binding))
            (val-result (codegen-expr ctx val-form))
            (ctx (pcons-head val-result))
            (val-v (pcons-tail val-result))
            (rest-result (codegen-let-body ctx (cdr bindings) body))
            (ctx (pcons-head rest-result))
            (rest-v (pcons-tail rest-result))
            (syms (cg-syms ctx)))
        (pcons ctx (lir-let1 syms name val-v rest-v)))))

(defun codegen-let (ctx: ptr form: ptr) -> ptr
  (let ((bindings (cadr form))
        (body (caddr form)))
    (codegen-let-body ctx bindings body)))

;; ============================================================
;; Do Block
;; ============================================================

(defun codegen-do-loop (ctx: ptr exprs: ptr last-v: ptr) -> ptr
  (if (nil? exprs)
      (pcons ctx last-v)
      (let ((result (codegen-expr ctx (car exprs)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-do-loop ctx (cdr exprs) v))))

(defun codegen-do (ctx: ptr form: ptr) -> ptr
  (codegen-do-loop ctx (cdr form) (box-int 0)))

;; ============================================================
;; Function Call
;; ============================================================

(defun codegen-args (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx acc)
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args ctx (cdr args) (scons v acc)))))

(defun codegen-call (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (args (cdr form))
        (args-result (codegen-args ctx args nil))
        (ctx (pcons-head args-result))
        (args-rev (pcons-tail args-result))
        (args-v (reverse-scons args-rev))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-call syms head args-v))))

;; ============================================================
;; Function Definition
;; ============================================================

;; Get the nth element of a list (0-indexed)
(defun list-nth (lst: ptr n: i64) -> ptr
  (if (<= n 0)
      (car lst)
      (list-nth (cdr lst) (- n 1))))

;; Check if element at index 3 is the arrow symbol ->
(defun has-return-type? (form: ptr) -> i64
  (let ((elem3 (list-nth form 3)))
    (if (symbol? elem3)
        (let ((name (symbol-name elem3)))
          (if (= (load-byte name) 45)           ;; '-'
              (if (= (load-byte (ptr+ name 1)) 62)   ;; '>'
                  1
                  0)
              0))
        0)))

;; Extract function body from defun form
(defun get-defun-body (form: ptr) -> ptr
  (if (= (has-return-type? form) 1)
      (list-nth form 5)
      (cadddr form)))

;; Transform params from (name : type name : type) to ((type name) (type name))
;; Skip colons, pair up names with types, swap order
(defun transform-params (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      ;; lst is: name : type rest...
      (let ((name (car lst))
            (rest (cdr lst)))  ;; should be (: type rest...)
        (if (nil? rest)
            (reverse-scons acc)  ;; malformed, just return what we have
            (let ((colon (car rest))
                  (rest2 (cdr rest)))  ;; should be (type rest...)
              (if (nil? rest2)
                  (reverse-scons acc)  ;; malformed
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2))  ;; remaining params
                        ;; Build (type name) pair
                        (pair (scons typ (scons name nil))))
                    (transform-params rest3 (scons pair acc)))))))))

;; Build the list of blocks for a function with branching
;; Blocks are already in correct order [entry, then, else], just append merge
(defun build-function-blocks (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (let ((merge-block (lir-block syms merge-lbl
                                (scons (lir-ret syms body-v) nil))))
    ;; Append merge block to the end
    (append-scons blocks (scons merge-block nil))))

;; Append two scons lists
(defun append-scons (lst1: ptr lst2: ptr) -> ptr
  (if (nil? lst1)
      lst2
      (scons (car lst1) (append-scons (cdr lst1) lst2))))

;; Helper to build function body based on whether there are blocks
(defun build-fn-body (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (if (nil? blocks)
      ;; No branching: simple single-block function
      (scons (scons (sym-block syms)
                    (scons (sym-entry syms)
                           (scons (lir-ret syms body-v) nil)))
             nil)
      ;; Has branching: use accumulated blocks + merge block
      (build-function-blocks syms blocks merge-lbl body-v)))

(defun codegen-defun (ctx: ptr form: ptr) -> ptr
  ;; (defun name (params) body) OR (defun name (params) -> type body)
  (let ((name (cadr form))
        (raw-params (caddr form))
        (lir-params (transform-params raw-params nil))
        (body (get-defun-body form))
        (syms (cg-syms ctx))
        ;; Reset temp and block counters for function body
        (fn-ctx (share (CodegenCtx 0 syms (cg-env ctx) nil 0 nil nil)))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        ;; Check if body generated any blocks (from if expressions)
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        ;; Build function signature: (name return-type)
        (fn-sig (scons name (scons (sym-i64 syms) nil)))
        ;; Build function body - call helper to avoid if in let binding
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        ;; Build complete function definition
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        ;; Add function to context
        (ctx (cg-add-fn ctx fn-def)))
    (pcons ctx fn-def)))

;; Lambda - stub for now
(defun codegen-fn (ctx: ptr form: ptr) -> ptr
  (pcons ctx (box-int 0)))

;; ============================================================
;; Top-Level
;; ============================================================

(defun codegen-toplevel (ctx: ptr forms: ptr) -> ptr
  (if (nil? forms)
      ctx
      (let ((result (codegen-expr ctx (car forms)))
            (ctx (pcons-head result)))
        (codegen-toplevel ctx (cdr forms)))))

(defun codegen-module (forms: ptr syms: ptr) -> ptr
  (let ((ctx (make-codegen-ctx syms))
        (ctx (codegen-toplevel ctx forms))
        (result (cg-fns ctx)))
    result))

