;; codegen.liar - lIR code generation for liarliar
;;
;; Walks the AST (SCons trees from reader.liar) and emits lIR as SCons trees.
;; The lIR is then serialized by a printer.
;;
;; Per ADR 019: lIR is the universal backend - all liar code emits lIR.
;; Per ADR 024: Type-directed codegen uses inferred types for optimal output.
;;
;; Design: Build lIR as data (cons cells), then print. This is cleaner than
;; string building and allows lIR-level transformations before output.

(ns liarliar.codegen
  (:require [liar.core :refer :all]
            [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]
            [liarliar.env :refer :all]))

;; ============================================================
;; Codegen Context
;; ============================================================

(defstruct CodegenCtx
  (cg-temp: i64        ;; Counter for unique temps (%0, %1, etc.)
   cg-syms: ptr        ;; SymbolTable for interning
   cg-env: ptr         ;; Current environment for name lookup
   cg-fns: ptr         ;; List of generated function definitions
   cg-block-counter: i64  ;; Counter for unique block labels
   cg-blocks: ptr      ;; List of accumulated blocks (for branching)
   cg-merge-label: ptr ;; Label for merge block (set by if)
   cg-structs: ptr     ;; NEW: List of struct definitions (unused)
   cg-type-id: i64     ;; NEW: Counter for type IDs (unused)
   cg-struct-defs: ptr ;; NEW: List of struct defs (unused)
   cg-fn-names: ptr    ;; List of known function symbols
   cg-proto-methods: ptr ;; List of protocol method entries
   cg-proto-impls: ptr ;; List of protocol impl entries
   cg-proto-defaults: ptr ;; List of protocol default entries
   cg-type-protocols: ptr ;; List of type -> protocol list entries
   cg-closure-counter: i64)) ;; Counter for generated lambda names

(defun make-codegen-ctx (syms: ptr) -> ptr
  (share (CodegenCtx 0 syms (make-global-env) nil 0 nil nil nil 1 nil nil nil nil nil nil 0)))

(defun cg-temp (ctx: ptr) -> i64 (. ctx cg-temp))
(defun cg-syms (ctx: ptr) -> ptr (. ctx cg-syms))
(defun cg-env (ctx: ptr) -> ptr (. ctx cg-env))
(defun cg-fns (ctx: ptr) -> ptr (. ctx cg-fns))
(defun cg-block-counter (ctx: ptr) -> i64 (. ctx cg-block-counter))
(defun cg-blocks (ctx: ptr) -> ptr (. ctx cg-blocks))
(defun cg-merge-label (ctx: ptr) -> ptr (. ctx cg-merge-label))
(defun cg-structs (ctx: ptr) -> ptr (. ctx cg-structs))
(defun cg-type-id (ctx: ptr) -> i64 (. ctx cg-type-id))
(defun cg-struct-defs (ctx: ptr) -> ptr (. ctx cg-struct-defs))
(defun cg-fn-names (ctx: ptr) -> ptr (. ctx cg-fn-names))
(defun cg-proto-methods (ctx: ptr) -> ptr (. ctx cg-proto-methods))
(defun cg-proto-impls (ctx: ptr) -> ptr (. ctx cg-proto-impls))
(defun cg-proto-defaults (ctx: ptr) -> ptr (. ctx cg-proto-defaults))
(defun cg-type-protocols (ctx: ptr) -> ptr (. ctx cg-type-protocols))
(defun cg-closure-counter (ctx: ptr) -> i64 (. ctx cg-closure-counter))

;; Register a struct (returns updated context with new type_id)
;; Entry is stored as (name fields type_id) - a 3-element scons list
(defun cg-register-struct (ctx: ptr name: ptr fields: ptr) -> ptr
  (let ((type-id (cg-type-id ctx))
        (entry (scons name (scons fields (scons (box-int type-id) nil)))))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (scons entry (cg-structs ctx)) (+ type-id 1) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                       (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))
  )

;; Add defstruct definition to list
(defun cg-add-struct-def (ctx: ptr sdef: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (scons sdef (cg-struct-defs ctx))
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; Compare two interned symbols by their IDs
(defun sym-eq? (a: ptr b: ptr) -> i64
  (if (= (symbol-id a) (symbol-id b)) 1 0))

;; ============================================================
;; Function Registry
;; ============================================================

(defun fn-list-has? (lst: ptr name: ptr) -> i64
  (if (nil? lst)
      0
      (if (= 1 (sym-eq? (pcons-head lst) name))
          1
          (fn-list-has? (pcons-tail lst) name))))

(defun cg-add-fn-name (ctx: ptr name: ptr) -> ptr
  (if (= 1 (fn-list-has? (cg-fn-names ctx) name))
      ctx
      (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                         (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                         (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                         (pcons name (cg-fn-names ctx)) (cg-proto-methods ctx)
                         (cg-proto-impls ctx) (cg-proto-defaults ctx)
                         (cg-type-protocols ctx) (cg-closure-counter ctx)))))

;; Add function definition and register name
(defun cg-add-fn-def (ctx: ptr name: ptr fn-def: ptr) -> ptr
  (let ((ctx (cg-add-fn-name ctx name)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx)
                       (scons fn-def (cg-fns ctx))
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx)
                       (cg-proto-impls ctx) (cg-proto-defaults ctx)
                       (cg-type-protocols ctx) (cg-closure-counter ctx)))))

;; ============================================================
;; Protocol Metadata
;; ============================================================

;; Protocol method entry: (method protocol return-type)
(defun proto-method-entry (method: ptr protocol: ptr ret: ptr) -> ptr
  (pcons method (pcons protocol (pcons ret nil))))

(defun proto-method-name (entry: ptr) -> ptr
  (pcons-head entry))

(defun proto-method-protocol (entry: ptr) -> ptr
  (pcons-head (pcons-tail entry)))

(defun proto-method-ret (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail entry))))

(defun proto-methods-find (lst: ptr method: ptr protocol: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (pcons-head lst)))
        (if (and (= 1 (sym-eq? (proto-method-name entry) method))
                 (= 1 (sym-eq? (proto-method-protocol entry) protocol)))
            entry
            (proto-methods-find (pcons-tail lst) method protocol)))))

(defun cg-register-proto-method (ctx: ptr method: ptr protocol: ptr ret: ptr) -> ptr
  (let ((entry (proto-method-entry method protocol ret)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (pcons entry (cg-proto-methods ctx))
                       (cg-proto-impls ctx) (cg-proto-defaults ctx)
                       (cg-type-protocols ctx) (cg-closure-counter ctx)))))

(defun cg-update-proto-method-ret (ctx: ptr method: ptr protocol: ptr ret: ptr) -> ptr
  (let ((entries (cg-proto-methods ctx)))
    (cg-update-proto-method-ret-loop ctx entries nil method protocol ret)))

(defun cg-update-proto-method-ret-loop (ctx: ptr entries: ptr acc: ptr method: ptr protocol: ptr ret: ptr) -> ptr
  (if (nil? entries)
      (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                         (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                         (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                         (cg-fn-names ctx) (reverse-pcons acc)
                         (cg-proto-impls ctx) (cg-proto-defaults ctx)
                         (cg-type-protocols ctx) (cg-closure-counter ctx)))
      (let ((entry (pcons-head entries))
            (rest (pcons-tail entries)))
        (if (and (= 1 (sym-eq? (proto-method-name entry) method))
                 (= 1 (sym-eq? (proto-method-protocol entry) protocol)))
            (let ((new-entry (proto-method-entry method protocol ret)))
              (cg-update-proto-method-ret-loop ctx rest (pcons new-entry acc) method protocol ret))
            (cg-update-proto-method-ret-loop ctx rest (pcons entry acc) method protocol ret)))))

;; Protocol impl entry: (protocol type method fn-name)
(defun proto-impl-entry (protocol: ptr type-name: ptr method: ptr fn-name: ptr) -> ptr
  (pcons protocol (pcons type-name (pcons method (pcons fn-name nil)))))

(defun proto-impl-protocol (entry: ptr) -> ptr
  (pcons-head entry))

(defun proto-impl-type (entry: ptr) -> ptr
  (pcons-head (pcons-tail entry)))

(defun proto-impl-method (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail entry))))

(defun proto-impl-fn (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail (pcons-tail entry)))))

(defun cg-register-proto-impl (ctx: ptr protocol: ptr type-name: ptr method: ptr fn-name: ptr) -> ptr
  (let ((entry (proto-impl-entry protocol type-name method fn-name)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx)
                       (pcons entry (cg-proto-impls ctx)) (cg-proto-defaults ctx)
                       (cg-type-protocols ctx) (cg-closure-counter ctx)))))

;; Protocol default entry: (target protocol source protocol method fn-name)
(defun proto-default-entry (target: ptr source: ptr method: ptr fn-name: ptr) -> ptr
  (pcons target (pcons source (pcons method (pcons fn-name nil)))))

(defun proto-default-target (entry: ptr) -> ptr
  (pcons-head entry))

(defun proto-default-source (entry: ptr) -> ptr
  (pcons-head (pcons-tail entry)))

(defun proto-default-method (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail entry))))

(defun proto-default-fn (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail (pcons-tail entry)))))

(defun cg-register-proto-default (ctx: ptr target: ptr source: ptr method: ptr fn-name: ptr) -> ptr
  (let ((entry (proto-default-entry target source method fn-name)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx)
                       (cg-proto-impls ctx) (pcons entry (cg-proto-defaults ctx))
                       (cg-type-protocols ctx) (cg-closure-counter ctx)))))

;; Type -> protocols entry: (type-name . protocol-list)
(defun type-proto-entry (type-name: ptr protocols: ptr) -> ptr
  (pcons type-name protocols))

(defun type-proto-name (entry: ptr) -> ptr
  (pcons-head entry))

(defun type-proto-list (entry: ptr) -> ptr
  (pcons-tail entry))

(defun proto-list-has? (lst: ptr protocol: ptr) -> i64
  (if (nil? lst)
      0
      (if (= 1 (sym-eq? (pcons-head lst) protocol))
          1
          (proto-list-has? (pcons-tail lst) protocol))))

(defun cg-add-type-protocol (ctx: ptr type-name: ptr protocol: ptr) -> ptr
  (cg-add-type-protocol-loop ctx (cg-type-protocols ctx) nil type-name protocol))

(defun cg-add-type-protocol-loop (ctx: ptr entries: ptr acc: ptr type-name: ptr protocol: ptr) -> ptr
  (if (nil? entries)
      (let ((new-entry (type-proto-entry type-name (pcons protocol nil))))
        (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                           (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                           (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                           (cg-fn-names ctx) (cg-proto-methods ctx)
                           (cg-proto-impls ctx) (cg-proto-defaults ctx)
                           (pcons new-entry (reverse-pcons acc)) (cg-closure-counter ctx))))
      (let ((entry (pcons-head entries))
            (rest (pcons-tail entries)))
        (if (= 1 (sym-eq? (type-proto-name entry) type-name))
            (let ((protocols (type-proto-list entry))
                  (updated (if (= 1 (proto-list-has? protocols protocol))
                               protocols
                               (pcons protocol protocols)))
                  (new-entry (type-proto-entry type-name updated)))
              (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                                 (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                                 (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                 (cg-fn-names ctx) (cg-proto-methods ctx)
                                 (cg-proto-impls ctx) (cg-proto-defaults ctx)
                                 (append-pcons (reverse-pcons acc) (pcons new-entry rest))
                                 (cg-closure-counter ctx))))
            (cg-add-type-protocol-loop ctx rest (pcons entry acc) type-name protocol)))))

(defun find-type-protocols (entries: ptr type-name: ptr) -> ptr
  (if (nil? entries)
      nil
      (let ((entry (pcons-head entries)))
        (if (= 1 (sym-eq? (type-proto-name entry) type-name))
            (type-proto-list entry)
            (find-type-protocols (pcons-tail entries) type-name)))))

;; ============================================================
;; PCons Helpers
;; ============================================================

(defun reverse-pcons-acc (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      acc
      (reverse-pcons-acc (pcons-tail lst) (pcons (pcons-head lst) acc))))

(defun reverse-pcons (lst: ptr) -> ptr
  (reverse-pcons-acc lst nil))

(defun append-pcons (a: ptr b: ptr) -> ptr
  (if (nil? a)
      b
      (pcons (pcons-head a) (append-pcons (pcons-tail a) b))))

;; Lookup struct by name - returns entry (name fields type_id) scons list or nil
(defun cg-lookup-struct (ctx: ptr name: ptr) -> ptr
  (lookup-struct-loop (cg-structs ctx) name))

(defun lookup-struct-loop (lst: ptr name: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (car lst))
            (entry-name (car entry)))  ;; name is first element
        (if (= 1 (sym-eq? entry-name name))
            entry  ;; return full entry (name fields type_id)
            (lookup-struct-loop (cdr lst) name)))))

;; Helper to get fields from struct entry
(defun struct-entry-fields (entry: ptr) -> ptr
  (cadr entry))

;; Helper to get type_id from struct entry
(defun struct-entry-type-id (entry: ptr) -> i64
  (unbox-int (caddr entry)))

;; Get next temp and increment counter
(defun cg-next-temp (ctx: ptr) -> ptr
  (share (CodegenCtx (+ (cg-temp ctx) 1) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; Update environment
(defun cg-with-env (ctx: ptr new-env: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) new-env (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; Add function to list
(defun cg-add-fn (ctx: ptr fn-def: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx)
                     (scons fn-def (cg-fns ctx))
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; ============================================================
;; Block Management Helpers
;; ============================================================

;; Increment block counter and return updated context
(defun cg-inc-block-counter (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (+ (cg-block-counter ctx) 1) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; Add a block to the accumulated blocks list
(defun cg-add-block (ctx: ptr block: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (scons block (cg-blocks ctx)) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; Set the merge label for the if expression
(defun cg-set-merge-label (ctx: ptr label: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) label
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; Reset block state for new function
(defun cg-reset-blocks (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))

;; ============================================================
;; Symbol/String Helpers
;; ============================================================

;; Create a symbol from bytes (for lIR keywords)
;; Always allocate 9 bytes (8 chars + null), write all, null-terminate at len
(defun make-sym (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 len: i64) -> ptr
  (let ((buf (heap-array 9)))  ;; 8 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf len) 0)  ;; null terminate at len
      (intern syms buf))))

;; Helper for symbols up to 12 chars
(defun make-sym-long (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 len: i64) -> ptr
  (let ((buf (heap-array 13)))  ;; 12 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf len) 0)
      (intern syms buf))))

;; Helper for symbols of exactly 13 chars
(defun make-sym-13 (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12: i64) -> ptr
  (let ((buf (heap-array 14)))  ;; 13 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf 12) b12)
      (store-byte (ptr+ buf 13) 0)
      (intern syms buf))))

;; Common lIR symbols
(defun sym-i64 (s: ptr) -> ptr     (make-sym s 105 54 52 0 0 0 0 0 3))       ;; i64
(defun sym-i1 (s: ptr) -> ptr      (make-sym s 105 49 0 0 0 0 0 0 2))        ;; i1
(defun sym-ptr (s: ptr) -> ptr     (make-sym s 112 116 114 0 0 0 0 0 3))     ;; ptr
(defun sym-double (s: ptr) -> ptr  (make-sym s 100 111 117 98 108 101 0 0 6)) ;; double
(defun sym-add (s: ptr) -> ptr     (make-sym s 97 100 100 0 0 0 0 0 3))      ;; add
(defun sym-sub (s: ptr) -> ptr     (make-sym s 115 117 98 0 0 0 0 0 3))      ;; sub
(defun sym-mul (s: ptr) -> ptr     (make-sym s 109 117 108 0 0 0 0 0 3))     ;; mul
(defun sym-sdiv (s: ptr) -> ptr    (make-sym s 115 100 105 118 0 0 0 0 4))   ;; sdiv
(defun sym-srem (s: ptr) -> ptr    (make-sym s 115 114 101 109 0 0 0 0 4))   ;; srem
(defun sym-icmp (s: ptr) -> ptr    (make-sym s 105 99 109 112 0 0 0 0 4))    ;; icmp
(defun sym-eq (s: ptr) -> ptr      (make-sym s 101 113 0 0 0 0 0 0 2))       ;; eq
(defun sym-slt (s: ptr) -> ptr     (make-sym s 115 108 116 0 0 0 0 0 3))     ;; slt
(defun sym-sgt (s: ptr) -> ptr     (make-sym s 115 103 116 0 0 0 0 0 3))     ;; sgt
(defun sym-sle (s: ptr) -> ptr     (make-sym s 115 108 101 0 0 0 0 0 3))     ;; sle
(defun sym-sge (s: ptr) -> ptr     (make-sym s 115 103 101 0 0 0 0 0 3))     ;; sge
(defun sym-select (s: ptr) -> ptr  (make-sym s 115 101 108 101 99 116 0 0 6)) ;; select
(defun sym-call (s: ptr) -> ptr    (make-sym s 99 97 108 108 0 0 0 0 4))     ;; call
(defun sym-indirect-call (s: ptr) -> ptr
  (make-sym-13 s 105 110 100 105 114 101 99 116 45 99 97 108 108)) ;; indirect-call
(defun sym-ret (s: ptr) -> ptr     (make-sym s 114 101 116 0 0 0 0 0 3))     ;; ret
(defun sym-define (s: ptr) -> ptr  (make-sym s 100 101 102 105 110 101 0 0 6)) ;; define
(defun sym-block (s: ptr) -> ptr   (make-sym s 98 108 111 99 107 0 0 0 5))   ;; block
(defun sym-entry (s: ptr) -> ptr   (make-sym s 101 110 116 114 121 0 0 0 5)) ;; entry
(defun sym-let (s: ptr) -> ptr     (make-sym s 108 101 116 0 0 0 0 0 3))     ;; let
(defun sym-string (s: ptr) -> ptr  (make-sym s 115 116 114 105 110 103 0 0 6)) ;; string
(defun sym-br (s: ptr) -> ptr      (make-sym s 98 114 0 0 0 0 0 0 2))        ;; br
(defun sym-phi (s: ptr) -> ptr     (make-sym s 112 104 105 0 0 0 0 0 3))     ;; phi

;; Float arithmetic lIR symbols
(defun sym-fadd (s: ptr) -> ptr    (make-sym s 102 97 100 100 0 0 0 0 4))    ;; fadd
(defun sym-fsub (s: ptr) -> ptr    (make-sym s 102 115 117 98 0 0 0 0 4))    ;; fsub
(defun sym-fmul (s: ptr) -> ptr    (make-sym s 102 109 117 108 0 0 0 0 4))   ;; fmul
(defun sym-fdiv (s: ptr) -> ptr    (make-sym s 102 100 105 118 0 0 0 0 4))   ;; fdiv
(defun sym-frem (s: ptr) -> ptr    (make-sym s 102 114 101 109 0 0 0 0 4))   ;; frem

;; Type conversion lIR symbols
(defun sym-trunc (s: ptr) -> ptr   (make-sym s 116 114 117 110 99 0 0 0 5))  ;; trunc
(defun sym-zext (s: ptr) -> ptr    (make-sym s 122 101 120 116 0 0 0 0 4))   ;; zext
(defun sym-sext (s: ptr) -> ptr    (make-sym s 115 101 120 116 0 0 0 0 4))   ;; sext
(defun sym-fptosi (s: ptr) -> ptr  (make-sym s 102 112 116 111 115 105 0 0 6)) ;; fptosi
(defun sym-fptoui (s: ptr) -> ptr  (make-sym s 102 112 116 111 117 105 0 0 6)) ;; fptoui
(defun sym-sitofp (s: ptr) -> ptr  (make-sym s 115 105 116 111 102 112 0 0 6)) ;; sitofp
(defun sym-uitofp (s: ptr) -> ptr  (make-sym s 117 105 116 111 102 112 0 0 6)) ;; uitofp
(defun sym-fpext (s: ptr) -> ptr   (make-sym s 102 112 101 120 116 0 0 0 5))  ;; fpext
(defun sym-fptrunc (s: ptr) -> ptr (make-sym s 102 112 116 114 117 110 99 0 7)) ;; fptrunc

;; Pointer and null
(defun sym-null (s: ptr) -> ptr    (make-sym s 110 117 108 108 0 0 0 0 4))     ;; null

;; Struct-related lIR symbols
(defun sym-defstruct (s: ptr) -> ptr   (make-sym-long s 100 101 102 115 116 114 117 99 116 0 0 0 9)) ;; defstruct
(defun sym-heap-struct (s: ptr) -> ptr (make-sym-long s 104 101 97 112 45 115 116 114 117 99 116 0 11)) ;; heap-struct
(defun sym-getelementptr (s: ptr) -> ptr (make-sym-13 s 103 101 116 101 108 101 109 101 110 116 112 116 114)) ;; getelementptr
(defun sym-load (s: ptr) -> ptr    (make-sym s 108 111 97 100 0 0 0 0 4))      ;; load
(defun sym-inbounds (s: ptr) -> ptr (make-sym s 105 110 98 111 117 110 100 115 8)) ;; inbounds
(defun sym-alloca (s: ptr) -> ptr  (make-sym s 97 108 108 111 99 97 0 0 6))    ;; alloca
(defun sym-store (s: ptr) -> ptr   (make-sym s 115 116 111 114 101 0 0 0 5))   ;; store

;; Liar special forms (for dispatch)
(defun str-if () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 102) (store-byte (ptr+ b 2) 0) b)))

(defun str-let () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 108) (store-byte (ptr+ b 1) 101)
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 0) b)))

(defun str-defun () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 117) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 0) b)))

(defun str-do () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 0) b)))

(defun str-fn () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 0) b)))

(defun str-plus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 43) (store-byte (ptr+ b 1) 0) b)))

(defun str-minus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 45) (store-byte (ptr+ b 1) 0) b)))

(defun str-star () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 42) (store-byte (ptr+ b 1) 0) b)))

(defun str-slash () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 47) (store-byte (ptr+ b 1) 0) b)))

(defun str-rem () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 109)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-eq () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 61) (store-byte (ptr+ b 1) 0) b)))

(defun str-lt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 60) (store-byte (ptr+ b 1) 0) b)))

(defun str-gt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 62) (store-byte (ptr+ b 1) 0) b)))

(defun str-lte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 60) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-gte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 62) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

;; Float operator strings (+., -., *., /., %.)
(defun str-plus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 43) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-minus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 45) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-star-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 42) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-slash-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 47) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-percent-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 37) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

;; Named float operator strings (fadd, fsub, fmul, fdiv, frem)
(defun str-fadd () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 97) (store-byte (ptr+ b 2) 100)
        (store-byte (ptr+ b 3) 100) (store-byte (ptr+ b 4) 0) b)))

(defun str-fsub () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 98) (store-byte (ptr+ b 4) 0) b)))

(defun str-fmul () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 109) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 108) (store-byte (ptr+ b 4) 0) b)))

(defun str-fdiv () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 100) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 118) (store-byte (ptr+ b 4) 0) b)))

(defun str-frem () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 109) (store-byte (ptr+ b 4) 0) b)))

;; Type conversion operator strings
(defun str-trunc () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 99) (store-byte (ptr+ b 5) 0) b)))

(defun str-zext () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 122) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 120)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-sext () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 120)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-fptosi () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-fptoui () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 117) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-sitofp () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 102) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-uitofp () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 117) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 102) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-fpext () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 120) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 0) b)))

(defun str-fptrunc () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 117) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 0) b)))

;; Builtin operator strings
(defun str-nil? () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 108)
        (store-byte (ptr+ b 3) 63) (store-byte (ptr+ b 4) 0) b)))

(defun str-nil () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 105)
        (store-byte (ptr+ b 2) 108) (store-byte (ptr+ b 3) 0) b)))

(defun str-true () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 114)
        (store-byte (ptr+ b 2) 117) (store-byte (ptr+ b 3) 101)
        (store-byte (ptr+ b 4) 0) b)))

(defun str-false () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 97)
        (store-byte (ptr+ b 2) 108) (store-byte (ptr+ b 3) 115)
        (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

(defun str-colon () -> ptr
  (let ((b (heap-array 2)))
    (do (store-byte b 58) (store-byte (ptr+ b 1) 0) b)))

(defun str-self () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 101)
        (store-byte (ptr+ b 2) 108) (store-byte (ptr+ b 3) 102)
        (store-byte (ptr+ b 4) 0) b)))

(defun str-defstruct () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 115) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 114)
        (store-byte (ptr+ b 6) 117) (store-byte (ptr+ b 7) 99) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-defprotocol () -> ptr
  (let ((b (heap-array 12)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 112) (store-byte (ptr+ b 4) 114) (store-byte (ptr+ b 5) 111)
        (store-byte (ptr+ b 6) 116) (store-byte (ptr+ b 7) 111) (store-byte (ptr+ b 8) 99)
        (store-byte (ptr+ b 9) 111) (store-byte (ptr+ b 10) 108) (store-byte (ptr+ b 11) 0) b)))

(defun str-extend-protocol () -> ptr
  (let ((b (heap-array 16)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 120) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 100)
        (store-byte (ptr+ b 6) 45) (store-byte (ptr+ b 7) 112) (store-byte (ptr+ b 8) 114)
        (store-byte (ptr+ b 9) 111) (store-byte (ptr+ b 10) 116) (store-byte (ptr+ b 11) 111)
        (store-byte (ptr+ b 12) 99) (store-byte (ptr+ b 13) 111) (store-byte (ptr+ b 14) 108)
        (store-byte (ptr+ b 15) 0) b)))

(defun str-extend-protocol-default () -> ptr
  (let ((b (heap-array 24)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 120) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 100)
        (store-byte (ptr+ b 6) 45) (store-byte (ptr+ b 7) 112) (store-byte (ptr+ b 8) 114)
        (store-byte (ptr+ b 9) 111) (store-byte (ptr+ b 10) 116) (store-byte (ptr+ b 11) 111)
        (store-byte (ptr+ b 12) 99) (store-byte (ptr+ b 13) 111) (store-byte (ptr+ b 14) 108)
        (store-byte (ptr+ b 15) 45) (store-byte (ptr+ b 16) 100) (store-byte (ptr+ b 17) 101)
        (store-byte (ptr+ b 18) 102) (store-byte (ptr+ b 19) 97) (store-byte (ptr+ b 20) 117)
        (store-byte (ptr+ b 21) 108) (store-byte (ptr+ b 22) 116) (store-byte (ptr+ b 23) 0) b)))

(defun str-share () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 97)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

(defun str-instance? () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 97) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 63)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-dot () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 46) (store-byte (ptr+ b 1) 0) b)))

;; ============================================================
;; AST Predicates
;; ============================================================

(defun ast-symbol? (form: ptr) (symbol? form))
(defun ast-int? (form: ptr) (boxed-int? form))
(defun ast-bool? (form: ptr) (boxed-bool? form))
(defun ast-float? (form: ptr) (boxed-float? form))
(defun ast-string? (form: ptr) (liar-string? form))
(defun ast-list? (form: ptr) (scons? form))

;; ============================================================
;; Symbol Helpers
;; ============================================================

;; Find last occurrence of a byte in a string, or -1 if not found
(defun find-last-char (s: ptr idx: i64 last: i64 target: i64) -> i64
  (let ((c (load-byte (ptr+ s idx))))
    (if (= c 0)
        last
        (if (= c target)
            (find-last-char s (+ idx 1) idx target)
            (find-last-char s (+ idx 1) last target)))))

;; Return the base name after the last '/' (for namespaced symbols)
(defun symbol-base-name (syms: ptr sym: ptr) -> ptr
  (let ((name (symbol-name sym))
        (len (strlen name))
        (slash (find-last-char name 0 -1 47)))
    (if (and (= len 1) (= slash 0))
        name
        (if (< slash 0)
        name
        (let ((base-len (- len (+ slash 1)))
              (buf (heap-array (+ base-len 1))))
          (do
            (copy-str-loop buf 0 (ptr+ name (+ slash 1)) 0 base-len)
            (store-byte (ptr+ buf base-len) 0)
            buf))))))

;; Check if symbol name matches a string, returning i64 1/0
(defun symbol-name-match? (sym: ptr name: ptr) -> i64
  (if (symbol? sym)
      (if (streq (symbol-name sym) name) 1 0)
      0))

;; ============================================================
;; lIR Construction Helpers
;; ============================================================

;; Build: (i64 N)
(defun lir-int (syms: ptr val: i64) -> ptr
  (scons (sym-i64 syms) (scons (box-int val) nil)))

;; Build: (i1 N)
(defun lir-i1 (syms: ptr val: i64) -> ptr
  (scons (sym-i1 syms) (scons (box-int val) nil)))

;; Build: %N (temp reference as symbol)
(defun lir-temp (syms: ptr n: i64) -> ptr
  ;; Create %N symbol - for now just use the number as a boxed int marker
  ;; Real impl would create "%0", "%1" etc symbols
  (box-int n))

;; Build: (op left right)
(defun lir-binop (syms: ptr op: ptr left: ptr right: ptr) -> ptr
  (scons op (scons left (scons right nil))))

;; Build: (icmp pred left right)
(defun lir-icmp (syms: ptr pred: ptr left: ptr right: ptr) -> ptr
  (scons (sym-icmp syms) (scons pred (scons left (scons right nil)))))

;; Build: (select cond then else)
(defun lir-select (syms: ptr cond-v: ptr then-v: ptr else-v: ptr) -> ptr
  (scons (sym-select syms) (scons cond-v (scons then-v (scons else-v nil)))))

;; Build: (ptr null)
(defun lir-null (syms: ptr) -> ptr
  (scons (sym-ptr syms) (scons (sym-null syms) nil)))

;; Build: (load type ptr)
(defun lir-load (syms: ptr ty: ptr ptr-expr: ptr) -> ptr
  (scons (sym-load syms) (scons ty (scons ptr-expr nil))))

;; Helper: prepend @ to a string and intern it as a symbol
(extern strlen i64 (ptr))

(defun prepend-at (syms: ptr name: ptr) -> ptr
  (let ((name-len (strlen name))
        (new-len (+ name-len 2))  ;; @ + name + null
        (buf (heap-array new-len)))
    (do
      (store-byte buf 64)  ;; '@' = 64
      (copy-str-loop buf 1 name 0 name-len)
      (store-byte (ptr+ buf (+ name-len 1)) 0)  ;; null terminator
      (intern syms buf))))

(defun copy-str-loop (dst: ptr dst-idx: i64 src: ptr src-idx: i64 len: i64) -> i64
  (if (>= src-idx len)
      0
      (do
        (store-byte (ptr+ dst dst-idx) (load-byte (ptr+ src src-idx)))
        (copy-str-loop dst (+ dst-idx 1) src (+ src-idx 1) len))))

;; Build: (call @fn args...)
(defun lir-call (syms: ptr fn-name: ptr args: ptr) -> ptr
  (let ((at-name (prepend-at syms (symbol-name fn-name))))
    (scons (sym-call syms) (scons at-name args))))

;; Build: (indirect-call fn-ptr ret-type args...)
(defun lir-indirect-call (syms: ptr fn-ptr: ptr ret-ty: ptr args: ptr) -> ptr
  (scons (sym-indirect-call syms) (scons fn-ptr (scons ret-ty args))))

;; Build: (ret val)
(defun lir-ret (syms: ptr val: ptr) -> ptr
  (scons (sym-ret syms) (scons val nil)))

;; Build: (let ((name val)) body)
(defun lir-let1 (syms: ptr name: ptr val: ptr body: ptr) -> ptr
  (scons (sym-let syms)
         (scons (scons (scons name (scons val nil)) nil)
                (scons body nil))))

;; Build: (br label) - unconditional branch
(defun lir-br (syms: ptr label: ptr) -> ptr
  (scons (sym-br syms) (scons label nil)))

;; Build: (br cond then-label else-label) - conditional branch
(defun lir-br-cond (syms: ptr cond-v: ptr then-lbl: ptr else-lbl: ptr) -> ptr
  (scons (sym-br syms) (scons cond-v (scons then-lbl (scons else-lbl nil)))))

;; Build: (phi type (label val) (label val))
(defun lir-phi (syms: ptr ty: ptr lbl1: ptr val1: ptr lbl2: ptr val2: ptr) -> ptr
  (scons (sym-phi syms)
         (scons ty
                (scons (scons lbl1 (scons val1 nil))
                       (scons (scons lbl2 (scons val2 nil)) nil)))))

;; Build: (block label body...)
(defun lir-block (syms: ptr label: ptr body: ptr) -> ptr
  (scons (sym-block syms) (scons label body)))

;; ============================================================
;; Block Label Generation
;; ============================================================

;; Helper to write a digit to buffer
(defun write-digit (buf: ptr idx: i64 n: i64) -> i64
  (do (store-byte (ptr+ buf idx) (+ 48 n)) (+ idx 1)))

;; Write number to buffer, return new index
(defun write-number (buf: ptr idx: i64 n: i64) -> i64
  (if (< n 10)
      (write-digit buf idx n)
      (let ((idx2 (write-number buf idx (/ n 10))))
        (write-digit buf idx2 (- n (* (/ n 10) 10))))))

;; Generate fresh block label like "then.0", "else.1", "merge.2"
;; Returns (ctx . label-symbol)
(defun cg-fresh-label (ctx: ptr prefix: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (counter (cg-block-counter ctx))
        (prefix-len (strlen prefix))
        (buf (heap-array 20)))  ;; enough for prefix.NNNN
    (do
      ;; Copy prefix to buffer
      (copy-str-loop buf 0 prefix 0 prefix-len)
      ;; Add dot separator
      (store-byte (ptr+ buf prefix-len) 46)  ;; '.' = 46
      ;; Write the counter number
      (let ((end-idx (write-number buf (+ prefix-len 1) counter)))
        (do
          ;; Null terminate
          (store-byte (ptr+ buf end-idx) 0)
          ;; Intern as symbol and return with incremented counter
          (pcons (cg-inc-block-counter ctx) (intern syms buf)))))))

;; String constants for label prefixes
(defun str-then-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 0) b)))

(defun str-else-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 0) b)))

(defun str-merge-prefix () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 109) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 103) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

;; ============================================================
;; Expression Codegen
;; ============================================================

;; Returns (ctx . lir-expr)
(defun codegen-expr (ctx: ptr form: ptr) -> ptr
  (cond
    ((ast-int? form)    (codegen-int ctx form))
    ((ast-bool? form)   (codegen-bool ctx form))
    ((ast-float? form)  (codegen-float ctx form))
    ((ast-symbol? form) (codegen-symbol ctx form))
    ((ast-string? form) (codegen-string ctx form))
    ((ast-list? form)   (codegen-list ctx form))
    ((pcons? form)      (pcons ctx (box-int 0)))
    ((icons? form)      (pcons ctx (box-int 0)))
    ((nil? form)        (pcons ctx (box-int 0)))
    (else               (pcons ctx (box-int 0)))))

;; Integer literal: (i64 N)
(defun codegen-int (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (val (unbox-int form)))
    (pcons ctx (lir-int syms val))))

;; Boolean literal: (i1 0|1)
(defun codegen-bool (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (val (unbox-bool form)))
    (pcons ctx (lir-i1 syms val))))

;; Float literal: (double N.M)
;; BoxedFloat stores: int-part, frac-part, scale (10^digits in frac)
;; E.g., 3.14 => int=3, frac=14, scale=100
;; We emit (double ...) with the reconstructed float value
(defun codegen-float (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; Emit the BoxedFloat directly - the lIR printer will handle it
    (pcons ctx (scons (sym-double syms) (scons form nil)))))

;; Symbol reference - pass through for now
(defun codegen-symbol (ctx: ptr form: ptr) -> ptr
  (let ((name (symbol-name form))
        (syms (cg-syms ctx)))
    (if (streq name (str-nil))
        (pcons ctx (lir-null syms))
        (if (streq name (str-true))
            (pcons ctx (lir-i1 syms 1))
            (if (streq name (str-false))
                (pcons ctx (lir-i1 syms 0))
                (pcons ctx form))))))

;; String literal - emit (string "...")
(defun codegen-string (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; form is a LiarString - wrap it in (string ...)
    (pcons ctx (scons (sym-string syms) (scons form nil)))))

;; ============================================================
;; List Form Dispatch
;; ============================================================

(defun codegen-list (ctx: ptr form: ptr) -> ptr
  (let ((head (car form)))
    (if (symbol? head)
        (let ((name (symbol-name head))
              (base-name (symbol-base-name (cg-syms ctx) head)))
          (cond
            ((streq base-name (str-if))     (codegen-if ctx form))
            ((streq base-name (str-let))    (codegen-let ctx form))
            ((streq base-name (str-defun))  (codegen-defun ctx form))
            ((streq base-name (str-do))     (codegen-do ctx form))
            ((streq base-name (str-fn))     (codegen-fn ctx form))
            ((streq base-name (str-plus))   (codegen-binop ctx form (sym-add (cg-syms ctx))))
            ((streq base-name (str-minus))  (codegen-binop ctx form (sym-sub (cg-syms ctx))))
            ((streq base-name (str-star))   (codegen-binop ctx form (sym-mul (cg-syms ctx))))
            ((streq base-name (str-slash))  (codegen-binop ctx form (sym-sdiv (cg-syms ctx))))
            ((streq base-name (str-rem))    (codegen-binop ctx form (sym-srem (cg-syms ctx))))
            ((streq base-name (str-eq))     (codegen-cmp ctx form (sym-eq (cg-syms ctx))))
            ((streq base-name (str-lt))     (codegen-cmp ctx form (sym-slt (cg-syms ctx))))
            ((streq base-name (str-gt))     (codegen-cmp ctx form (sym-sgt (cg-syms ctx))))
            ((streq base-name (str-lte))    (codegen-cmp ctx form (sym-sle (cg-syms ctx))))
            ((streq base-name (str-gte))    (codegen-cmp ctx form (sym-sge (cg-syms ctx))))
            ;; Float arithmetic operators
            ((streq base-name (str-plus-dot))    (codegen-float-binop ctx form (sym-fadd (cg-syms ctx))))
            ((streq base-name (str-minus-dot))   (codegen-float-binop ctx form (sym-fsub (cg-syms ctx))))
            ((streq base-name (str-star-dot))    (codegen-float-binop ctx form (sym-fmul (cg-syms ctx))))
            ((streq base-name (str-slash-dot))   (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx))))
            ((streq base-name (str-percent-dot)) (codegen-float-binop ctx form (sym-frem (cg-syms ctx))))
            ((streq base-name (str-fadd))        (codegen-float-binop ctx form (sym-fadd (cg-syms ctx))))
            ((streq base-name (str-fsub))        (codegen-float-binop ctx form (sym-fsub (cg-syms ctx))))
            ((streq base-name (str-fmul))        (codegen-float-binop ctx form (sym-fmul (cg-syms ctx))))
            ((streq base-name (str-fdiv))        (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx))))
            ((streq base-name (str-frem))        (codegen-float-binop ctx form (sym-frem (cg-syms ctx))))
            ;; Type conversion operators
            ((streq base-name (str-trunc))       (codegen-conv ctx form (sym-trunc (cg-syms ctx))))
            ((streq base-name (str-zext))        (codegen-conv ctx form (sym-zext (cg-syms ctx))))
            ((streq base-name (str-sext))        (codegen-conv ctx form (sym-sext (cg-syms ctx))))
            ((streq base-name (str-fptosi))      (codegen-conv ctx form (sym-fptosi (cg-syms ctx))))
            ((streq base-name (str-fptoui))      (codegen-conv ctx form (sym-fptoui (cg-syms ctx))))
            ((streq base-name (str-sitofp))      (codegen-conv ctx form (sym-sitofp (cg-syms ctx))))
            ((streq base-name (str-uitofp))      (codegen-conv ctx form (sym-uitofp (cg-syms ctx))))
            ((streq base-name (str-fpext))       (codegen-conv ctx form (sym-fpext (cg-syms ctx))))
            ((streq base-name (str-fptrunc))     (codegen-conv ctx form (sym-fptrunc (cg-syms ctx))))
            ;; Builtin predicates
            ((streq base-name (str-nil?))        (codegen-nil? ctx form))
            ;; Struct operations
            ((streq base-name (str-defstruct))   (codegen-defstruct ctx form))
            ((streq base-name (str-defprotocol)) (codegen-defprotocol ctx form))
            ((streq base-name (str-extend-protocol)) (codegen-extend-protocol ctx form))
            ((streq base-name (str-extend-protocol-default)) (codegen-extend-protocol-default ctx form))
            ((streq base-name (str-share))       (codegen-share ctx form))
            ((streq base-name (str-instance?))   (codegen-instance? ctx form))
            ((streq base-name (str-dot))         (codegen-field-access ctx form))
            (else                      (codegen-call-or-struct ctx form))))
        (codegen-call ctx form))))

;; ============================================================
;; Binary Operations
;; ============================================================

(defun codegen-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

(defun codegen-cmp (ctx: ptr form: ptr pred: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-icmp syms pred left-v right-v))))

;; Float binary operations - same as codegen-binop but for float ops
(defun codegen-float-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

;; Type conversion operations - emit (op target-type value)
;; Form: (trunc i8 value) or (fptosi i64 value)
(defun codegen-conv (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((target-type (cadr form))    ;; e.g., i8, i64, double
        (value-form (caddr form))
        (value-result (codegen-expr ctx value-form))
        (ctx (pcons-head value-result))
        (value-v (pcons-tail value-result))
        (syms (cg-syms ctx)))
    ;; Emit: (op target-type value)
    (pcons ctx (scons op (scons target-type (scons value-v nil))))))

;; ============================================================
;; Builtin Predicates
;; ============================================================

;; nil? - check if a pointer is null
;; Form: (nil? expr)
;; Emits: (icmp eq arg (ptr null))
(defun codegen-nil? (ctx: ptr form: ptr) -> ptr
  (let ((arg-form (cadr form))
        (arg-result (codegen-expr ctx arg-form))
        (ctx (pcons-head arg-result))
        (arg-v (pcons-tail arg-result))
        (syms (cg-syms ctx)))
    ;; Emit: (icmp eq arg (ptr null))
    (pcons ctx (lir-icmp syms (sym-eq syms) arg-v (lir-null syms)))))

;; ============================================================
;; Struct Operations
;; ============================================================

;; Try to codegen as struct constructor, fall back to function call
(defun codegen-call-or-struct (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (struct-info (if (symbol? head) (cg-lookup-struct ctx head) nil)))
    (if (nil? struct-info)
        (codegen-call ctx form)
        (codegen-struct-constructor ctx form struct-info))))

;; Helper to count scons list length
(defun scons-length (lst: ptr) -> i64
  (scons-length-loop lst 0))

(defun scons-length-loop (lst: ptr acc: i64) -> i64
  (if (nil? lst)
      acc
      (scons-length-loop (cdr lst) (+ acc 1))))

;; Helper string for __type_id
(defun str-type-id () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95)   ;; __
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 121) ;; ty
        (store-byte (ptr+ b 4) 112) (store-byte (ptr+ b 5) 101) ;; pe
        (store-byte (ptr+ b 6) 95) (store-byte (ptr+ b 7) 105)  ;; _i
        (store-byte (ptr+ b 8) 100) (store-byte (ptr+ b 9) 0) b))) ;; d

;; Helper to build %struct.Name symbol
(defun make-struct-type-sym (syms: ptr name: ptr) -> ptr
  (let ((name-str (symbol-name name))
        (name-len (strlen name-str))
        (buf-len (+ 9 name-len))  ;; "%struct." + name + null
        (buf (heap-array buf-len)))
    (do
      (store-byte buf 37)           ;; %
      (store-byte (ptr+ buf 1) 115) ;; s
      (store-byte (ptr+ buf 2) 116) ;; t
      (store-byte (ptr+ buf 3) 114) ;; r
      (store-byte (ptr+ buf 4) 117) ;; u
      (store-byte (ptr+ buf 5) 99)  ;; c
      (store-byte (ptr+ buf 6) 116) ;; t
      (store-byte (ptr+ buf 7) 46)  ;; .
      (copy-str-loop buf 8 name-str 0 name-len)
      (store-byte (ptr+ buf (+ 8 name-len)) 0)
      (intern syms buf))))

;; Parse defstruct field types (x: i64 y: i64) -> (i64 i64)
(defun parse-struct-fields (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((colon (car rest))
                  (rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2)))
                    (parse-struct-fields rest3 (scons typ acc)))))))))

;; Build field list for struct registry: ((field-name . type) ...)
(defun build-field-info (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((colon (car rest))
                  (rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2)))
                    (build-field-info rest3 (scons (pcons name typ) acc)))))))))

;; Codegen for defstruct: (defstruct Name (x: i64 y: i64))
(defun codegen-defstruct (ctx: ptr form: ptr) -> ptr
  (let ((name (cadr form))
        (raw-fields (caddr form))
        (field-types (parse-struct-fields raw-fields nil))
        (field-info (build-field-info raw-fields nil))
        (syms (cg-syms ctx))
        ;; Prepend i64 for type_id field
        (all-types (scons (sym-i64 syms) field-types))
        ;; Build defstruct form
        (lir-def (scons (sym-defstruct syms) (scons name (scons all-types nil))))
        ;; Register struct with prepended __type_id field
        (type-id-field (pcons (intern syms (str-type-id)) (sym-i64 syms)))
        (all-fields (scons type-id-field field-info))
        (ctx (cg-register-struct ctx name all-fields))
        (ctx (cg-add-struct-def ctx lir-def)))
    (pcons ctx nil)))

;; Helper to codegen a list of args
(defun codegen-args-list (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx (reverse-scons acc))
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args-list ctx (cdr args) (scons v acc)))))

;; Codegen for share: (share (Point 10 20))
;; Emits: (heap-struct Point type-id arg1 arg2 ...)
(defun codegen-share (ctx: ptr form: ptr) -> ptr
  (let ((inner (cadr form)))
    (if (scons? inner)
        (let ((struct-name (car inner))
              (struct-info (cg-lookup-struct ctx struct-name)))
          (if (nil? struct-info)
              ;; Not a struct constructor - error
              (pcons ctx (box-int 0))
              (let ((args (cdr inner))
                    (type-id (struct-entry-type-id struct-info))
                    (syms (cg-syms ctx))
                    ;; Generate argument expressions
                    (args-result (codegen-args-list ctx args nil))
                    (ctx (pcons-head args-result))
                    (arg-vals (pcons-tail args-result))
                    ;; Prepend type-id to field values
                    (all-vals (scons (lir-int syms type-id) arg-vals)))
                (pcons ctx (scons (sym-heap-struct syms)
                                 (scons struct-name all-vals))))))
        (pcons ctx (box-int 0)))))

;; Find field index in struct fields list (0-indexed)
(defun find-field-index (fields: ptr field-name: ptr idx: i64) -> i64
  (if (nil? fields)
      -1
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            idx
            (find-field-index (cdr fields) field-name (+ idx 1))))))

;; Find field entry (name . type)
(defun find-field-entry (fields: ptr field-name: ptr) -> ptr
  (if (nil? fields)
      nil
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            entry
            (find-field-entry (cdr fields) field-name)))))

;; Find struct that has a given field
(defun find-struct-with-field (ctx: ptr field-name: ptr) -> ptr
  (find-struct-loop (cg-structs ctx) field-name))

(defun find-struct-loop (structs: ptr field-name: ptr) -> ptr
  (if (nil? structs)
      nil
      (let ((entry (car structs))
            (fields (struct-entry-fields entry)))
        (if (= 1 (struct-has-field? fields field-name))
            entry
            (find-struct-loop (cdr structs) field-name)))))

(defun struct-has-field? (fields: ptr field-name: ptr) -> i64
  (if (nil? fields)
      0
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            1
            (struct-has-field? (cdr fields) field-name)))))

;; Codegen for field access: (. obj field)
(defun codegen-field-access (ctx: ptr form: ptr) -> ptr
  (let ((obj-form (cadr form))
        (field-name (caddr form))
        (obj-result (codegen-expr ctx obj-form))
        (ctx (pcons-head obj-result))
        (obj-v (pcons-tail obj-result))
        (syms (cg-syms ctx))
        (struct-info (find-struct-with-field ctx field-name)))
    (if (nil? struct-info)
        (pcons ctx (lir-int syms -999))
        (codegen-field-access-found ctx obj-v field-name struct-info))))

(defun codegen-field-access-found (ctx: ptr obj-v: ptr field-name: ptr struct-info: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (struct-name (car struct-info))
        (fields (struct-entry-fields struct-info))
        (field-idx (find-field-index fields field-name 0))
        (field-entry (find-field-entry fields field-name)))
    (let ((field-ty (pcons-tail field-entry))
          (struct-ty (make-struct-type-sym syms struct-name)))
      ;; Emit: (load i64 (getelementptr inbounds %struct.X obj (i64 0) (i64 idx)))
      (pcons ctx (scons (sym-load syms)
                       (scons field-ty
                              (scons (scons (sym-getelementptr syms)
                                           (scons (sym-inbounds syms)
                                                  (scons struct-ty
                                                         (scons obj-v
                                                                (scons (lir-int syms 0)
                                                                       (scons (lir-int syms field-idx) nil))))))
                                     nil)))))))

;; Codegen for struct constructor: (Point 10 20)
(defun codegen-struct-constructor (ctx: ptr form: ptr struct-info: ptr) -> ptr
  (let ((name (car form))
        (args (cdr form))
        (fields (struct-entry-fields struct-info))
        (type-id (struct-entry-type-id struct-info))
        (num-fields (scons-length fields))
        (syms (cg-syms ctx))
        ;; Generate argument expressions
        (args-result (codegen-args-list ctx args nil))
        (ctx (pcons-head args-result))
        (arg-vals (pcons-tail args-result))
        (struct-ty (make-struct-type-sym syms name))
        (ptr-sym (sym-ptr syms))
        ;; Build the alloca + stores + ptr return expression
        (body (build-struct-stores syms struct-ty arg-vals type-id 1 nil)))
    ;; Wrap in let with alloca
    (pcons ctx (scons (sym-let syms)
                      (scons (scons (scons ptr-sym
                                          (scons (scons (sym-alloca syms)
                                                       (scons (sym-i64 syms)
                                                              (scons (lir-int syms num-fields) nil)))
                                                nil))
                                   nil)
                            (scons (scons (sym-store syms)
                                         (scons (lir-int syms type-id)
                                                (scons (make-gep-idx0 syms struct-ty ptr-sym 0) nil)))
                                   body))))))

;; Helper to generate GEP for field index 0,N
(defun make-gep-idx0 (syms: ptr struct-ty: ptr ptr-sym: ptr idx: i64) -> ptr
  (scons (sym-getelementptr syms)
         (scons (sym-inbounds syms)
                (scons struct-ty
                       (scons ptr-sym
                              (scons (lir-int syms 0)
                                     (scons (lir-int syms idx) nil)))))))

;; Build store expressions for struct fields
(defun build-struct-stores (syms: ptr struct-ty: ptr args: ptr type-id: i64 idx: i64 acc: ptr) -> ptr
  (if (nil? args)
      (reverse-scons (scons (sym-ptr syms) acc))
      (let ((arg (car args))
            (store-expr (scons (sym-store syms)
                              (scons arg
                                     (scons (make-gep-idx0 syms struct-ty (sym-ptr syms) idx) nil)))))
        (build-struct-stores syms struct-ty (cdr args) type-id (+ idx 1) (scons store-expr acc)))))

;; Codegen for instance?: (instance? obj Type)
(defun codegen-instance? (ctx: ptr form: ptr) -> ptr
  (let ((obj-form (cadr form))
        (type-name (caddr form))
        (struct-info (cg-lookup-struct ctx type-name)))
    (if (nil? struct-info)
        ;; Type not found - return false
        (pcons ctx (lir-int (cg-syms ctx) 0))
        ;; Generate runtime check
        (let ((obj-result (codegen-expr ctx obj-form))
              (ctx (pcons-head obj-result))
              (obj-v (pcons-tail obj-result))
              (type-id (struct-entry-type-id struct-info))
              (syms (cg-syms ctx)))
          ;; Emit: (icmp eq (load i64 (gep obj 0 0)) type-id)
          (pcons ctx (lir-icmp syms (sym-eq syms)
                              (scons (sym-load syms)
                                    (scons (sym-i64 syms)
                                           (scons (make-gep-idx0 syms (make-struct-type-sym syms type-name) obj-v 0) nil)))
                              (lir-int syms type-id)))))))

;; ============================================================
;; Protocols
;; ============================================================

;; Strip generic type args from protocol names (Seq<i64> -> Seq)
(defun find-char (s: ptr idx: i64 target: i64) -> i64
  (let ((c (load-byte (ptr+ s idx))))
    (if (= c 0)
        -1
        (if (= c target)
            idx
            (find-char s (+ idx 1) target)))))

(defun protocol-base (syms: ptr protocol: ptr) -> ptr
  (let ((name (symbol-name protocol))
        (len (strlen name))
        (idx (find-char (symbol-name protocol) 0 60)))  ;; '<'
    (if (< idx 0)
        (let ((buf (heap-array (+ len 1))))
          (do
            (copy-str-loop buf 0 name 0 len)
            (store-byte (ptr+ buf len) 0)
            (intern syms buf)))
        (let ((buf (heap-array (+ idx 1))))
          (do
            (copy-str-loop buf 0 name 0 idx)
            (store-byte (ptr+ buf idx) 0)
            (intern syms buf))))))

;; Check for ASCII alnum or underscore
(defun is-alnum-or-underscore? (b: i64) -> i64
  (if (and (>= b 48) (<= b 57))
      1
      (if (and (>= b 65) (<= b 90))
          1
          (if (and (>= b 97) (<= b 122))
              1
              (if (= b 95) 1 0)))))

;; Sanitize type-arg substring into an identifier-safe suffix
(defun sanitize-args-loop (src: ptr idx: i64 len: i64 dst: ptr out-idx: i64 last-us: i64) -> ptr
  (if (>= idx len)
      (pcons (box-int out-idx) (box-int last-us))
      (let ((b (load-byte (ptr+ src idx)))
            (use (if (= 1 (is-alnum-or-underscore? b)) b 95))
            (is-us (if (= use 95) 1 0))
            (skip (if (and (= is-us 1) (= last-us 1)) 1 0)))
        (if (= skip 1)
            (sanitize-args-loop src (+ idx 1) len dst out-idx last-us)
            (do
              (store-byte (ptr+ dst out-idx) use)
              (sanitize-args-loop src (+ idx 1) len dst (+ out-idx 1) is-us))))))

;; Mangle protocol name with generic args for stable symbol names
(defun protocol-mangled (syms: ptr protocol: ptr) -> ptr
  (let ((name (symbol-name protocol))
        (lt-check (find-char name 0 60)))  ;; '<'
    (if (< lt-check 0)
        (protocol-base syms protocol)
        (let ((base-len (find-char name 0 60))
              (args-start (+ (find-char name 0 60) 1))
              (gt (find-char name (+ (find-char name 0 60) 1) 62)))  ;; '>'
          (if (< gt 0)
              (protocol-base syms protocol)
              (let ((args-len (- gt args-start))
                    (buf (heap-array (+ (+ base-len 1) (+ args-len 1)))))
                (do
                  (copy-str-loop buf 0 name 0 base-len)
                  (store-byte (ptr+ buf base-len) 95) ;; _
                  (let ((result (sanitize-args-loop (ptr+ name args-start) 0 args-len buf (+ base-len 1) 1))
                        (out-idx (unbox-int (pcons-head result))))
                    (do
                      (store-byte (ptr+ buf out-idx) 0)
                      (intern syms buf))))))))))

(defun method-return-sym (lst: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((head (car lst)))
        (if (= 1 (is-arrow-sym? head))
            (car (cdr lst))
            (method-return-sym (cdr lst))))))

(defun method-return-type (syms: ptr method-form: ptr) -> ptr
  (let ((ret-sym (method-return-sym (cdr method-form))))
    (if (nil? ret-sym)
        nil
        (type-sym-to-lir syms ret-sym))))

(defun codegen-defprotocol-loop (ctx: ptr protocol: ptr methods: ptr) -> ptr
  (if (nil? methods)
      ctx
      (let ((method-form (car methods))
            (method-name (car method-form))
            (ret (method-return-type (cg-syms ctx) method-form))
            (ctx (cg-register-proto-method ctx method-name protocol ret)))
        (codegen-defprotocol-loop ctx protocol (cdr methods)))))

(defun codegen-defprotocol (ctx: ptr form: ptr) -> ptr
  (let ((protocol (protocol-base (cg-syms ctx) (cadr form)))
        (methods (cddr form))
        (ctx (codegen-defprotocol-loop ctx protocol methods)))
    (pcons ctx nil)))

;; Integer helpers (binary + only)
(defun add3 (a b c) -> i64
  (+ (+ a b) c))

(defun add4 (a b c d) -> i64
  (+ (+ (+ a b) c) d))

;; Build function name for protocol impl: __Protocol_Type__method
(defun make-method-fn-name (syms: ptr protocol: ptr type-name: ptr method: ptr) -> ptr
  (let ((pname (symbol-name protocol))
        (tname (symbol-name type-name))
        (mname (symbol-name method))
        (plen (strlen pname))
        (tlen (strlen tname))
        (mlen (strlen mname))
        (total (add4 plen tlen mlen 5))  ;; "__" + "_" + "__" = 5
        (buf (heap-array (+ total 1))))
    (do
      (store-byte buf 95) (store-byte (ptr+ buf 1) 95)  ;; __
      (copy-str-loop buf 2 pname 0 plen)
      (store-byte (ptr+ buf (+ 2 plen)) 95)             ;; _
      (copy-str-loop buf (add3 3 plen 0) tname 0 tlen)
      (store-byte (ptr+ buf (add3 3 plen tlen)) 95)        ;; _
      (store-byte (ptr+ buf (add3 4 plen tlen)) 95)        ;; _
      (copy-str-loop buf (add3 5 plen tlen) mname 0 mlen)
      (store-byte (ptr+ buf total) 0)
      (intern syms buf))))

;; Build function name for protocol default: __Target_Source__method
(defun make-default-fn-name (syms: ptr target: ptr source: ptr method: ptr) -> ptr
  (let ((tname (symbol-name target))
        (sname (symbol-name source))
        (mname (symbol-name method))
        (tlen (strlen tname))
        (slen (strlen sname))
        (mlen (strlen mname))
        (total (add4 tlen slen mlen 5))
        (buf (heap-array (+ total 1))))
    (do
      (store-byte buf 95) (store-byte (ptr+ buf 1) 95)
      (copy-str-loop buf 2 tname 0 tlen)
      (store-byte (ptr+ buf (+ 2 tlen)) 95)
      (copy-str-loop buf (add3 3 tlen 0) sname 0 slen)
      (store-byte (ptr+ buf (add3 3 tlen slen)) 95)
      (store-byte (ptr+ buf (add3 4 tlen slen)) 95)
      (copy-str-loop buf (add3 5 tlen slen) mname 0 mlen)
      (store-byte (ptr+ buf total) 0)
      (intern syms buf))))

;; Build protocol method params list (self -> ptr, others -> i64)
(defun build-proto-params (syms: ptr params: ptr acc: ptr) -> ptr
  (if (nil? params)
      (reverse-scons acc)
      (let ((param (car params))
            (name (if (symbol? param) param param))
            (ty (if (= 1 (symbol-name-match? param (str-self)))
                    (sym-ptr syms)
                    (sym-i64 syms)))
            (pair (scons ty (scons name nil))))
        (build-proto-params syms (cdr params) (scons pair acc)))))

(defun build-param-type-list (syms: ptr params: ptr acc: ptr) -> ptr
  (if (nil? params)
      (reverse-pcons acc)
      (let ((param (car params))
            (name (if (symbol? param) param param))
            (ty (if (= 1 (symbol-name-match? param (str-self)))
                    (sym-ptr syms)
                    (sym-i64 syms))))
        (build-param-type-list syms (cdr params) (pcons (pcons name ty) acc)))))

(defun param-type-lookup (lst: ptr sym: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (pcons-head lst)))
        (if (= 1 (sym-eq? (pcons-head entry) sym))
            (pcons-tail entry)
            (param-type-lookup (pcons-tail lst) sym)))))

(defun normalize-param-list (params: ptr) -> ptr
  (if (symbol? params)
      (if (= 1 (symbol-name-match? params (str-nil)))
          nil
          params)
      params))

(defun lir-expr-ret-type-with-params (ctx: ptr expr: ptr param-types: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    (cond
      ((symbol? expr)
       (let ((ty (param-type-lookup param-types expr)))
         (if (nil? ty) (sym-i64 syms) ty)))
      ((scons? expr)
       (let ((head (car expr)))
         (if (= 1 (sym-eq? head (sym-let syms)))
             (lir-expr-ret-type-with-params ctx (caddr expr) param-types)
             (lir-expr-ret-type ctx expr))))
      (else (lir-expr-ret-type ctx expr)))))

(defun protocol-method-ret-type (ret-ty: ptr inferred: ptr) -> ptr
  (if (nil? ret-ty) inferred ret-ty))

(defun codegen-protocol-method (ctx: ptr fn-name: ptr params: ptr body: ptr ret-ty: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (lir-params (build-proto-params syms params nil))
        (param-types (build-param-type-list syms params nil))
        (fn-ctx (share (CodegenCtx 0 syms (cg-env ctx) nil 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                   (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                   (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        (inferred (lir-expr-ret-type-with-params ctx body-v param-types))
        (method-ret (protocol-method-ret-type ret-ty inferred))
        (fn-sig (scons fn-name (scons method-ret nil)))
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        (ctx (cg-add-fn-def ctx fn-name fn-def)))
    (pcons ctx (pcons fn-def inferred))))

(defun codegen-extend-protocol-loop (ctx: ptr protocol: ptr protocol-name: ptr type-name: ptr methods: ptr) -> ptr
  (if (nil? methods)
      ctx
      (let ((method-form (car methods))
            (method-name (car method-form))
            (params (cadr method-form))
            (body (caddr method-form))
            (fn-name (make-method-fn-name (cg-syms ctx) protocol-name type-name method-name))
            (entry (proto-methods-find (cg-proto-methods ctx) method-name protocol))
            (ret-ty (if (nil? entry) nil (proto-method-ret entry)))
            (result (codegen-protocol-method ctx fn-name params body ret-ty))
            (ctx (pcons-head result))
            (info (pcons-tail result))
            (inferred (pcons-tail info))
            (ctx (if (and (nil? ret-ty) (not (nil? inferred)))
                     (cg-update-proto-method-ret ctx method-name protocol inferred)
                     ctx))
            (ctx (cg-register-proto-impl ctx protocol type-name method-name fn-name)))
        (codegen-extend-protocol-loop ctx protocol protocol-name type-name (cdr methods)))))

(defun codegen-extend-protocol (ctx: ptr form: ptr) -> ptr
  (let ((protocol (protocol-base (cg-syms ctx) (cadr form)))
        (protocol-name (protocol-mangled (cg-syms ctx) (cadr form)))
        (type-name (caddr form))
        (methods (cdddr form))
        (ctx (cg-add-type-protocol ctx type-name protocol-name))
        (ctx (codegen-extend-protocol-loop ctx protocol protocol-name type-name methods)))
    (pcons ctx nil)))

(defun codegen-extend-protocol-default-loop (ctx: ptr target: ptr target-name: ptr source-name: ptr methods: ptr) -> ptr
  (if (nil? methods)
      ctx
      (let ((method-form (car methods))
            (method-name (car method-form))
            (params (cadr method-form))
            (body (caddr method-form))
            (fn-name (make-default-fn-name (cg-syms ctx) target-name source-name method-name))
            (entry (proto-methods-find (cg-proto-methods ctx) method-name target))
            (ret-ty (if (nil? entry) nil (proto-method-ret entry)))
            (result (codegen-protocol-method ctx fn-name params body ret-ty))
            (ctx (pcons-head result))
            (info (pcons-tail result))
            (inferred (pcons-tail info))
            (ctx (if (and (nil? ret-ty) (not (nil? inferred)))
                     (cg-update-proto-method-ret ctx method-name target inferred)
                     ctx))
            (ctx (cg-register-proto-default ctx target source-name method-name fn-name)))
        (codegen-extend-protocol-default-loop ctx target target-name source-name (cdr methods)))))

(defun codegen-extend-protocol-default (ctx: ptr form: ptr) -> ptr
  (let ((target (protocol-base (cg-syms ctx) (cadr form)))
        (target-name (protocol-mangled (cg-syms ctx) (cadr form)))
        (source-name (protocol-mangled (cg-syms ctx) (caddr form)))
        (methods (cdddr form))
        (ctx (codegen-extend-protocol-default-loop ctx target target-name source-name methods)))
    (pcons ctx nil)))

;; Protocol dispatch helpers
(defun find-protocol-for-method (entries: ptr method: ptr) -> ptr
  (if (nil? entries)
      nil
      (let ((entry (pcons-head entries)))
        (if (= 1 (sym-eq? (proto-method-name entry) method))
            (proto-method-protocol entry)
            (find-protocol-for-method (pcons-tail entries) method)))))

(defun dispatch-entry (type-id: i64 fn-name: ptr) -> ptr
  (pcons (box-int type-id) fn-name))

(defun dispatch-entry-type-id (entry: ptr) -> i64
  (unbox-int (pcons-head entry)))

(defun dispatch-entry-fn (entry: ptr) -> ptr
  (pcons-tail entry))

(defun type-has-direct-impl? (ctx: ptr protocol: ptr method: ptr type-name: ptr) -> i64
  (type-has-direct-impl-loop (cg-proto-impls ctx) protocol method type-name))

(defun type-has-direct-impl-loop (entries: ptr protocol: ptr method: ptr type-name: ptr) -> i64
  (if (nil? entries)
      0
      (let ((entry (pcons-head entries)))
        (if (and (= 1 (sym-eq? (proto-impl-protocol entry) protocol))
                 (and (= 1 (sym-eq? (proto-impl-method entry) method))
                      (= 1 (sym-eq? (proto-impl-type entry) type-name))))
            1
            (type-has-direct-impl-loop (pcons-tail entries) protocol method type-name)))))

(defun collect-direct-impls (ctx: ptr protocol: ptr method: ptr entries: ptr acc: ptr) -> ptr
  (if (nil? entries)
      (reverse-pcons acc)
      (let ((entry (pcons-head entries)))
        (if (and (= 1 (sym-eq? (proto-impl-protocol entry) protocol))
                 (= 1 (sym-eq? (proto-impl-method entry) method)))
            (let ((type-name (proto-impl-type entry))
                  (struct-info (cg-lookup-struct ctx type-name)))
              (if (nil? struct-info)
                  (collect-direct-impls ctx protocol method (pcons-tail entries) acc)
                  (let ((type-id (struct-entry-type-id struct-info))
                        (dispatch (dispatch-entry type-id (proto-impl-fn entry))))
                    (collect-direct-impls ctx protocol method (pcons-tail entries) (pcons dispatch acc)))))
            (collect-direct-impls ctx protocol method (pcons-tail entries) acc)))))

(defun collect-default-for-source (ctx: ptr protocol: ptr method: ptr source: ptr fn-name: ptr entries: ptr acc: ptr) -> ptr
  (if (nil? entries)
      acc
      (let ((entry (pcons-head entries))
            (type-name (type-proto-name entry))
            (protocols (type-proto-list entry)))
        (if (and (= 1 (proto-list-has? protocols source))
                 (= 0 (type-has-direct-impl? ctx protocol method type-name)))
            (let ((struct-info (cg-lookup-struct ctx type-name)))
              (if (nil? struct-info)
                  (collect-default-for-source ctx protocol method source fn-name (pcons-tail entries) acc)
                  (let ((type-id (struct-entry-type-id struct-info))
                        (dispatch (dispatch-entry type-id fn-name)))
                    (collect-default-for-source ctx protocol method source fn-name (pcons-tail entries) (pcons dispatch acc)))))
            (collect-default-for-source ctx protocol method source fn-name (pcons-tail entries) acc)))))

(defun collect-default-impls (ctx: ptr protocol: ptr method: ptr defaults: ptr acc: ptr) -> ptr
  (if (nil? defaults)
      (reverse-pcons acc)
      (let ((entry (pcons-head defaults)))
        (if (and (= 1 (sym-eq? (proto-default-target entry) protocol))
                 (= 1 (sym-eq? (proto-default-method entry) method)))
            (let ((source (proto-default-source entry))
                  (fn-name (proto-default-fn entry))
                  (acc (collect-default-for-source ctx protocol method source fn-name (cg-type-protocols ctx) acc)))
              (collect-default-impls ctx protocol method (pcons-tail defaults) acc))
            (collect-default-impls ctx protocol method (pcons-tail defaults) acc)))))

(defun build-protocol-dispatch (ctx: ptr entries: ptr type-id-v: ptr args: ptr ret-ty: ptr default-expr: ptr) -> ptr
  (if (nil? entries)
      (pcons ctx default-expr)
      (let ((entry (pcons-head entries))
            (rest (pcons-tail entries))
            (syms (cg-syms ctx))
            (type-id (dispatch-entry-type-id entry))
            (fn-name (dispatch-entry-fn entry))
            (cond-v (lir-icmp syms (sym-eq syms) type-id-v (lir-int syms type-id)))
            (then-v (lir-call syms fn-name args))
            (else-result (build-protocol-dispatch ctx rest type-id-v args ret-ty default-expr))
            (ctx (pcons-head else-result))
            (else-v (pcons-tail else-result)))
        (pcons ctx (lir-select syms cond-v then-v else-v)))))

(defun codegen-protocol-call (ctx: ptr method: ptr args: ptr protocol: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (self-form (car args))
        (rest-args (cdr args))
        (self-result (codegen-expr ctx self-form))
        (ctx (pcons-head self-result))
        (self-v (pcons-tail self-result))
        (args-result (codegen-args-list ctx rest-args nil))
        (ctx (pcons-head args-result))
        (rest-v (pcons-tail args-result))
        (args-v (scons self-v rest-v))
        (type-id-v (lir-load syms (sym-i64 syms) self-v))
        (direct (collect-direct-impls ctx protocol method (cg-proto-impls ctx) nil))
        (defaults (collect-default-impls ctx protocol method (cg-proto-defaults ctx) nil))
        (entries (append-pcons direct defaults))
        (entry (proto-methods-find (cg-proto-methods ctx) method protocol))
        (ret-ty (if (nil? entry)
                    (sym-i64 syms)
                    (let ((ret (proto-method-ret entry)))
                      (if (nil? ret) (sym-i64 syms) ret)))))
    (if (= 1 (sym-eq? ret-ty (sym-ptr syms)))
        (build-protocol-dispatch ctx entries type-id-v args-v ret-ty (lir-null syms))
        (build-protocol-dispatch ctx entries type-id-v args-v ret-ty (lir-int syms 0)))))

;; Indirect calls for closure values (assume ptr return for now)
(defun codegen-indirect-call (ctx: ptr fn-sym: ptr args: ptr) -> ptr
  (let ((args-result (codegen-args ctx args nil))
        (ctx (pcons-head args-result))
        (args-rev (pcons-tail args-result))
        (args-v (reverse-scons args-rev))
        (syms (cg-syms ctx))
        (ret-ty (sym-ptr syms)))
    (pcons ctx (lir-indirect-call syms fn-sym ret-ty args-v))))

(defun codegen-indirect-call-expr (ctx: ptr fn-expr: ptr args: ptr) -> ptr
  (let ((fn-result (codegen-expr ctx fn-expr))
        (ctx (pcons-head fn-result))
        (fn-v (pcons-tail fn-result)))
    (codegen-indirect-call ctx fn-v args)))

;; ============================================================
;; If Expression (with proper branching)
;; ============================================================

;; Infer a simple lIR return type (ptr or i64) from an expression
(defun lir-expr-ret-type (ctx: ptr expr: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    (cond
      ((nil? expr) (sym-i64 syms))
      ((boxed-int? expr) (sym-i64 syms))
      ((symbol? expr) (sym-i64 syms))  ;; unknown symbol defaults to i64
      ((scons? expr)
       (let ((head (car expr)))
         (cond
           ((sym-eq? head (sym-ptr syms)) (sym-ptr syms))
           ((sym-eq? head (sym-i1 syms)) (sym-i1 syms))
           ((sym-eq? head (sym-i64 syms)) (sym-i64 syms))
           ((sym-eq? head (sym-string syms)) (sym-ptr syms))
           ((sym-eq? head (sym-heap-struct syms)) (sym-ptr syms))
           ((sym-eq? head (sym-alloca syms)) (sym-ptr syms))
           ((sym-eq? head (sym-getelementptr syms)) (sym-ptr syms))
           ((sym-eq? head (sym-load syms)) (cadr expr))
           ((sym-eq? head (sym-indirect-call syms)) (caddr expr))
           ((sym-eq? head (sym-let syms)) (lir-expr-ret-type ctx (caddr expr)))
           (else (sym-i64 syms)))))
      (else (sym-i64 syms)))))

(defun lir-merge-type (ctx: ptr a: ptr b: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (ta (lir-expr-ret-type ctx a))
        (tb (lir-expr-ret-type ctx b)))
    (if (= 1 (sym-eq? ta (sym-ptr syms)))
        (sym-ptr syms)
        (if (= 1 (sym-eq? tb (sym-ptr syms)))
            (sym-ptr syms)
            (sym-i64 syms)))))

;; Emit if with explicit result type
(defun codegen-if-typed (ctx: ptr cond-v: ptr then-v: ptr else-v: ptr result-ty: ptr) -> ptr
  (let ((syms (cg-syms ctx))

        ;; Generate unique block labels
        (then-result (cg-fresh-label ctx (str-then-prefix)))
        (ctx (pcons-head then-result))
        (then-lbl (pcons-tail then-result))

        (else-result (cg-fresh-label ctx (str-else-prefix)))
        (ctx (pcons-head else-result))
        (else-lbl (pcons-tail else-result))

        (merge-result (cg-fresh-label ctx (str-merge-prefix)))
        (ctx (pcons-head merge-result))
        (merge-lbl (pcons-tail merge-result))

        ;; Build entry block: (block entry (br cond then else))
        (entry-block (lir-block syms (sym-entry syms)
                                (scons (lir-br-cond syms cond-v then-lbl else-lbl) nil)))

        ;; Build then block
        (then-block (lir-block syms then-lbl
                               (scons (lir-let1 syms then-lbl then-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Build else block
        (else-block (lir-block syms else-lbl
                               (scons (lir-let1 syms else-lbl else-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Add blocks to context (reverse order so they emit correctly)
        (ctx (cg-add-block ctx else-block))
        (ctx (cg-add-block ctx then-block))
        (ctx (cg-add-block ctx entry-block))

        ;; Set merge label for defun to use
        (ctx (cg-set-merge-label ctx merge-lbl))

        ;; Build phi expression in merge block
        (phi-expr (lir-phi syms result-ty then-lbl then-lbl else-lbl else-lbl)))

    (pcons ctx phi-expr)))

;; Emit proper control flow using br/phi for short-circuit evaluation
;; This enables recursion to work correctly (unlike select which evaluates both branches)
;;
;; For (if cond then else), we generate:
;;   (block entry (br cond-v then-label else-label))
;;   (block then-label (let ((then-var then-v)) (br merge-label)))
;;   (block else-label (let ((else-var else-v)) (br merge-label)))
;;   (block merge-label (ret (phi i64 (then-label then-var) (else-label else-var))))
;;
;; The then-var/else-var let bindings ensure values are computed in their blocks
;; before being referenced by phi in the merge block.

(defun codegen-if (ctx: ptr form: ptr) -> ptr
  (let ((cond-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head cond-result))
        (cond-v (pcons-tail cond-result))
        (then-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head then-result))
        (then-v (pcons-tail then-result))
        (else-result (codegen-expr ctx (cadddr form)))
        (ctx (pcons-head else-result))
        (else-v (pcons-tail else-result))
        (result-ty (lir-merge-type ctx then-v else-v)))
    (codegen-if-typed ctx cond-v then-v else-v result-ty)))

;; ============================================================
;; Let Bindings
;; ============================================================

(defun codegen-let-body (ctx: ptr bindings: ptr body: ptr) -> ptr
  (if (nil? bindings)
      (codegen-expr ctx body)
      (let ((binding (car bindings))
            (name (car binding))
            (val-form (cadr binding))
            (val-result (codegen-expr ctx val-form))
            (ctx (pcons-head val-result))
            (val-v (pcons-tail val-result))
            (rest-result (codegen-let-body ctx (cdr bindings) body))
            (ctx (pcons-head rest-result))
            (rest-v (pcons-tail rest-result))
            (syms (cg-syms ctx)))
        (pcons ctx (lir-let1 syms name val-v rest-v)))))

(defun codegen-let (ctx: ptr form: ptr) -> ptr
  (let ((bindings (cadr form))
        (body (caddr form)))
    (codegen-let-body ctx bindings body)))

;; ============================================================
;; Do Block
;; ============================================================

(defun codegen-do-loop (ctx: ptr exprs: ptr last-v: ptr) -> ptr
  (if (nil? exprs)
      (pcons ctx last-v)
      (let ((result (codegen-expr ctx (car exprs)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-do-loop ctx (cdr exprs) v))))

(defun codegen-do (ctx: ptr form: ptr) -> ptr
  (codegen-do-loop ctx (cdr form) (box-int 0)))

;; ============================================================
;; Function Call
;; ============================================================

(defun codegen-args (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx acc)
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args ctx (cdr args) (scons v acc)))))

(defun codegen-call (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (args (cdr form))
        (syms (cg-syms ctx)))
    (if (symbol? head)
        (let ((protocol (find-protocol-for-method (cg-proto-methods ctx) head)))
          (if (nil? protocol)
              (if (= 1 (fn-list-has? (cg-fn-names ctx) head))
                  (let ((args-result (codegen-args ctx args nil))
                        (ctx (pcons-head args-result))
                        (args-rev (pcons-tail args-result))
                        (args-v (reverse-scons args-rev)))
                    (pcons ctx (lir-call syms head args-v)))
                  (codegen-indirect-call ctx head args))
              (codegen-protocol-call ctx head args protocol)))
        (codegen-indirect-call-expr ctx head args))))

;; ============================================================
;; Function Definition
;; ============================================================

;; Get the nth element of a list (0-indexed)
(defun list-nth (lst: ptr n: i64) -> ptr
  (if (<= n 0)
      (car lst)
      (list-nth (cdr lst) (- n 1))))

;; Check if symbol is ->
(defun is-arrow-sym? (sym: ptr) -> i64
  (if (symbol? sym)
      (let ((name (symbol-name sym)))
        (if (= (load-byte name) 45)           ;; '-'
            (if (= (load-byte (ptr+ name 1)) 62) 1 0)
            0))
      0))

;; Check if element at index 3 is the arrow symbol ->
(defun has-return-type? (form: ptr) -> i64
  (let ((elem3 (list-nth form 3)))
    (is-arrow-sym? elem3)))

;; Map a type symbol to an lIR type symbol
(defun type-sym-to-lir (syms: ptr type-sym: ptr) -> ptr
  (if (nil? type-sym)
      (sym-i64 syms)
      (if (symbol? type-sym)
          (if (= 1 (sym-eq? type-sym (sym-ptr syms)))
              (sym-ptr syms)
              (if (= 1 (sym-eq? type-sym (sym-double syms)))
                  (sym-double syms)
                  (if (= 1 (sym-eq? type-sym (sym-i1 syms)))
                      (sym-i1 syms)
                      (sym-i64 syms))))
          (sym-i64 syms))))

;; Extract function body from defun form
(defun get-defun-body (form: ptr) -> ptr
  (if (= (has-return-type? form) 1)
      (list-nth form 5)
      (cadddr form)))

;; Extract return type symbol (defaults to i64)
(defun get-defun-return-type (syms: ptr form: ptr) -> ptr
  (if (= (has-return-type? form) 1)
      (type-sym-to-lir syms (list-nth form 4))
      (sym-i64 syms)))

;; Collect parameter names (handles typed and untyped params)
(defun collect-param-names (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-pcons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-pcons (pcons name acc))
            (let ((maybe-colon (car rest)))
              (if (= 1 (is-arrow-sym? maybe-colon))
                  (reverse-pcons (pcons name acc))
                  (if (= 1 (symbol-name-match? maybe-colon (str-colon)))
                      (collect-param-names (cdr (cdr rest)) (pcons name acc))
                      (collect-param-names rest (pcons name acc)))))))))

;; Check if param symbol is used in call position
(defun callable-has? (lst: ptr sym: ptr) -> i64
  (if (nil? lst)
      0
      (if (= 1 (sym-eq? (pcons-head lst) sym))
          1
          (callable-has? (pcons-tail lst) sym))))

(defun add-callable (lst: ptr sym: ptr) -> ptr
  (if (= 1 (callable-has? lst sym))
      lst
      (pcons sym lst)))

(defun find-callables-in-list (exprs: ptr params: ptr acc: ptr) -> ptr
  (if (nil? exprs)
      acc
      (let ((acc2 (find-callables-in-expr (car exprs) params acc)))
        (find-callables-in-list (cdr exprs) params acc2))))

(defun find-callables-in-expr (expr: ptr params: ptr acc: ptr) -> ptr
  (if (nil? expr)
      acc
      (if (scons? expr)
          (let ((head (car expr)))
            (let ((tail (cdr expr)))
              (if (symbol? head)
                  (if (= 1 (callable-has? params head))
                      (let ((acc2 (add-callable acc head)))
                        (let ((acc3 (find-callables-in-expr head params acc2)))
                          (find-callables-in-list tail params acc3)))
                      (let ((acc2 (find-callables-in-expr head params acc)))
                        (find-callables-in-list tail params acc2)))
                  (let ((acc2 (find-callables-in-expr head params acc)))
                    (find-callables-in-list tail params acc2)))))
          acc)))

(defun find-callable-params (params: ptr body: ptr) -> ptr
  (let ((param-names (collect-param-names params nil)))
    (find-callables-in-expr body param-names nil)))

;; Transform params from (name : type name : type) to ((type name) (type name))
;; Untyped params default to i64, or ptr when used in call position
(defun transform-params (syms: ptr lst: ptr acc: ptr callable: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      ;; lst is: name : type rest...
      (let ((name (car lst))
            (rest (cdr lst)))  ;; should be (: type rest...)
        (if (nil? rest)
            (let ((typ (if (= 1 (callable-has? callable name)) (sym-ptr syms) (sym-i64 syms)))
                  (pair (scons typ (scons name nil))))
              (reverse-scons (scons pair acc)))
            (let ((colon (car rest))
                  (rest2 (cdr rest)))  ;; should be (type rest...)
              (if (= 1 (symbol-name-match? colon (str-colon)))
                  (if (nil? rest2)
                      (reverse-scons acc)  ;; malformed
                      (let ((typ (car rest2))
                            (rest3 (cdr rest2))
                            (pair (scons typ (scons name nil))))
                        (transform-params syms rest3 (scons pair acc) callable)))
                  (let ((typ (if (= 1 (callable-has? callable name)) (sym-ptr syms) (sym-i64 syms)))
                        (pair (scons typ (scons name nil))))
                    (transform-params syms rest (scons pair acc) callable))))))))

;; Build the list of blocks for a function with branching
;; Blocks are already in correct order [entry, then, else], just append merge
(defun build-function-blocks (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (let ((merge-block (lir-block syms merge-lbl
                                (scons (lir-ret syms body-v) nil))))
    ;; Append merge block to the end
    (append-scons blocks (scons merge-block nil))))

;; Append two scons lists
(defun append-scons (lst1: ptr lst2: ptr) -> ptr
  (if (nil? lst1)
      lst2
      (scons (car lst1) (append-scons (cdr lst1) lst2))))

;; Helper to build function body based on whether there are blocks
(defun build-fn-body (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (if (nil? blocks)
      ;; No branching: simple single-block function
      (scons (scons (sym-block syms)
                    (scons (sym-entry syms)
                           (scons (lir-ret syms body-v) nil)))
             nil)
      ;; Has branching: use accumulated blocks + merge block
      (build-function-blocks syms blocks merge-lbl body-v)))

;; ============================================================
;; Lambda Helpers
;; ============================================================

(defun build-lambda-params (syms: ptr params: ptr acc: ptr) -> ptr
  (if (nil? params)
      (reverse-scons acc)
      (let ((param (car params))
            (pair (scons (sym-ptr syms) (scons param nil))))
        (build-lambda-params syms (cdr params) (scons pair acc)))))

(defun append-digit (buf: ptr idx n: i64) -> i64
  (do (store-byte (ptr+ buf idx) (+ 48 (rem n 10)))
      (+ idx 1)))

(defun int-to-buf-loop (buf: ptr idx n: i64) -> i64
  (if (< n 10)
      (append-digit buf idx n)
      (let ((idx2 (int-to-buf-loop buf idx (/ n 10))))
        (append-digit buf idx2 (rem n 10)))))

(defun gensym-lambda (syms: ptr counter: i64) -> ptr
  (let ((buf (heap-array 20)))
    (do
      ;; __lambda_
      (store-byte buf 95)           ;; _
      (store-byte (ptr+ buf 1) 95)  ;; _
      (store-byte (ptr+ buf 2) 108) ;; l
      (store-byte (ptr+ buf 3) 97)  ;; a
      (store-byte (ptr+ buf 4) 109) ;; m
      (store-byte (ptr+ buf 5) 98)  ;; b
      (store-byte (ptr+ buf 6) 100) ;; d
      (store-byte (ptr+ buf 7) 97)  ;; a
      (store-byte (ptr+ buf 8) 95)  ;; _
      (let ((end (int-to-buf-loop buf 9 counter)))
        (do (store-byte (ptr+ buf end) 0)
            (intern syms buf))))))

(defun cg-next-closure-name (ctx: ptr) -> ptr
  (let ((counter (cg-closure-counter ctx))
        (syms (cg-syms ctx))
        (name (gensym-lambda syms counter))
        (ctx (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                                (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                                (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                (cg-proto-defaults ctx) (cg-type-protocols ctx) (+ counter 1)))))
    (pcons ctx name)))

(defun codegen-defun (ctx: ptr form: ptr) -> ptr
  ;; (defun name (params) body) OR (defun name (params) -> type body)
  (let ((name (cadr form))
        (raw-params (normalize-param-list (caddr form)))
        (body (get-defun-body form))
        (callable (find-callable-params raw-params body))
        (lir-params (transform-params (cg-syms ctx) raw-params nil callable))
        (ret-ty (get-defun-return-type (cg-syms ctx) form))
        (syms (cg-syms ctx))
        ;; Reset temp and block counters for function body
        (fn-ctx (share (CodegenCtx 0 syms (cg-env ctx) nil 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                   (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                   (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        ;; Check if body generated any blocks (from if expressions)
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        ;; Build function signature: (name return-type)
        (fn-sig (scons name (scons ret-ty nil)))
        ;; Build function body - call helper to avoid if in let binding
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        ;; Build complete function definition
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        ;; Add function to context
        (ctx (cg-add-fn-def ctx name fn-def)))
    (pcons ctx fn-def)))

;; Lambda - stub for now
(defun codegen-fn (ctx: ptr form: ptr) -> ptr
  (let ((params (normalize-param-list (cadr form)))
        (body (caddr form))
        (name-result (cg-next-closure-name ctx))
        (ctx (pcons-head name-result))
        (fn-name (pcons-tail name-result))
        (syms (cg-syms ctx))
        (lir-params (build-lambda-params syms params nil))
        (fn-ctx (share (CodegenCtx 0 syms (cg-env ctx) nil 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                   (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                   (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-closure-counter ctx))))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        (fn-sig (scons fn-name (scons (sym-ptr syms) nil)))
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        (ctx (cg-add-fn-def ctx fn-name fn-def))
        (fn-ptr (prepend-at syms (symbol-name fn-name))))
    (pcons ctx fn-ptr)))

;; ============================================================
;; Top-Level
;; ============================================================

(defun codegen-toplevel (ctx: ptr forms: ptr) -> ptr
  (if (nil? forms)
      ctx
      (let ((result (codegen-expr ctx (car forms)))
            (ctx (pcons-head result)))
        (codegen-toplevel ctx (cdr forms)))))

(defun codegen-module (forms: ptr syms: ptr) -> ptr
  (let ((ctx (make-codegen-ctx syms))
        (ctx (codegen-toplevel ctx forms))
        (struct-defs (cg-struct-defs ctx))
        (fn-defs (cg-fns ctx)))
    ;; Combine struct defs and function defs
    (append-scons (reverse-scons struct-defs) fn-defs)))
