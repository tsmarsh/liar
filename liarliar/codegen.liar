;; codegen.liar - lIR code generation for liarliar
;;
;; Walks the AST (SCons trees from reader.liar) and emits lIR as SCons trees.
;; The lIR is then serialized by a printer.
;;
;; Per ADR 019: lIR is the universal backend - all liar code emits lIR.
;; Per ADR 024: Type-directed codegen uses inferred types for optimal output.
;;
;; Design: Build lIR as data (cons cells), then print. This is cleaner than
;; string building and allows lIR-level transformations before output.

(ns liarliar.codegen
  (:require [liar.core :refer :all]
            [liarliar.symbols :refer :all]
            [liarliar.value :refer :all]
            [liarliar.env :refer :all]))

;; ============================================================
;; Codegen Context
;; ============================================================

(defstruct CodegenCtx
  (cg-temp: i64        ;; Counter for unique temps (%0, %1, etc.)
   cg-syms: ptr        ;; SymbolTable for interning
   cg-env: ptr         ;; Current environment for name lookup
   cg-fns: ptr         ;; List of generated function definitions
   cg-block-counter: i64  ;; Counter for unique block labels
   cg-blocks: ptr      ;; List of accumulated blocks (for branching)
   cg-merge-label: ptr ;; Label for merge block (set by if)
   cg-structs: ptr     ;; NEW: List of struct definitions (unused)
   cg-type-id: i64     ;; NEW: Counter for type IDs (unused)
   cg-struct-defs: ptr ;; NEW: List of struct defs (unused)
   cg-fn-names: ptr    ;; List of known function symbols
   cg-proto-methods: ptr ;; List of protocol method entries
   cg-proto-impls: ptr ;; List of protocol impl entries
   cg-proto-defaults: ptr ;; List of protocol default entries
   cg-type-protocols: ptr ;; List of type -> protocol list entries
   cg-errors: i64      ;; Count of codegen errors
   cg-closure-counter: i64)) ;; Counter for generated lambda names

(defun make-codegen-ctx (syms: ptr) -> ptr
  (share (CodegenCtx 0 syms (make-global-env) nil 0 nil nil nil 1 nil nil nil nil nil nil 0 0)))

(defun cg-temp (ctx: ptr) -> i64 (. ctx cg-temp))
(defun cg-syms (ctx: ptr) -> ptr (. ctx cg-syms))
(defun cg-env (ctx: ptr) -> ptr (. ctx cg-env))
(defun cg-fns (ctx: ptr) -> ptr (. ctx cg-fns))
(defun cg-block-counter (ctx: ptr) -> i64 (. ctx cg-block-counter))
(defun cg-blocks (ctx: ptr) -> ptr (. ctx cg-blocks))
(defun cg-merge-label (ctx: ptr) -> ptr (. ctx cg-merge-label))
(defun cg-structs (ctx: ptr) -> ptr (. ctx cg-structs))
(defun cg-type-id (ctx: ptr) -> i64 (. ctx cg-type-id))
(defun cg-struct-defs (ctx: ptr) -> ptr (. ctx cg-struct-defs))
(defun cg-fn-names (ctx: ptr) -> ptr (. ctx cg-fn-names))
(defun cg-proto-methods (ctx: ptr) -> ptr (. ctx cg-proto-methods))
(defun cg-proto-impls (ctx: ptr) -> ptr (. ctx cg-proto-impls))
(defun cg-proto-defaults (ctx: ptr) -> ptr (. ctx cg-proto-defaults))
(defun cg-type-protocols (ctx: ptr) -> ptr (. ctx cg-type-protocols))
(defun cg-errors (ctx: ptr) -> i64 (. ctx cg-errors))
(defun cg-closure-counter (ctx: ptr) -> i64 (. ctx cg-closure-counter))

;; Replace the current compile-time environment.
(defun cg-set-env (ctx: ptr env: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) env (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Track local bindings for call-site resolution.
(defun env-define-pcons (env: ptr names: ptr) -> ptr
  (if (nil? names)
      env
      (do (env-define-sym! env (pcons-head names) 1)
          (env-define-pcons env (pcons-tail names)))))

(defun env-define-scons (env: ptr names: ptr) -> ptr
  (if (nil? names)
      env
      (do (env-define-sym! env (car names) 1)
          (env-define-scons env (cdr names)))))

(defun binding-names (binding: ptr) -> ptr
  (let ((name (car binding)))
    (if (scons? name)
        (cdr name)
        (scons name nil))))

;; Register a struct (returns updated context with new type_id)
;; Entry is stored as (name fields type_id) - a 3-element scons list
(defun cg-register-struct (ctx: ptr name: ptr fields: ptr) -> ptr
  (let ((type-id (cg-type-id ctx))
        (entry (scons name (scons fields (scons (box-int type-id) nil)))))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (scons entry (cg-structs ctx)) (+ type-id 1) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                       (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                       (cg-closure-counter ctx))))
  )

;; Add defstruct definition to list
(defun cg-add-struct-def (ctx: ptr sdef: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (scons sdef (cg-struct-defs ctx))
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Compare two interned symbols by their IDs
(defun sym-eq? (a: ptr b: ptr) -> i64
  (if (= (symbol-id a) (symbol-id b)) 1 0))

;; ============================================================
;; Function Registry
;; ============================================================

(defun fn-list-has? (lst: ptr name: ptr) -> i64
  (if (nil? lst)
      0
      (let ((entry (pcons-head lst)))
        (if (= 1 (streq (symbol-name entry) (symbol-name name)))
            1
            (fn-list-has? (pcons-tail lst) name)))))

(defun cg-add-fn-name (ctx: ptr name: ptr) -> ptr
  (if (= 1 (fn-list-has? (cg-fn-names ctx) name))
      ctx
      (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                         (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                         (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                         (pcons name (cg-fn-names ctx)) (cg-proto-methods ctx)
                         (cg-proto-impls ctx) (cg-proto-defaults ctx)
                         (cg-type-protocols ctx) (cg-errors ctx) (cg-closure-counter ctx)))))

;; Add function definition and register name
(defun cg-add-fn-def (ctx: ptr name: ptr fn-def: ptr) -> ptr
  (let ((ctx (cg-add-fn-name ctx name)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx)
                       (scons fn-def (cg-fns ctx))
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx)
                       (cg-proto-impls ctx) (cg-proto-defaults ctx)
                       (cg-type-protocols ctx) (cg-errors ctx) (cg-closure-counter ctx)))))

;; ============================================================
;; Protocol Metadata
;; ============================================================

;; Protocol method entry: (method protocol return-type)
(defun proto-method-entry (method: ptr protocol: ptr ret: ptr) -> ptr
  (pcons method (pcons protocol (pcons ret nil))))

(defun proto-method-name (entry: ptr) -> ptr
  (pcons-head entry))

(defun proto-method-protocol (entry: ptr) -> ptr
  (pcons-head (pcons-tail entry)))

(defun proto-method-ret (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail entry))))

(defun proto-methods-find (lst: ptr method: ptr protocol: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (pcons-head lst)))
        (if (and (= 1 (sym-eq? (proto-method-name entry) method))
                 (= 1 (sym-eq? (proto-method-protocol entry) protocol)))
            entry
            (proto-methods-find (pcons-tail lst) method protocol)))))

(defun cg-register-proto-method (ctx: ptr method: ptr protocol: ptr ret: ptr) -> ptr
  (let ((entry (proto-method-entry method protocol ret)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (pcons entry (cg-proto-methods ctx))
                       (cg-proto-impls ctx) (cg-proto-defaults ctx)
                       (cg-type-protocols ctx) (cg-errors ctx) (cg-closure-counter ctx)))))

(defun cg-update-proto-method-ret (ctx: ptr method: ptr protocol: ptr ret: ptr) -> ptr
  (let ((entries (cg-proto-methods ctx)))
    (cg-update-proto-method-ret-loop ctx entries nil method protocol ret)))

(defun cg-update-proto-method-ret-loop (ctx: ptr entries: ptr acc: ptr method: ptr protocol: ptr ret: ptr) -> ptr
  (if (nil? entries)
      (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                         (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                         (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                         (cg-fn-names ctx) (reverse-pcons acc)
                         (cg-proto-impls ctx) (cg-proto-defaults ctx)
                         (cg-type-protocols ctx) (cg-errors ctx) (cg-closure-counter ctx)))
      (let ((entry (pcons-head entries))
            (rest (pcons-tail entries)))
        (if (and (= 1 (sym-eq? (proto-method-name entry) method))
                 (= 1 (sym-eq? (proto-method-protocol entry) protocol)))
            (let ((new-entry (proto-method-entry method protocol ret)))
              (cg-update-proto-method-ret-loop ctx rest (pcons new-entry acc) method protocol ret))
            (cg-update-proto-method-ret-loop ctx rest (pcons entry acc) method protocol ret)))))

;; Protocol impl entry: (protocol type method fn-name)
(defun proto-impl-entry (protocol: ptr type-name: ptr method: ptr fn-name: ptr) -> ptr
  (pcons protocol (pcons type-name (pcons method (pcons fn-name nil)))))

(defun proto-impl-protocol (entry: ptr) -> ptr
  (pcons-head entry))

(defun proto-impl-type (entry: ptr) -> ptr
  (pcons-head (pcons-tail entry)))

(defun proto-impl-method (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail entry))))

(defun proto-impl-fn (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail (pcons-tail entry)))))

(defun cg-register-proto-impl (ctx: ptr protocol: ptr type-name: ptr method: ptr fn-name: ptr) -> ptr
  (let ((entry (proto-impl-entry protocol type-name method fn-name)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx)
                       (pcons entry (cg-proto-impls ctx)) (cg-proto-defaults ctx)
                       (cg-type-protocols ctx) (cg-errors ctx) (cg-closure-counter ctx)))))

;; Protocol default entry: (target protocol source protocol method fn-name)
(defun proto-default-entry (target: ptr source: ptr method: ptr fn-name: ptr) -> ptr
  (pcons target (pcons source (pcons method (pcons fn-name nil)))))

(defun proto-default-target (entry: ptr) -> ptr
  (pcons-head entry))

(defun proto-default-source (entry: ptr) -> ptr
  (pcons-head (pcons-tail entry)))

(defun proto-default-method (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail entry))))

(defun proto-default-fn (entry: ptr) -> ptr
  (pcons-head (pcons-tail (pcons-tail (pcons-tail entry)))))

(defun cg-register-proto-default (ctx: ptr target: ptr source: ptr method: ptr fn-name: ptr) -> ptr
  (let ((entry (proto-default-entry target source method fn-name)))
    (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                       (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                       (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                       (cg-fn-names ctx) (cg-proto-methods ctx)
                       (cg-proto-impls ctx) (pcons entry (cg-proto-defaults ctx))
                       (cg-type-protocols ctx) (cg-errors ctx) (cg-closure-counter ctx)))))

;; Type -> protocols entry: (type-name . protocol-list)
(defun type-proto-entry (type-name: ptr protocols: ptr) -> ptr
  (pcons type-name protocols))

(defun type-proto-name (entry: ptr) -> ptr
  (pcons-head entry))

(defun type-proto-list (entry: ptr) -> ptr
  (pcons-tail entry))

(defun proto-list-has? (lst: ptr protocol: ptr) -> i64
  (if (nil? lst)
      0
      (if (= 1 (sym-eq? (pcons-head lst) protocol))
          1
          (proto-list-has? (pcons-tail lst) protocol))))

(defun cg-add-type-protocol (ctx: ptr type-name: ptr protocol: ptr) -> ptr
  (cg-add-type-protocol-loop ctx (cg-type-protocols ctx) nil type-name protocol))

(defun cg-add-type-protocol-loop (ctx: ptr entries: ptr acc: ptr type-name: ptr protocol: ptr) -> ptr
  (if (nil? entries)
      (let ((new-entry (type-proto-entry type-name (pcons protocol nil))))
        (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                           (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                           (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                           (cg-fn-names ctx) (cg-proto-methods ctx)
                           (cg-proto-impls ctx) (cg-proto-defaults ctx)
                           (pcons new-entry (reverse-pcons acc)) (cg-errors ctx)
                           (cg-closure-counter ctx))))
      (let ((entry (pcons-head entries))
            (rest (pcons-tail entries)))
        (if (= 1 (sym-eq? (type-proto-name entry) type-name))
            (let ((protocols (type-proto-list entry))
                  (updated (if (= 1 (proto-list-has? protocols protocol))
                               protocols
                               (pcons protocol protocols)))
                  (new-entry (type-proto-entry type-name updated)))
              (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                                 (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                                 (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                 (cg-fn-names ctx) (cg-proto-methods ctx)
                                 (cg-proto-impls ctx) (cg-proto-defaults ctx)
                                 (append-pcons (reverse-pcons acc) (pcons new-entry rest))
                                 (cg-errors ctx) (cg-closure-counter ctx))))
            (cg-add-type-protocol-loop ctx rest (pcons entry acc) type-name protocol)))))

(defun find-type-protocols (entries: ptr type-name: ptr) -> ptr
  (if (nil? entries)
      nil
      (let ((entry (pcons-head entries)))
        (if (= 1 (sym-eq? (type-proto-name entry) type-name))
            (type-proto-list entry)
            (find-type-protocols (pcons-tail entries) type-name)))))

;; ============================================================
;; PCons Helpers
;; ============================================================

(defun reverse-pcons-acc (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      acc
      (reverse-pcons-acc (pcons-tail lst) (pcons (pcons-head lst) acc))))

(defun reverse-pcons (lst: ptr) -> ptr
  (reverse-pcons-acc lst nil))

(defun append-pcons (a: ptr b: ptr) -> ptr
  (if (nil? a)
      b
      (pcons (pcons-head a) (append-pcons (pcons-tail a) b))))

;; Lookup struct by name - returns entry (name fields type_id) scons list or nil
(defun cg-lookup-struct (ctx: ptr name: ptr) -> ptr
  (lookup-struct-loop (cg-structs ctx) name))

(defun lookup-struct-loop (lst: ptr name: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (car lst))
            (entry-name (car entry)))  ;; name is first element
        (if (= 1 (sym-eq? entry-name name))
            entry  ;; return full entry (name fields type_id)
            (lookup-struct-loop (cdr lst) name)))))

;; Helper to get fields from struct entry
(defun struct-entry-fields (entry: ptr) -> ptr
  (cadr entry))

;; Helper to get type_id from struct entry
(defun struct-entry-type-id (entry: ptr) -> i64
  (unbox-int (caddr entry)))

;; Get next temp and increment counter
(defun cg-next-temp (ctx: ptr) -> ptr
  (share (CodegenCtx (+ (cg-temp ctx) 1) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Update environment
(defun cg-with-env (ctx: ptr new-env: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) new-env (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Add function to list
(defun cg-add-fn (ctx: ptr fn-def: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx)
                     (scons fn-def (cg-fns ctx))
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Merge function definitions from a nested codegen context.
(defun cg-merge-fn-defs (ctx: ptr fns: ptr) -> ptr
  (if (nil? fns)
      ctx
      (cg-merge-fn-defs (cg-add-fn ctx (car fns)) (cdr fns))))

;; ============================================================
;; Block Management Helpers
;; ============================================================

;; Increment block counter and return updated context
(defun cg-inc-block-counter (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (+ (cg-block-counter ctx) 1) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Add a block to the accumulated blocks list
(defun cg-add-block (ctx: ptr block: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (scons block (cg-blocks ctx)) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Set the merge label for the if expression
(defun cg-set-merge-label (ctx: ptr label: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) label
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; Reset block state for new function
(defun cg-reset-blocks (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                     (cg-closure-counter ctx))))

;; ============================================================
;; Error Tracking
;; ============================================================

(defun cg-add-error (ctx: ptr) -> ptr
  (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                     (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                     (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                     (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                     (cg-proto-defaults ctx) (cg-type-protocols ctx)
                     (+ (cg-errors ctx) 1) (cg-closure-counter ctx))))

(defun cg-merge-errors (ctx: ptr other: ptr) -> ptr
  (if (= (cg-errors other) 0)
      ctx
      (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                         (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                         (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                         (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                         (cg-proto-defaults ctx) (cg-type-protocols ctx)
                         (+ (cg-errors ctx) (cg-errors other)) (cg-closure-counter ctx)))))

;; ============================================================
;; Symbol/String Helpers
;; ============================================================

;; Create a symbol from bytes (for lIR keywords)
;; Always allocate 9 bytes (8 chars + null), write all, null-terminate at len
(defun make-sym (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 len: i64) -> ptr
  (let ((buf (heap-array 9)))  ;; 8 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf len) 0)  ;; null terminate at len
      (intern syms buf))))

;; Helper for symbols up to 12 chars
(defun make-sym-long (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 len: i64) -> ptr
  (let ((buf (heap-array 13)))  ;; 12 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf len) 0)
      (intern syms buf))))

;; Helper for symbols of exactly 13 chars
(defun make-sym-13 (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12: i64) -> ptr
  (let ((buf (heap-array 14)))  ;; 13 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf 12) b12)
      (store-byte (ptr+ buf 13) 0)
      (intern syms buf))))

;; Helper for symbols of exactly 14 chars
(defun make-sym-14 (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13: i64) -> ptr
  (let ((buf (heap-array 15)))  ;; 14 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf 12) b12)
      (store-byte (ptr+ buf 13) b13)
      (store-byte (ptr+ buf 14) 0)
      (intern syms buf))))

;; Helper for symbols of exactly 15 chars
(defun make-sym-15 (syms: ptr b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14: i64) -> ptr
  (let ((buf (heap-array 16)))  ;; 15 + null
    (do
      (store-byte buf b0)
      (store-byte (ptr+ buf 1) b1)
      (store-byte (ptr+ buf 2) b2)
      (store-byte (ptr+ buf 3) b3)
      (store-byte (ptr+ buf 4) b4)
      (store-byte (ptr+ buf 5) b5)
      (store-byte (ptr+ buf 6) b6)
      (store-byte (ptr+ buf 7) b7)
      (store-byte (ptr+ buf 8) b8)
      (store-byte (ptr+ buf 9) b9)
      (store-byte (ptr+ buf 10) b10)
      (store-byte (ptr+ buf 11) b11)
      (store-byte (ptr+ buf 12) b12)
      (store-byte (ptr+ buf 13) b13)
      (store-byte (ptr+ buf 14) b14)
      (store-byte (ptr+ buf 15) 0)
      (intern syms buf))))


;; Common lIR symbols
(defun sym-i64 (s: ptr) -> ptr     (make-sym s 105 54 52 0 0 0 0 0 3))       ;; i64
(defun sym-i32 (s: ptr) -> ptr     (make-sym s 105 51 50 0 0 0 0 0 3))       ;; i32
(defun sym-i16 (s: ptr) -> ptr     (make-sym s 105 49 54 0 0 0 0 0 3))       ;; i16
(defun sym-i8 (s: ptr) -> ptr      (make-sym s 105 56 0 0 0 0 0 0 2))        ;; i8
(defun sym-i1 (s: ptr) -> ptr      (make-sym s 105 49 0 0 0 0 0 0 2))        ;; i1
(defun sym-ptr (s: ptr) -> ptr     (make-sym s 112 116 114 0 0 0 0 0 3))     ;; ptr
(defun sym-float (s: ptr) -> ptr   (make-sym s 102 108 111 97 116 0 0 0 5))  ;; float
(defun sym-double (s: ptr) -> ptr  (make-sym s 100 111 117 98 108 101 0 0 6)) ;; double
(defun sym-add (s: ptr) -> ptr     (make-sym s 97 100 100 0 0 0 0 0 3))      ;; add
(defun sym-sub (s: ptr) -> ptr     (make-sym s 115 117 98 0 0 0 0 0 3))      ;; sub
(defun sym-mul (s: ptr) -> ptr     (make-sym s 109 117 108 0 0 0 0 0 3))     ;; mul
(defun sym-sdiv (s: ptr) -> ptr    (make-sym s 115 100 105 118 0 0 0 0 4))   ;; sdiv
(defun sym-srem (s: ptr) -> ptr    (make-sym s 115 114 101 109 0 0 0 0 4))   ;; srem
(defun sym-icmp (s: ptr) -> ptr    (make-sym s 105 99 109 112 0 0 0 0 4))    ;; icmp
(defun sym-fcmp (s: ptr) -> ptr    (make-sym s 102 99 109 112 0 0 0 0 4))    ;; fcmp
(defun sym-eq (s: ptr) -> ptr      (make-sym s 101 113 0 0 0 0 0 0 2))       ;; eq
(defun sym-ne (s: ptr) -> ptr      (make-sym s 110 101 0 0 0 0 0 0 2))       ;; ne
(defun sym-slt (s: ptr) -> ptr     (make-sym s 115 108 116 0 0 0 0 0 3))     ;; slt
(defun sym-sgt (s: ptr) -> ptr     (make-sym s 115 103 116 0 0 0 0 0 3))     ;; sgt
(defun sym-sle (s: ptr) -> ptr     (make-sym s 115 108 101 0 0 0 0 0 3))     ;; sle
(defun sym-sge (s: ptr) -> ptr     (make-sym s 115 103 101 0 0 0 0 0 3))     ;; sge
(defun sym-oeq (s: ptr) -> ptr     (make-sym s 111 101 113 0 0 0 0 0 3))     ;; oeq
(defun sym-one (s: ptr) -> ptr     (make-sym s 111 110 101 0 0 0 0 0 3))     ;; one
(defun sym-olt (s: ptr) -> ptr     (make-sym s 111 108 116 0 0 0 0 0 3))     ;; olt
(defun sym-ogt (s: ptr) -> ptr     (make-sym s 111 103 116 0 0 0 0 0 3))     ;; ogt
(defun sym-ole (s: ptr) -> ptr     (make-sym s 111 108 101 0 0 0 0 0 3))     ;; ole
(defun sym-oge (s: ptr) -> ptr     (make-sym s 111 103 101 0 0 0 0 0 3))     ;; oge
(defun sym-select (s: ptr) -> ptr  (make-sym s 115 101 108 101 99 116 0 0 6)) ;; select
(defun sym-and (s: ptr) -> ptr     (make-sym s 97 110 100 0 0 0 0 0 3))      ;; and
(defun sym-or (s: ptr) -> ptr      (make-sym s 111 114 0 0 0 0 0 0 2))       ;; or
(defun sym-xor (s: ptr) -> ptr     (make-sym s 120 111 114 0 0 0 0 0 3))     ;; xor
(defun sym-shl (s: ptr) -> ptr     (make-sym s 115 104 108 0 0 0 0 0 3))     ;; shl
(defun sym-lshr (s: ptr) -> ptr    (make-sym s 108 115 104 114 0 0 0 0 4))   ;; lshr
(defun sym-ashr (s: ptr) -> ptr    (make-sym s 97 115 104 114 0 0 0 0 4))    ;; ashr
(defun sym-ctpop (s: ptr) -> ptr   (make-sym s 99 116 112 111 112 0 0 0 5))  ;; ctpop
(defun sym-call (s: ptr) -> ptr    (make-sym s 99 97 108 108 0 0 0 0 4))     ;; call
(defun sym-tailcall (s: ptr) -> ptr (make-sym s 116 97 105 108 99 97 108 108 8)) ;; tailcall
(defun sym-indirect-call (s: ptr) -> ptr
  (make-sym-13 s 105 110 100 105 114 101 99 116 45 99 97 108 108)) ;; indirect-call
(defun sym-indirect-tailcall (s: ptr) -> ptr
  (let ((buf (heap-array 18)))  ;; 17 + null
    (do
      (store-byte buf 105)      ;; i
      (store-byte (ptr+ buf 1) 110)  ;; n
      (store-byte (ptr+ buf 2) 100)  ;; d
      (store-byte (ptr+ buf 3) 105)  ;; i
      (store-byte (ptr+ buf 4) 114)  ;; r
      (store-byte (ptr+ buf 5) 101)  ;; e
      (store-byte (ptr+ buf 6) 99)   ;; c
      (store-byte (ptr+ buf 7) 116)  ;; t
      (store-byte (ptr+ buf 8) 45)   ;; -
      (store-byte (ptr+ buf 9) 116)  ;; t
      (store-byte (ptr+ buf 10) 97)  ;; a
      (store-byte (ptr+ buf 11) 105) ;; i
      (store-byte (ptr+ buf 12) 108) ;; l
      (store-byte (ptr+ buf 13) 99)  ;; c
      (store-byte (ptr+ buf 14) 97)  ;; a
      (store-byte (ptr+ buf 15) 108) ;; l
      (store-byte (ptr+ buf 16) 108) ;; l
      (store-byte (ptr+ buf 17) 0)
      (intern s buf)))) ;; indirect-tailcall
(defun sym-ret (s: ptr) -> ptr     (make-sym s 114 101 116 0 0 0 0 0 3))     ;; ret
(defun sym-declare (s: ptr) -> ptr (make-sym s 100 101 99 108 97 114 101 0 7)) ;; declare
(defun sym-define (s: ptr) -> ptr  (make-sym s 100 101 102 105 110 101 0 0 6)) ;; define
(defun sym-block (s: ptr) -> ptr   (make-sym s 98 108 111 99 107 0 0 0 5))   ;; block
(defun sym-entry (s: ptr) -> ptr   (make-sym s 101 110 116 114 121 0 0 0 5)) ;; entry
(defun sym-let (s: ptr) -> ptr     (make-sym s 108 101 116 0 0 0 0 0 3))     ;; let
(defun sym-string (s: ptr) -> ptr  (make-sym s 115 116 114 105 110 103 0 0 6)) ;; string
(defun sym-ellipsis (s: ptr) -> ptr (make-sym s 46 46 46 0 0 0 0 0 3))       ;; ...
(defun sym-br (s: ptr) -> ptr      (make-sym s 98 114 0 0 0 0 0 0 2))        ;; br
(defun sym-phi (s: ptr) -> ptr     (make-sym s 112 104 105 0 0 0 0 0 3))     ;; phi
(defun sym-array-alloc (s: ptr) -> ptr (make-sym-long s 97 114 114 97 121 45 97 108 108 111 99 0 11)) ;; array-alloc
(defun sym-array-get (s: ptr) -> ptr  (make-sym-long s 97 114 114 97 121 45 103 101 116 0 0 0 9))    ;; array-get
(defun sym-array-set (s: ptr) -> ptr  (make-sym-long s 97 114 114 97 121 45 115 101 116 0 0 0 9))    ;; array-set
(defun sym-array-len (s: ptr) -> ptr  (make-sym-long s 97 114 114 97 121 45 108 101 110 0 0 0 9))    ;; array-len
(defun sym-heap-array (s: ptr) -> ptr (make-sym-long s 104 101 97 112 45 97 114 114 97 121 0 0 10))   ;; heap-array
(defun sym-heap-array-dyn (s: ptr) -> ptr (make-sym-14 s 104 101 97 112 45 97 114 114 97 121 45 100 121 110)) ;; heap-array-dyn
(defun sym-array-copy (s: ptr) -> ptr (make-sym-long s 97 114 114 97 121 45 99 111 112 121 0 0 10))  ;; array-copy
(defun sym-ptr-array-alloc (s: ptr) -> ptr (make-sym-15 s 112 116 114 45 97 114 114 97 121 45 97 108 108 111 99)) ;; ptr-array-alloc
(defun sym-ptr-array-get (s: ptr) -> ptr (make-sym-13 s 112 116 114 45 97 114 114 97 121 45 103 101 116)) ;; ptr-array-get
(defun sym-ptr-array-set (s: ptr) -> ptr (make-sym-13 s 112 116 114 45 97 114 114 97 121 45 115 101 116)) ;; ptr-array-set

;; Float arithmetic lIR symbols
(defun sym-fadd (s: ptr) -> ptr    (make-sym s 102 97 100 100 0 0 0 0 4))    ;; fadd
(defun sym-fsub (s: ptr) -> ptr    (make-sym s 102 115 117 98 0 0 0 0 4))    ;; fsub
(defun sym-fmul (s: ptr) -> ptr    (make-sym s 102 109 117 108 0 0 0 0 4))   ;; fmul
(defun sym-fdiv (s: ptr) -> ptr    (make-sym s 102 100 105 118 0 0 0 0 4))   ;; fdiv
(defun sym-frem (s: ptr) -> ptr    (make-sym s 102 114 101 109 0 0 0 0 4))   ;; frem

;; Type conversion lIR symbols
(defun sym-trunc (s: ptr) -> ptr   (make-sym s 116 114 117 110 99 0 0 0 5))  ;; trunc
(defun sym-zext (s: ptr) -> ptr    (make-sym s 122 101 120 116 0 0 0 0 4))   ;; zext
(defun sym-sext (s: ptr) -> ptr    (make-sym s 115 101 120 116 0 0 0 0 4))   ;; sext
(defun sym-fptosi (s: ptr) -> ptr  (make-sym s 102 112 116 111 115 105 0 0 6)) ;; fptosi
(defun sym-fptoui (s: ptr) -> ptr  (make-sym s 102 112 116 111 117 105 0 0 6)) ;; fptoui
(defun sym-sitofp (s: ptr) -> ptr  (make-sym s 115 105 116 111 102 112 0 0 6)) ;; sitofp
(defun sym-uitofp (s: ptr) -> ptr  (make-sym s 117 105 116 111 102 112 0 0 6)) ;; uitofp
(defun sym-fpext (s: ptr) -> ptr   (make-sym s 102 112 101 120 116 0 0 0 5))  ;; fpext
(defun sym-fptrunc (s: ptr) -> ptr (make-sym s 102 112 116 114 117 110 99 0 7)) ;; fptrunc

;; Pointer and null
(defun sym-null (s: ptr) -> ptr    (make-sym s 110 117 108 108 0 0 0 0 4))     ;; null

;; Struct-related lIR symbols
(defun sym-defstruct (s: ptr) -> ptr   (make-sym-long s 100 101 102 115 116 114 117 99 116 0 0 0 9)) ;; defstruct
(defun sym-heap-struct (s: ptr) -> ptr (make-sym-long s 104 101 97 112 45 115 116 114 117 99 116 0 11)) ;; heap-struct
(defun sym-getelementptr (s: ptr) -> ptr (make-sym-13 s 103 101 116 101 108 101 109 101 110 116 112 116 114)) ;; getelementptr
(defun sym-load (s: ptr) -> ptr    (make-sym s 108 111 97 100 0 0 0 0 4))      ;; load
(defun sym-inbounds (s: ptr) -> ptr (make-sym s 105 110 98 111 117 110 100 115 8)) ;; inbounds
(defun sym-alloca (s: ptr) -> ptr  (make-sym s 97 108 108 111 99 97 0 0 6))    ;; alloca
(defun sym-store (s: ptr) -> ptr   (make-sym s 115 116 111 114 101 0 0 0 5))   ;; store
(defun sym-alloc (s: ptr) -> ptr   (make-sym s 97 108 108 111 99 0 0 0 5))    ;; alloc
(defun sym-own (s: ptr) -> ptr     (make-sym s 111 119 110 0 0 0 0 0 3))      ;; own
(defun sym-drop (s: ptr) -> ptr    (make-sym s 100 114 111 112 0 0 0 0 4))    ;; drop
(defun sym-move (s: ptr) -> ptr    (make-sym s 109 111 118 101 0 0 0 0 4))    ;; move
(defun sym-rc-alloc (s: ptr) -> ptr (make-sym s 114 99 45 97 108 108 111 99 8)) ;; rc-alloc
(defun sym-rc-clone (s: ptr) -> ptr (make-sym s 114 99 45 99 108 111 110 101 8)) ;; rc-clone
(defun sym-rc-drop (s: ptr) -> ptr  (make-sym s 114 99 45 100 114 111 112 0 7))  ;; rc-drop
(defun sym-printf (s: ptr) -> ptr  (make-sym s 112 114 105 110 116 102 0 0 6)) ;; printf

;; Liar special forms (for dispatch)
(defun str-if () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 102) (store-byte (ptr+ b 2) 0) b)))

(defun str-ns () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 0) b)))

(defun str-let () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 108) (store-byte (ptr+ b 1) 101)
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 0) b)))

(defun str-defun () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 117) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 0) b)))

(defun str-do () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 0) b)))

(defun str-fn () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 0) b)))

(defun str-tailcall () -> ptr
  (let ((b (heap-array 9)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 97) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 108) (store-byte (ptr+ b 4) 99) (store-byte (ptr+ b 5) 97)
        (store-byte (ptr+ b 6) 108) (store-byte (ptr+ b 7) 108)
        (store-byte (ptr+ b 8) 0) b)))

(defun str-indirect-tailcall () -> ptr
  (let ((b (heap-array 18)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 100)
        (store-byte (ptr+ b 3) 105) (store-byte (ptr+ b 4) 114) (store-byte (ptr+ b 5) 101)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 116)
        (store-byte (ptr+ b 8) 45)  ;; '-'
        (store-byte (ptr+ b 9) 116) (store-byte (ptr+ b 10) 97) (store-byte (ptr+ b 11) 105)
        (store-byte (ptr+ b 12) 108) (store-byte (ptr+ b 13) 99) (store-byte (ptr+ b 14) 97)
        (store-byte (ptr+ b 15) 108) (store-byte (ptr+ b 16) 108)
        (store-byte (ptr+ b 17) 0) b)))

(defun str-plus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 43) (store-byte (ptr+ b 1) 0) b)))

(defun str-minus () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 45) (store-byte (ptr+ b 1) 0) b)))

(defun str-star () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 42) (store-byte (ptr+ b 1) 0) b)))

(defun str-slash () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 47) (store-byte (ptr+ b 1) 0) b)))

(defun str-rem () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 109)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-eq () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 61) (store-byte (ptr+ b 1) 0) b)))

(defun str-lt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 60) (store-byte (ptr+ b 1) 0) b)))

(defun str-gt () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 62) (store-byte (ptr+ b 1) 0) b)))

(defun str-lte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 60) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-gte () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 62) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

;; Float operator strings (+., -., *., /., %.)
(defun str-plus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 43) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-minus-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 45) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-star-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 42) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-slash-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 47) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-percent-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 37) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

;; Named float operator strings (fadd, fsub, fmul, fdiv, frem)
(defun str-fadd () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 97) (store-byte (ptr+ b 2) 100)
        (store-byte (ptr+ b 3) 100) (store-byte (ptr+ b 4) 0) b)))

(defun str-fsub () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 98) (store-byte (ptr+ b 4) 0) b)))

(defun str-fmul () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 109) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 108) (store-byte (ptr+ b 4) 0) b)))

(defun str-fdiv () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 100) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 118) (store-byte (ptr+ b 4) 0) b)))

(defun str-frem () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 109) (store-byte (ptr+ b 4) 0) b)))

;; Type conversion operator strings
(defun str-trunc () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 117)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 99) (store-byte (ptr+ b 5) 0) b)))

(defun str-zext () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 122) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 120)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-sext () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 120)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-fptosi () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-fptoui () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 117) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-sitofp () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 102) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-uitofp () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 117) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 102) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-fpext () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 120) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 0) b)))

(defun str-fptrunc () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 112) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 117) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 0) b)))

;; Comparison operator strings
(defun str-eqeq () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 61) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-neq () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 33) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-eq-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 61) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-neq-dot () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 33) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 46)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-lt-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 60) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-gt-dot () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 62) (store-byte (ptr+ b 1) 46) (store-byte (ptr+ b 2) 0) b)))

(defun str-lte-dot () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 60) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 46)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-gte-dot () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 62) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 46)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-feq () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 61) (store-byte (ptr+ b 2) 0) b)))

(defun str-fneq () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 33) (store-byte (ptr+ b 2) 61)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-flt () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 60) (store-byte (ptr+ b 2) 0) b)))

(defun str-fgt () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 62) (store-byte (ptr+ b 2) 0) b)))

(defun str-flte () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 60) (store-byte (ptr+ b 2) 61)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-fgte () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 62) (store-byte (ptr+ b 2) 61)
        (store-byte (ptr+ b 3) 0) b)))

;; Boolean/bitwise operator strings
(defun str-not () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-and () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 100)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-or () -> ptr
  (let ((b (heap-array 3)))
    (do (store-byte b 111) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 0) b)))

(defun str-bit-and () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 98) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 45) (store-byte (ptr+ b 4) 97) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 100) (store-byte (ptr+ b 7) 0) b)))

(defun str-bit-or () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 98) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 45) (store-byte (ptr+ b 4) 111) (store-byte (ptr+ b 5) 114)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-bit-xor () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 98) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 45) (store-byte (ptr+ b 4) 120) (store-byte (ptr+ b 5) 111)
        (store-byte (ptr+ b 6) 114) (store-byte (ptr+ b 7) 0) b)))

(defun str-bit-not () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 98) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 45) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 111)
        (store-byte (ptr+ b 6) 116) (store-byte (ptr+ b 7) 0) b)))

(defun str-bit-shift-left () -> ptr
  (let ((b (heap-array 15)))
    (do (store-byte b 98) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 45) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 104)
        (store-byte (ptr+ b 6) 105) (store-byte (ptr+ b 7) 102) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 45) (store-byte (ptr+ b 10) 108) (store-byte (ptr+ b 11) 101)
        (store-byte (ptr+ b 12) 102) (store-byte (ptr+ b 13) 116) (store-byte (ptr+ b 14) 0) b)))

(defun str-bit-shift-right () -> ptr
  (let ((b (heap-array 16)))
    (do (store-byte b 98) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 45) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 104)
        (store-byte (ptr+ b 6) 105) (store-byte (ptr+ b 7) 102) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 45) (store-byte (ptr+ b 10) 114) (store-byte (ptr+ b 11) 105)
        (store-byte (ptr+ b 12) 103) (store-byte (ptr+ b 13) 104) (store-byte (ptr+ b 14) 116)
        (store-byte (ptr+ b 15) 0) b)))

(defun str-arithmetic-shift-right () -> ptr
  (let ((b (heap-array 23)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 104) (store-byte (ptr+ b 5) 109)
        (store-byte (ptr+ b 6) 101) (store-byte (ptr+ b 7) 116) (store-byte (ptr+ b 8) 105)
        (store-byte (ptr+ b 9) 99) (store-byte (ptr+ b 10) 45) (store-byte (ptr+ b 11) 115)
        (store-byte (ptr+ b 12) 104) (store-byte (ptr+ b 13) 105) (store-byte (ptr+ b 14) 102)
        (store-byte (ptr+ b 15) 116) (store-byte (ptr+ b 16) 45) (store-byte (ptr+ b 17) 114)
        (store-byte (ptr+ b 18) 105) (store-byte (ptr+ b 19) 103) (store-byte (ptr+ b 20) 104)
        (store-byte (ptr+ b 21) 116) (store-byte (ptr+ b 22) 0) b)))

(defun str-shl () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 108)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-shr () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-ashr () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 104)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 0) b)))

(defun str-popcount () -> ptr
  (let ((b (heap-array 9)))
    (do (store-byte b 112) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 112)
        (store-byte (ptr+ b 3) 99) (store-byte (ptr+ b 4) 111) (store-byte (ptr+ b 5) 117)
        (store-byte (ptr+ b 6) 110) (store-byte (ptr+ b 7) 116) (store-byte (ptr+ b 8) 0) b)))

;; Byte/pointer operator strings
(defun str-store-byte () -> ptr
  (let ((b (heap-array 11)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 116) (store-byte (ptr+ b 2) 111)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 45)
        (store-byte (ptr+ b 6) 98) (store-byte (ptr+ b 7) 121) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 101) (store-byte (ptr+ b 10) 0) b)))

(defun str-load-byte () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 108) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 97)
        (store-byte (ptr+ b 3) 100) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 98)
        (store-byte (ptr+ b 6) 121) (store-byte (ptr+ b 7) 116) (store-byte (ptr+ b 8) 101)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-ptr-plus () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 112) (store-byte (ptr+ b 1) 116) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 43) (store-byte (ptr+ b 4) 0) b)))

;; Array operator strings
(defun str-array () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 97) (store-byte (ptr+ b 4) 121) (store-byte (ptr+ b 5) 0) b)))

(defun str-make-array () -> ptr
  (let ((b (heap-array 11)))
    (do (store-byte b 109) (store-byte (ptr+ b 1) 97) (store-byte (ptr+ b 2) 107)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 97)
        (store-byte (ptr+ b 6) 114) (store-byte (ptr+ b 7) 114) (store-byte (ptr+ b 8) 97)
        (store-byte (ptr+ b 9) 121) (store-byte (ptr+ b 10) 0) b)))

(defun str-array-get () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 97) (store-byte (ptr+ b 4) 121) (store-byte (ptr+ b 5) 45)
        (store-byte (ptr+ b 6) 103) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-aget () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 103) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-array-set () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 97) (store-byte (ptr+ b 4) 121) (store-byte (ptr+ b 5) 45)
        (store-byte (ptr+ b 6) 115) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-aset () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 0) b)))

(defun str-array-len () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 97) (store-byte (ptr+ b 4) 121) (store-byte (ptr+ b 5) 45)
        (store-byte (ptr+ b 6) 108) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 110)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-alen () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 0) b)))

(defun str-heap-array () -> ptr
  (let ((b (heap-array 11)))
    (do (store-byte b 104) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 97)
        (store-byte (ptr+ b 3) 112) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 97)
        (store-byte (ptr+ b 6) 114) (store-byte (ptr+ b 7) 114) (store-byte (ptr+ b 8) 97)
        (store-byte (ptr+ b 9) 121) (store-byte (ptr+ b 10) 0) b)))

(defun str-heap-array-ptr () -> ptr
  (let ((b (heap-array 15)))
    (do (store-byte b 104) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 97)
        (store-byte (ptr+ b 3) 112) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 97)
        (store-byte (ptr+ b 6) 114) (store-byte (ptr+ b 7) 114) (store-byte (ptr+ b 8) 97)
        (store-byte (ptr+ b 9) 121) (store-byte (ptr+ b 10) 45) (store-byte (ptr+ b 11) 112)
        (store-byte (ptr+ b 12) 116) (store-byte (ptr+ b 13) 114) (store-byte (ptr+ b 14) 0) b)))

(defun str-aget-ptr () -> ptr
  (let ((b (heap-array 9)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 103) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 116) (store-byte (ptr+ b 7) 114) (store-byte (ptr+ b 8) 0) b)))

(defun str-aset-ptr () -> ptr
  (let ((b (heap-array 9)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 115) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 112)
        (store-byte (ptr+ b 6) 116) (store-byte (ptr+ b 7) 114) (store-byte (ptr+ b 8) 0) b)))

(defun str-array-copy () -> ptr
  (let ((b (heap-array 11)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 97) (store-byte (ptr+ b 4) 121) (store-byte (ptr+ b 5) 45)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 111) (store-byte (ptr+ b 8) 112)
        (store-byte (ptr+ b 9) 121) (store-byte (ptr+ b 10) 0) b)))

;; Ownership and I/O operator strings
(defun str-alloc () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 97) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 108)
        (store-byte (ptr+ b 3) 111) (store-byte (ptr+ b 4) 99) (store-byte (ptr+ b 5) 0) b)))

(defun str-drop () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 111)
        (store-byte (ptr+ b 3) 112) (store-byte (ptr+ b 4) 0) b)))

(defun str-move () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 109) (store-byte (ptr+ b 1) 111) (store-byte (ptr+ b 2) 118)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 0) b)))

(defun str-rc-new () -> ptr
  (let ((b (heap-array 7)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 99) (store-byte (ptr+ b 2) 45)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 119)
        (store-byte (ptr+ b 6) 0) b)))

(defun str-rc-clone () -> ptr
  (let ((b (heap-array 9)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 99) (store-byte (ptr+ b 2) 45)
        (store-byte (ptr+ b 3) 99) (store-byte (ptr+ b 4) 108) (store-byte (ptr+ b 5) 111)
        (store-byte (ptr+ b 6) 110) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 0) b)))

(defun str-rc-drop () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 114) (store-byte (ptr+ b 1) 99) (store-byte (ptr+ b 2) 45)
        (store-byte (ptr+ b 3) 100) (store-byte (ptr+ b 4) 114) (store-byte (ptr+ b 5) 111)
        (store-byte (ptr+ b 6) 112) (store-byte (ptr+ b 7) 0) b)))

(defun str-clone () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 99) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 111)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

(defun str-print () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 112) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 0) b)))

(defun str-println () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 112) (store-byte (ptr+ b 1) 114) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 108)
        (store-byte (ptr+ b 6) 110) (store-byte (ptr+ b 7) 0) b)))

;; LiarString helpers for printf format strings
(defun fmt-percent-s () -> ptr
  (let ((buf (heap-array 3)))
    (do (store-byte buf 37) (store-byte (ptr+ buf 1) 115) (store-byte (ptr+ buf 2) 0)
        (liar-string buf 2))))

(defun fmt-percent-ld () -> ptr
  (let ((buf (heap-array 4)))
    (do (store-byte buf 37) (store-byte (ptr+ buf 1) 108) (store-byte (ptr+ buf 2) 100)
        (store-byte (ptr+ buf 3) 0) (liar-string buf 3))))

(defun fmt-percent-s-nl () -> ptr
  (let ((buf (heap-array 4)))
    (do (store-byte buf 37) (store-byte (ptr+ buf 1) 115) (store-byte (ptr+ buf 2) 10)
        (store-byte (ptr+ buf 3) 0) (liar-string buf 3))))

(defun fmt-percent-ld-nl () -> ptr
  (let ((buf (heap-array 5)))
    (do (store-byte buf 37) (store-byte (ptr+ buf 1) 108) (store-byte (ptr+ buf 2) 100)
        (store-byte (ptr+ buf 3) 10) (store-byte (ptr+ buf 4) 0) (liar-string buf 4))))

;; Builtin operator strings
(defun str-nil? () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 105) (store-byte (ptr+ b 2) 108)
        (store-byte (ptr+ b 3) 63) (store-byte (ptr+ b 4) 0) b)))

(defun str-nil () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 110) (store-byte (ptr+ b 1) 105)
        (store-byte (ptr+ b 2) 108) (store-byte (ptr+ b 3) 0) b)))

(defun str-true () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 114)
        (store-byte (ptr+ b 2) 117) (store-byte (ptr+ b 3) 101)
        (store-byte (ptr+ b 4) 0) b)))

(defun str-false () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 102) (store-byte (ptr+ b 1) 97)
        (store-byte (ptr+ b 2) 108) (store-byte (ptr+ b 3) 115)
        (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

(defun str-colon () -> ptr
  (let ((b (heap-array 2)))
    (do (store-byte b 58) (store-byte (ptr+ b 1) 0) b)))

(defun str-self () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 101)
        (store-byte (ptr+ b 2) 108) (store-byte (ptr+ b 3) 102)
        (store-byte (ptr+ b 4) 0) b)))

(defun str-defstruct () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 115) (store-byte (ptr+ b 4) 116) (store-byte (ptr+ b 5) 114)
        (store-byte (ptr+ b 6) 117) (store-byte (ptr+ b 7) 99) (store-byte (ptr+ b 8) 116)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-defprotocol () -> ptr
  (let ((b (heap-array 12)))
    (do (store-byte b 100) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 102)
        (store-byte (ptr+ b 3) 112) (store-byte (ptr+ b 4) 114) (store-byte (ptr+ b 5) 111)
        (store-byte (ptr+ b 6) 116) (store-byte (ptr+ b 7) 111) (store-byte (ptr+ b 8) 99)
        (store-byte (ptr+ b 9) 111) (store-byte (ptr+ b 10) 108) (store-byte (ptr+ b 11) 0) b)))

(defun str-extend-protocol () -> ptr
  (let ((b (heap-array 16)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 120) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 100)
        (store-byte (ptr+ b 6) 45) (store-byte (ptr+ b 7) 112) (store-byte (ptr+ b 8) 114)
        (store-byte (ptr+ b 9) 111) (store-byte (ptr+ b 10) 116) (store-byte (ptr+ b 11) 111)
        (store-byte (ptr+ b 12) 99) (store-byte (ptr+ b 13) 111) (store-byte (ptr+ b 14) 108)
        (store-byte (ptr+ b 15) 0) b)))

(defun str-extend-protocol-default () -> ptr
  (let ((b (heap-array 24)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 120) (store-byte (ptr+ b 2) 116)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 110) (store-byte (ptr+ b 5) 100)
        (store-byte (ptr+ b 6) 45) (store-byte (ptr+ b 7) 112) (store-byte (ptr+ b 8) 114)
        (store-byte (ptr+ b 9) 111) (store-byte (ptr+ b 10) 116) (store-byte (ptr+ b 11) 111)
        (store-byte (ptr+ b 12) 99) (store-byte (ptr+ b 13) 111) (store-byte (ptr+ b 14) 108)
        (store-byte (ptr+ b 15) 45) (store-byte (ptr+ b 16) 100) (store-byte (ptr+ b 17) 101)
        (store-byte (ptr+ b 18) 102) (store-byte (ptr+ b 19) 97) (store-byte (ptr+ b 20) 117)
        (store-byte (ptr+ b 21) 108) (store-byte (ptr+ b 22) 116) (store-byte (ptr+ b 23) 0) b)))

(defun str-share () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 115) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 97)
        (store-byte (ptr+ b 3) 114) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

(defun str-instance? () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 105) (store-byte (ptr+ b 1) 110) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 116) (store-byte (ptr+ b 4) 97) (store-byte (ptr+ b 5) 110)
        (store-byte (ptr+ b 6) 99) (store-byte (ptr+ b 7) 101) (store-byte (ptr+ b 8) 63)
        (store-byte (ptr+ b 9) 0) b)))

(defun str-instance-check () -> ptr
  (let ((b (heap-array 17)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 116)
        (store-byte (ptr+ b 6) 97) (store-byte (ptr+ b 7) 110) (store-byte (ptr+ b 8) 99)
        (store-byte (ptr+ b 9) 101) (store-byte (ptr+ b 10) 95) (store-byte (ptr+ b 11) 99)
        (store-byte (ptr+ b 12) 104) (store-byte (ptr+ b 13) 101) (store-byte (ptr+ b 14) 99)
        (store-byte (ptr+ b 15) 107) (store-byte (ptr+ b 16) 0) b)))

(defun str-instance-obj () -> ptr
  (let ((b (heap-array 4)))
    (do (store-byte b 111) (store-byte (ptr+ b 1) 98) (store-byte (ptr+ b 2) 106)
        (store-byte (ptr+ b 3) 0) b)))

(defun str-instance-type-id () -> ptr
  (let ((b (heap-array 8)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 121) (store-byte (ptr+ b 2) 112)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 45) (store-byte (ptr+ b 5) 105)
        (store-byte (ptr+ b 6) 100) (store-byte (ptr+ b 7) 0) b)))

(defun str-instance-null () -> ptr
  (let ((b (heap-array 15)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 116)
        (store-byte (ptr+ b 6) 97) (store-byte (ptr+ b 7) 110) (store-byte (ptr+ b 8) 99)
        (store-byte (ptr+ b 9) 101) (store-byte (ptr+ b 10) 95) (store-byte (ptr+ b 11) 110)
        (store-byte (ptr+ b 12) 117) (store-byte (ptr+ b 13) 108) (store-byte (ptr+ b 14) 0) b)))

(defun str-instance-check-lbl () -> ptr
  (let ((b (heap-array 17)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95) (store-byte (ptr+ b 2) 105)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 115) (store-byte (ptr+ b 5) 116)
        (store-byte (ptr+ b 6) 97) (store-byte (ptr+ b 7) 110) (store-byte (ptr+ b 8) 99)
        (store-byte (ptr+ b 9) 101) (store-byte (ptr+ b 10) 95) (store-byte (ptr+ b 11) 99)
        (store-byte (ptr+ b 12) 104) (store-byte (ptr+ b 13) 101) (store-byte (ptr+ b 14) 99)
        (store-byte (ptr+ b 15) 107) (store-byte (ptr+ b 16) 0) b)))

(defun str-dot () -> ptr
  (let ((b (heap-array 2))) (do (store-byte b 46) (store-byte (ptr+ b 1) 0) b)))

;; ============================================================
;; AST Predicates
;; ============================================================

(defun ast-symbol? (form: ptr) (symbol? form))
(defun ast-int? (form: ptr) (boxed-int? form))
(defun ast-bool? (form: ptr) (boxed-bool? form))
(defun ast-float? (form: ptr) (boxed-float? form))
(defun ast-string? (form: ptr) (liar-string? form))
(defun ast-list? (form: ptr) (scons? form))

;; ============================================================
;; Symbol Helpers
;; ============================================================

;; Find last occurrence of a byte in a string, or -1 if not found
(defun find-last-char (s: ptr idx: i64 last: i64 target: i64) -> i64
  (let ((c (load-byte (ptr+ s idx))))
    (if (= c 0)
        last
        (if (= c target)
            (find-last-char s (+ idx 1) idx target)
            (find-last-char s (+ idx 1) last target)))))

;; Return the base name after the last '/' (for namespaced symbols)
(defun symbol-base-name (syms: ptr sym: ptr) -> ptr
  (let ((name (symbol-name sym))
        (len (strlen name))
        (slash (find-last-char name 0 -1 47)))
    (if (<= slash 0)
        name
        (let ((base-len (- len (+ slash 1)))
              (buf (heap-array (+ base-len 1))))
          (do
            (copy-str-loop buf 0 (ptr+ name (+ slash 1)) 0 base-len)
            (store-byte (ptr+ buf base-len) 0)
            buf)))))

;; Check if symbol name matches a string, returning i64 1/0
(defun symbol-name-match? (sym: ptr name: ptr) -> i64
  (if (symbol? sym)
      (if (streq (symbol-name sym) name) 1 0)
      0))

;; ============================================================
;; lIR Construction Helpers
;; ============================================================

;; Build: (i64 N)
(defun lir-int (syms: ptr val: i64) -> ptr
  (scons (sym-i64 syms) (scons (box-int val) nil)))

;; Build: (i1 N)
(defun lir-i1 (syms: ptr val: i64) -> ptr
  (scons (sym-i1 syms) (scons (box-int val) nil)))

;; Build: %N (temp reference as symbol)
(defun lir-temp (syms: ptr n: i64) -> ptr
  ;; Create %N symbol - for now just use the number as a boxed int marker
  ;; Real impl would create "%0", "%1" etc symbols
  (box-int n))

;; Build: (op left right)
(defun lir-binop (syms: ptr op: ptr left: ptr right: ptr) -> ptr
  (scons op (scons left (scons right nil))))

;; Build: (icmp pred left right)
(defun lir-icmp (syms: ptr pred: ptr left: ptr right: ptr) -> ptr
  (scons (sym-icmp syms) (scons pred (scons left (scons right nil)))))

(defun lir-fcmp (syms: ptr pred: ptr left: ptr right: ptr) -> ptr
  (scons (sym-fcmp syms) (scons pred (scons left (scons right nil)))))

;; Build: (select cond then else)
(defun lir-select (syms: ptr cond-v: ptr then-v: ptr else-v: ptr) -> ptr
  (scons (sym-select syms) (scons cond-v (scons then-v (scons else-v nil)))))

;; Build: (ptr null)
(defun lir-null (syms: ptr) -> ptr
  (scons (sym-ptr syms) (scons (sym-null syms) nil)))

;; Build: (ptr __env)
(defun lir-env-param (syms: ptr) -> ptr
  (scons (sym-ptr syms) (scons (intern syms (str-env)) nil)))

;; Build: (load type ptr)
(defun lir-load (syms: ptr ty: ptr ptr-expr: ptr) -> ptr
  (scons (sym-load syms) (scons ty (scons ptr-expr nil))))

;; Helper: prepend @ to a string and intern it as a symbol
(extern strlen i64 (ptr))

(defun prepend-at (syms: ptr name: ptr) -> ptr
  (let ((name-len (strlen name))
        (new-len (+ name-len 2))  ;; @ + name + null
        (buf (heap-array new-len)))
    (do
      (store-byte buf 64)  ;; '@' = 64
      (copy-str-loop buf 1 name 0 name-len)
      (store-byte (ptr+ buf (+ name-len 1)) 0)  ;; null terminator
      (intern syms buf))))

(defun copy-str-loop (dst: ptr dst-idx: i64 src: ptr src-idx: i64 len: i64) -> i64
  (if (>= src-idx len)
      0
      (do
        (store-byte (ptr+ dst dst-idx) (load-byte (ptr+ src src-idx)))
        (copy-str-loop dst (+ dst-idx 1) src (+ src-idx 1) len))))

;; Build: (call @fn args...)
(defun lir-call (syms: ptr fn-name: ptr args: ptr) -> ptr
  (let ((at-name (prepend-at syms (symbol-name fn-name))))
    (scons (sym-call syms) (scons at-name args))))

;; Build: (tailcall @fn args...)
(defun lir-tailcall (syms: ptr fn-name: ptr args: ptr) -> ptr
  (let ((at-name (prepend-at syms (symbol-name fn-name))))
    (scons (sym-tailcall syms) (scons at-name args))))

;; Build: (declare printf i32 (ptr ...))
(defun lir-declare-printf (syms: ptr) -> ptr
  (let ((params (scons (sym-ptr syms) (scons (sym-ellipsis syms) nil))))
    (scons (sym-declare syms)
           (scons (sym-printf syms) (scons (sym-i32 syms) (scons params nil))))))

;; Build: (indirect-call fn-ptr ret-type args...)
(defun lir-indirect-call (syms: ptr fn-ptr: ptr ret-ty: ptr args: ptr) -> ptr
  (scons (sym-indirect-call syms) (scons fn-ptr (scons ret-ty args))))

;; Build: (indirect-tailcall fn-ptr ret-type args...)
(defun lir-indirect-tailcall (syms: ptr fn-ptr: ptr ret-ty: ptr args: ptr) -> ptr
  (scons (sym-indirect-tailcall syms) (scons fn-ptr (scons ret-ty args))))

;; Build: (ret val)
(defun lir-ret (syms: ptr val: ptr) -> ptr
  (scons (sym-ret syms) (scons val nil)))

;; Build: (let ((name val)) body)
(defun lir-let1 (syms: ptr name: ptr val: ptr body: ptr) -> ptr
  (scons (sym-let syms)
         (scons (scons (scons name (scons val nil)) nil)
                (scons body nil))))

;; Build: (br label) - unconditional branch
(defun lir-br (syms: ptr label: ptr) -> ptr
  (scons (sym-br syms) (scons label nil)))

;; Build: (br cond then-label else-label) - conditional branch
(defun lir-br-cond (syms: ptr cond-v: ptr then-lbl: ptr else-lbl: ptr) -> ptr
  (scons (sym-br syms) (scons cond-v (scons then-lbl (scons else-lbl nil)))))

;; Build: (phi type (label val) (label val))
(defun lir-phi (syms: ptr ty: ptr lbl1: ptr val1: ptr lbl2: ptr val2: ptr) -> ptr
  (scons (sym-phi syms)
         (scons ty
                (scons (scons lbl1 (scons val1 nil))
                       (scons (scons lbl2 (scons val2 nil)) nil)))))

;; Build: (block label body...)
(defun lir-block (syms: ptr label: ptr body: ptr) -> ptr
  (scons (sym-block syms) (scons label body)))

;; ============================================================
;; Block Label Generation
;; ============================================================

;; Helper to write a digit to buffer
(defun write-digit (buf: ptr idx: i64 n: i64) -> i64
  (do (store-byte (ptr+ buf idx) (+ 48 n)) (+ idx 1)))

;; Write number to buffer, return new index
(defun write-number (buf: ptr idx: i64 n: i64) -> i64
  (if (< n 10)
      (write-digit buf idx n)
      (let ((idx2 (write-number buf idx (/ n 10))))
        (write-digit buf idx2 (- n (* (/ n 10) 10))))))

;; Generate fresh block label like "then.0", "else.1", "merge.2"
;; Returns (ctx . label-symbol)
(defun cg-fresh-label (ctx: ptr prefix: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (counter (cg-block-counter ctx))
        (prefix-len (strlen prefix))
        (buf (heap-array 20)))  ;; enough for prefix.NNNN
    (do
      ;; Copy prefix to buffer
      (copy-str-loop buf 0 prefix 0 prefix-len)
      ;; Add dot separator
      (store-byte (ptr+ buf prefix-len) 46)  ;; '.' = 46
      ;; Write the counter number
      (let ((end-idx (write-number buf (+ prefix-len 1) counter)))
        (do
          ;; Null terminate
          (store-byte (ptr+ buf end-idx) 0)
          ;; Intern as symbol and return with incremented counter
          (pcons (cg-inc-block-counter ctx) (intern syms buf)))))))

;; String constants for label prefixes
(defun str-then-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 116) (store-byte (ptr+ b 1) 104) (store-byte (ptr+ b 2) 101)
        (store-byte (ptr+ b 3) 110) (store-byte (ptr+ b 4) 0) b)))

(defun str-else-prefix () -> ptr
  (let ((b (heap-array 5)))
    (do (store-byte b 101) (store-byte (ptr+ b 1) 108) (store-byte (ptr+ b 2) 115)
        (store-byte (ptr+ b 3) 101) (store-byte (ptr+ b 4) 0) b)))

(defun str-merge-prefix () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 109) (store-byte (ptr+ b 1) 101) (store-byte (ptr+ b 2) 114)
        (store-byte (ptr+ b 3) 103) (store-byte (ptr+ b 4) 101) (store-byte (ptr+ b 5) 0) b)))

;; ============================================================
;; Expression Codegen
;; ============================================================

;; Returns (ctx . lir-expr)
(defun codegen-expr (ctx: ptr form: ptr) -> ptr
  (cond
    ((ast-int? form)    (codegen-int ctx form))
    ((ast-bool? form)   (codegen-bool ctx form))
    ((ast-float? form)  (codegen-float ctx form))
    ((ast-symbol? form) (codegen-symbol ctx form))
    ((ast-string? form) (codegen-string ctx form))
    ((ast-list? form)   (codegen-list ctx form))
    ((pcons? form)      (pcons ctx (box-int 0)))
    ((icons? form)      (pcons ctx (box-int 0)))
    ((nil? form)        (pcons ctx (box-int 0)))
    (else               (pcons ctx (box-int 0)))))

;; Promote call expressions to tailcall in tail position.
(defun promote-tailcall (syms: ptr expr: ptr) -> ptr
  (if (scons? expr)
      (let ((head (car expr)))
        (if (= 1 (sym-eq? head (sym-indirect-call syms)))
            (scons (sym-indirect-tailcall syms) (cdr expr))
            expr))
      expr))

;; Returns (ctx . lir-expr), treating the expression as tail position.
(defun codegen-expr-tail (ctx: ptr form: ptr) -> ptr
  (if (ast-list? form)
      (let ((head (car form)))
        (if (symbol? head)
            (let ((base-name (symbol-base-name (cg-syms ctx) head)))
              (cond
                ((streq base-name (str-do)) (codegen-do-tail ctx form))
                ((streq base-name (str-let)) (codegen-let-tail ctx form))
                (else
                  (let ((result (codegen-expr ctx form))
                        (ctx (pcons-head result))
                        (expr (pcons-tail result))
                        (expr (promote-tailcall (cg-syms ctx) expr)))
                    (pcons ctx expr)))))
            (let ((result (codegen-expr ctx form))
                  (ctx (pcons-head result))
                  (expr (pcons-tail result))
                  (expr (promote-tailcall (cg-syms ctx) expr)))
              (pcons ctx expr))))
      (codegen-expr ctx form)))

;; Integer literal: (i64 N)
(defun codegen-int (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (val (unbox-int form)))
    (pcons ctx (lir-int syms val))))

;; Boolean literal: (i1 0|1)
(defun codegen-bool (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (val (unbox-bool form)))
    (pcons ctx (lir-i1 syms val))))

;; Float literal: (double N.M)
;; BoxedFloat stores: int-part, frac-part, scale (10^digits in frac)
;; E.g., 3.14 => int=3, frac=14, scale=100
;; We emit (double ...) with the reconstructed float value
(defun codegen-float (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; Emit the BoxedFloat directly - the lIR printer will handle it
    (pcons ctx (scons (sym-double syms) (scons form nil)))))

;; Symbol reference - pass through for now
(defun codegen-symbol (ctx: ptr form: ptr) -> ptr
  (let ((name (symbol-name form))
        (syms (cg-syms ctx)))
    (if (streq name (str-nil))
        (pcons ctx (lir-null syms))
        (if (streq name (str-true))
            (pcons ctx (lir-i1 syms 1))
            (if (streq name (str-false))
                (pcons ctx (lir-i1 syms 0))
                (pcons ctx form))))))

;; String literal - emit (string "...")
(defun codegen-string (ctx: ptr form: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    ;; form is a LiarString - wrap it in (string ...)
    (pcons ctx (scons (sym-string syms) (scons form nil)))))

;; ============================================================
;; List Form Dispatch
;; ============================================================

(defun codegen-error (ctx: ptr msg: string) -> ptr
  (do (println msg) (pcons (cg-add-error ctx) (box-int 0))))

(defun codegen-list (ctx: ptr form: ptr) -> ptr
  (let ((head (car form)))
    (if (symbol? head)
        (let ((base-name (symbol-base-name (cg-syms ctx) head)))
          (cond
            ((streq base-name (str-if))     (codegen-if ctx form))
            ((streq base-name (str-let))    (codegen-let ctx form))
            ((streq base-name (str-defun))  (codegen-defun ctx form))
            ((streq base-name (str-do))     (codegen-do ctx form))
            ((streq base-name (str-fn))     (codegen-fn ctx form))
            ;; Namespace declaration - skip for now (no-op)
            ;; TODO: Implement proper :require handling
            ((streq base-name (str-ns))     (pcons ctx (box-int 0)))
            ;; Arithmetic operators
            ((streq base-name (str-plus))
             (if (= (scons-length form) 3)
                 (codegen-binop ctx form (sym-add (cg-syms ctx)))
                 (codegen-error ctx "Error: + requires exactly 2 arguments")))
            ((streq base-name (str-minus))
             (if (= (scons-length form) 3)
                 (codegen-binop ctx form (sym-sub (cg-syms ctx)))
                 (codegen-error ctx "Error: - requires exactly 2 arguments")))
            ((streq base-name (str-star))
             (if (= (scons-length form) 3)
                 (codegen-binop ctx form (sym-mul (cg-syms ctx)))
                 (codegen-error ctx "Error: * requires exactly 2 arguments")))
            ((streq base-name (str-slash))
             (if (= (scons-length form) 3)
                 (codegen-binop ctx form (sym-sdiv (cg-syms ctx)))
                 (codegen-error ctx "Error: / requires exactly 2 arguments")))
            ((streq base-name (str-rem))
             (if (= (scons-length form) 3)
                 (codegen-binop ctx form (sym-srem (cg-syms ctx)))
                 (codegen-error ctx "Error: rem requires exactly 2 arguments")))
            ;; Integer comparisons
            ((streq base-name (str-eq))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-eq (cg-syms ctx)))
                 (codegen-error ctx "Error: = requires exactly 2 arguments")))
            ((streq base-name (str-eqeq))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-eq (cg-syms ctx)))
                 (codegen-error ctx "Error: == requires exactly 2 arguments")))
            ((streq base-name (str-neq))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-ne (cg-syms ctx)))
                 (codegen-error ctx "Error: != requires exactly 2 arguments")))
            ((streq base-name (str-lt))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-slt (cg-syms ctx)))
                 (codegen-error ctx "Error: < requires exactly 2 arguments")))
            ((streq base-name (str-gt))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-sgt (cg-syms ctx)))
                 (codegen-error ctx "Error: > requires exactly 2 arguments")))
            ((streq base-name (str-lte))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-sle (cg-syms ctx)))
                 (codegen-error ctx "Error: <= requires exactly 2 arguments")))
            ((streq base-name (str-gte))
             (if (= (scons-length form) 3)
                 (codegen-cmp ctx form (sym-sge (cg-syms ctx)))
                 (codegen-error ctx "Error: >= requires exactly 2 arguments")))
            ;; Float comparisons
            ((streq base-name (str-eq-dot))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-oeq (cg-syms ctx)))
                 (codegen-error ctx "Error: =. requires exactly 2 arguments")))
            ((streq base-name (str-feq))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-oeq (cg-syms ctx)))
                 (codegen-error ctx "Error: f= requires exactly 2 arguments")))
            ((streq base-name (str-neq-dot))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-one (cg-syms ctx)))
                 (codegen-error ctx "Error: !=. requires exactly 2 arguments")))
            ((streq base-name (str-fneq))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-one (cg-syms ctx)))
                 (codegen-error ctx "Error: f!= requires exactly 2 arguments")))
            ((streq base-name (str-lt-dot))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-olt (cg-syms ctx)))
                 (codegen-error ctx "Error: <. requires exactly 2 arguments")))
            ((streq base-name (str-flt))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-olt (cg-syms ctx)))
                 (codegen-error ctx "Error: f< requires exactly 2 arguments")))
            ((streq base-name (str-gt-dot))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-ogt (cg-syms ctx)))
                 (codegen-error ctx "Error: >. requires exactly 2 arguments")))
            ((streq base-name (str-fgt))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-ogt (cg-syms ctx)))
                 (codegen-error ctx "Error: f> requires exactly 2 arguments")))
            ((streq base-name (str-lte-dot))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-ole (cg-syms ctx)))
                 (codegen-error ctx "Error: <=. requires exactly 2 arguments")))
            ((streq base-name (str-flte))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-ole (cg-syms ctx)))
                 (codegen-error ctx "Error: f<= requires exactly 2 arguments")))
            ((streq base-name (str-gte-dot))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-oge (cg-syms ctx)))
                 (codegen-error ctx "Error: >=. requires exactly 2 arguments")))
            ((streq base-name (str-fgte))
             (if (= (scons-length form) 3)
                 (codegen-fcmp ctx form (sym-oge (cg-syms ctx)))
                 (codegen-error ctx "Error: f>= requires exactly 2 arguments")))
            ;; Float arithmetic operators
            ((streq base-name (str-plus-dot))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fadd (cg-syms ctx)))
                 (codegen-error ctx "Error: +. requires exactly 2 arguments")))
            ((streq base-name (str-minus-dot))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fsub (cg-syms ctx)))
                 (codegen-error ctx "Error: -. requires exactly 2 arguments")))
            ((streq base-name (str-star-dot))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fmul (cg-syms ctx)))
                 (codegen-error ctx "Error: *. requires exactly 2 arguments")))
            ((streq base-name (str-slash-dot))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx)))
                 (codegen-error ctx "Error: /. requires exactly 2 arguments")))
            ((streq base-name (str-percent-dot))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-frem (cg-syms ctx)))
                 (codegen-error ctx "Error: %. requires exactly 2 arguments")))
            ((streq base-name (str-fadd))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fadd (cg-syms ctx)))
                 (codegen-error ctx "Error: fadd requires exactly 2 arguments")))
            ((streq base-name (str-fsub))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fsub (cg-syms ctx)))
                 (codegen-error ctx "Error: fsub requires exactly 2 arguments")))
            ((streq base-name (str-fmul))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fmul (cg-syms ctx)))
                 (codegen-error ctx "Error: fmul requires exactly 2 arguments")))
            ((streq base-name (str-fdiv))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-fdiv (cg-syms ctx)))
                 (codegen-error ctx "Error: fdiv requires exactly 2 arguments")))
            ((streq base-name (str-frem))
             (if (= (scons-length form) 3)
                 (codegen-float-binop ctx form (sym-frem (cg-syms ctx)))
                 (codegen-error ctx "Error: frem requires exactly 2 arguments")))
            ;; Boolean and bitwise operators
            ((streq base-name (str-not))
             (if (= (scons-length form) 2)
                 (codegen-not ctx form)
                 (codegen-error ctx "Error: not requires exactly 1 argument")))
            ((streq base-name (str-and))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-and (cg-syms ctx)))
                 (codegen-error ctx "Error: and requires exactly 2 arguments")))
            ((streq base-name (str-or))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-or (cg-syms ctx)))
                 (codegen-error ctx "Error: or requires exactly 2 arguments")))
            ((streq base-name (str-bit-and))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-and (cg-syms ctx)))
                 (codegen-error ctx "Error: bit-and requires exactly 2 arguments")))
            ((streq base-name (str-bit-or))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-or (cg-syms ctx)))
                 (codegen-error ctx "Error: bit-or requires exactly 2 arguments")))
            ((streq base-name (str-bit-xor))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-xor (cg-syms ctx)))
                 (codegen-error ctx "Error: bit-xor requires exactly 2 arguments")))
            ((streq base-name (str-bit-not))
             (if (= (scons-length form) 2)
                 (let ((arg-result (codegen-expr ctx (cadr form)))
                       (ctx1 (pcons-head arg-result))
                       (arg-v (pcons-tail arg-result))
                       (syms (cg-syms ctx1)))
                   (pcons ctx1 (lir-binop syms (sym-xor syms) (lir-int syms -1) arg-v)))
                 (codegen-error ctx "Error: bit-not requires exactly 1 argument")))
            ((streq base-name (str-bit-shift-left))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-shl (cg-syms ctx)))
                 (codegen-error ctx "Error: bit-shift-left requires exactly 2 arguments")))
            ((streq base-name (str-shl))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-shl (cg-syms ctx)))
                 (codegen-error ctx "Error: shl requires exactly 2 arguments")))
            ((streq base-name (str-bit-shift-right))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-lshr (cg-syms ctx)))
                 (codegen-error ctx "Error: bit-shift-right requires exactly 2 arguments")))
            ((streq base-name (str-shr))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-lshr (cg-syms ctx)))
                 (codegen-error ctx "Error: shr requires exactly 2 arguments")))
            ((streq base-name (str-arithmetic-shift-right))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-ashr (cg-syms ctx)))
                 (codegen-error ctx "Error: arithmetic-shift-right requires exactly 2 arguments")))
            ((streq base-name (str-ashr))
             (if (= (scons-length form) 3)
                 (codegen-binary-op ctx form (sym-ashr (cg-syms ctx)))
                 (codegen-error ctx "Error: ashr requires exactly 2 arguments")))
            ((streq base-name (str-popcount))
             (if (= (scons-length form) 2)
                 (codegen-unary-op ctx form (sym-ctpop (cg-syms ctx)))
                 (codegen-error ctx "Error: popcount requires exactly 1 argument")))
            ;; Type conversion operators
            ((streq base-name (str-trunc))       (codegen-conv-checked ctx form (sym-trunc (cg-syms ctx)) "Error: trunc requires exactly 2 arguments"))
            ((streq base-name (str-zext))        (codegen-conv-checked ctx form (sym-zext (cg-syms ctx)) "Error: zext requires exactly 2 arguments"))
            ((streq base-name (str-sext))        (codegen-conv-checked ctx form (sym-sext (cg-syms ctx)) "Error: sext requires exactly 2 arguments"))
            ((streq base-name (str-fptosi))      (codegen-conv-checked ctx form (sym-fptosi (cg-syms ctx)) "Error: fptosi requires exactly 2 arguments"))
            ((streq base-name (str-fptoui))      (codegen-conv-checked ctx form (sym-fptoui (cg-syms ctx)) "Error: fptoui requires exactly 2 arguments"))
            ((streq base-name (str-sitofp))      (codegen-conv-checked ctx form (sym-sitofp (cg-syms ctx)) "Error: sitofp requires exactly 2 arguments"))
            ((streq base-name (str-uitofp))      (codegen-conv-checked ctx form (sym-uitofp (cg-syms ctx)) "Error: uitofp requires exactly 2 arguments"))
            ((streq base-name (str-fpext))       (codegen-conv-checked ctx form (sym-fpext (cg-syms ctx)) "Error: fpext requires exactly 2 arguments"))
            ((streq base-name (str-fptrunc))     (codegen-conv-checked ctx form (sym-fptrunc (cg-syms ctx)) "Error: fptrunc requires exactly 2 arguments"))
            ;; Byte and pointer operators
            ((streq base-name (str-store-byte))
             (if (= (scons-length form) 3)
                 (codegen-store-byte ctx form)
                 (codegen-error ctx "Error: store-byte requires exactly 2 arguments")))
            ((streq base-name (str-load-byte))
             (if (= (scons-length form) 2)
                 (codegen-load-byte ctx form)
                 (codegen-error ctx "Error: load-byte requires exactly 1 argument")))
            ((streq base-name (str-ptr-plus))
             (if (= (scons-length form) 3)
                 (codegen-ptr-plus ctx form)
                 (codegen-error ctx "Error: ptr+ requires exactly 2 arguments")))
            ;; Array operators
            ((streq base-name (str-array))
             (if (= (scons-length form) 2)
                 (codegen-array-alloc ctx form)
                 (codegen-error ctx "Error: array requires exactly 1 argument")))
            ((streq base-name (str-make-array))
             (if (= (scons-length form) 2)
                 (codegen-array-alloc ctx form)
                 (codegen-error ctx "Error: make-array requires exactly 1 argument")))
            ((streq base-name (str-array-get))
             (if (= (scons-length form) 3)
                 (codegen-array-get ctx form)
                 (codegen-error ctx "Error: array-get requires 2 arguments")))
            ((streq base-name (str-aget))
             (if (= (scons-length form) 3)
                 (codegen-array-get ctx form)
                 (codegen-error ctx "Error: aget requires 2 arguments")))
            ((streq base-name (str-array-set))
             (if (= (scons-length form) 4)
                 (codegen-array-set ctx form)
                 (codegen-error ctx "Error: array-set requires 3 arguments")))
            ((streq base-name (str-aset))
             (if (= (scons-length form) 4)
                 (codegen-array-set ctx form)
                 (codegen-error ctx "Error: aset requires 3 arguments")))
            ((streq base-name (str-array-len))
             (if (= (scons-length form) 2)
                 (codegen-array-len ctx form)
                 (codegen-error ctx "Error: array-len requires exactly 1 argument")))
            ((streq base-name (str-alen))
             (if (= (scons-length form) 2)
                 (codegen-array-len ctx form)
                 (codegen-error ctx "Error: alen requires exactly 1 argument")))
            ((streq base-name (str-heap-array))
             (if (= (scons-length form) 2)
                 (codegen-heap-array ctx form)
                 (codegen-error ctx "Error: heap-array requires exactly 1 argument")))
            ((streq base-name (str-array-copy))
             (if (= (scons-length form) 4)
                 (codegen-array-copy ctx form)
                 (codegen-error ctx "Error: array-copy requires 3 arguments")))
            ((streq base-name (str-heap-array-ptr))
             (if (= (scons-length form) 2)
                 (codegen-ptr-array-alloc ctx form)
                 (codegen-error ctx "Error: heap-array-ptr requires exactly 1 argument")))
            ((streq base-name (str-aget-ptr))
             (if (= (scons-length form) 3)
                 (codegen-ptr-array-get ctx form)
                 (codegen-error ctx "Error: aget-ptr requires 2 arguments")))
            ((streq base-name (str-aset-ptr))
             (if (= (scons-length form) 4)
                 (codegen-ptr-array-set ctx form)
                 (codegen-error ctx "Error: aset-ptr requires 3 arguments")))
            ;; Ownership operators
            ((streq base-name (str-alloc))
             (if (= (scons-length form) 1)
                 (pcons ctx (scons (sym-alloc (cg-syms ctx))
                                   (scons (sym-own (cg-syms ctx)) (scons (sym-i64 (cg-syms ctx)) nil))))
                 (codegen-error ctx "Error: alloc requires no arguments")))
            ((streq base-name (str-drop))
             (if (= (scons-length form) 2)
                 (codegen-unary-op ctx form (sym-drop (cg-syms ctx)))
                 (codegen-error ctx "Error: drop requires exactly 1 argument")))
            ((streq base-name (str-move))
             (if (= (scons-length form) 2)
                 (codegen-unary-op ctx form (sym-move (cg-syms ctx)))
                 (codegen-error ctx "Error: move requires exactly 1 argument")))
            ((streq base-name (str-rc-new))
             (if (= (scons-length form) 2)
                 (let ((arg-result (codegen-expr ctx (cadr form)))
                       (ctx1 (pcons-head arg-result))
                       (syms (cg-syms ctx1)))
                   (pcons ctx1 (scons (sym-rc-alloc syms) (scons (sym-i64 syms) nil))))
                 (codegen-error ctx "Error: rc-new requires exactly 1 argument")))
            ((streq base-name (str-rc-clone))
             (if (= (scons-length form) 2)
                 (codegen-unary-op ctx form (sym-rc-clone (cg-syms ctx)))
                 (codegen-error ctx "Error: rc-clone requires exactly 1 argument")))
            ((streq base-name (str-rc-drop))
             (if (= (scons-length form) 2)
                 (codegen-unary-op ctx form (sym-rc-drop (cg-syms ctx)))
                 (codegen-error ctx "Error: rc-drop requires exactly 1 argument")))
            ((streq base-name (str-clone))
             (if (= (scons-length form) 2)
                 (codegen-unary-op ctx form (sym-rc-clone (cg-syms ctx)))
                 (codegen-error ctx "Error: clone requires exactly 1 argument")))
            ((streq base-name (str-share))
             (if (= (scons-length form) 2)
                 (codegen-share ctx form)
                 (codegen-error ctx "Error: share requires exactly 1 argument")))
            ;; I/O operators
            ;; Note: Check if original arg is a string BEFORE codegen.
            ;; This is more reliable than lir-expr-ret-type which can fail
            ;; due to symbol table issues in self-hosted compilation.
            ((streq base-name (str-print))
             (if (= (scons-length form) 2)
                 (let ((arg-form (cadr form))
                       (arg-result (codegen-expr ctx arg-form))
                       (ctx1 (pcons-head arg-result))
                       (arg-v (pcons-tail arg-result))
                       (syms (cg-syms ctx1))
                       (fmt-expr (if (liar-string? arg-form)
                                     (scons (sym-string syms) (scons (fmt-percent-s) nil))
                                     (scons (sym-string syms) (scons (fmt-percent-ld) nil)))))
                   (codegen-print-call ctx1 arg-v fmt-expr))
                 (codegen-error ctx "Error: print requires exactly 1 argument")))
            ((streq base-name (str-println))
             (if (= (scons-length form) 2)
                 (let ((arg-form (cadr form))
                       (arg-result (codegen-expr ctx arg-form))
                       (ctx1 (pcons-head arg-result))
                       (arg-v (pcons-tail arg-result))
                       (syms (cg-syms ctx1))
                       (fmt-expr (if (liar-string? arg-form)
                                     (scons (sym-string syms) (scons (fmt-percent-s-nl) nil))
                                     (scons (sym-string syms) (scons (fmt-percent-ld-nl) nil)))))
                   (codegen-print-call ctx1 arg-v fmt-expr))
                 (codegen-error ctx "Error: println requires exactly 1 argument")))
            ;; Builtin predicates
            ((streq base-name (str-nil?))        (codegen-nil? ctx form))
            ;; Struct operations
            ((streq base-name (str-defstruct))   (codegen-defstruct ctx form))
            ((streq base-name (str-defprotocol)) (codegen-defprotocol ctx form))
            ((streq base-name (str-extend-protocol)) (codegen-extend-protocol ctx form))
            ((streq base-name (str-extend-protocol-default)) (codegen-extend-protocol-default ctx form))
            ((streq base-name (str-instance?))   (codegen-instance? ctx form))
            ((streq base-name (str-dot))         (codegen-field-access ctx form))
            (else                      (codegen-call-or-struct ctx form))))
        (codegen-call ctx form))))

;; ============================================================
;; Binary Operations
;; ============================================================

(defun codegen-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

(defun codegen-cmp (ctx: ptr form: ptr pred: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-icmp syms pred left-v right-v))))

;; Float binary operations - same as codegen-binop but for float ops
(defun codegen-float-binop (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result))
        (syms (cg-syms ctx)))
    (pcons ctx (lir-binop syms op left-v right-v))))

;; Resolve conversion type symbol to lIR type (nil if invalid)
(defun conv-type-sym (syms: ptr type-sym: ptr) -> ptr
  (if (not (symbol? type-sym))
      nil
      (if (= 1 (sym-eq? type-sym (sym-i1 syms)))
          (sym-i1 syms)
          (if (= 1 (sym-eq? type-sym (sym-i8 syms)))
              (sym-i8 syms)
              (if (= 1 (sym-eq? type-sym (sym-i16 syms)))
                  (sym-i16 syms)
                  (if (= 1 (sym-eq? type-sym (sym-i32 syms)))
                      (sym-i32 syms)
                      (if (= 1 (sym-eq? type-sym (sym-i64 syms)))
                          (sym-i64 syms)
                          (if (= 1 (sym-eq? type-sym (sym-float syms)))
                              (sym-float syms)
                              (if (= 1 (sym-eq? type-sym (sym-double syms)))
                                  (sym-double syms)
                                  nil)))))))))

;; Type conversion operations - emit (op target-type value)
(defun codegen-conv (ctx: ptr target-type: ptr value-form: ptr op: ptr) -> ptr
  (let ((value-result (codegen-expr ctx value-form))
        (ctx (pcons-head value-result))
        (value-v (pcons-tail value-result)))
    (pcons ctx (scons op (scons target-type (scons value-v nil))))))

(defun codegen-conv-checked (ctx: ptr form: ptr op: ptr err-msg: string) -> ptr
  (if (not (= (scons-length form) 3))
      (codegen-error ctx err-msg)
      (let ((target (cadr form))
            (syms (cg-syms ctx))
            (ty (conv-type-sym syms (cadr form))))
        (if (nil? ty)
            (if (symbol? target)
                (codegen-error ctx "undefined variable")
                (codegen-error ctx "type conversion requires a type name"))
            (codegen-conv ctx ty (caddr form) op)))))

;; ============================================================
;; Builtin Predicates
;; ============================================================

;; nil? - check if a pointer is null
;; Form: (nil? expr)
;; Emits: (icmp eq arg (ptr null))
(defun codegen-nil? (ctx: ptr form: ptr) -> ptr
  (let ((arg-form (cadr form))
        (arg-result (codegen-expr ctx arg-form))
        (ctx (pcons-head arg-result))
        (arg-v (pcons-tail arg-result))
        (syms (cg-syms ctx)))
    ;; Emit: (icmp eq arg (ptr null))
    (pcons ctx (lir-icmp syms (sym-eq syms) arg-v (lir-null syms)))))

;; ============================================================
;; Struct Operations
;; ============================================================

;; Try to codegen as struct constructor, fall back to function call
(defun codegen-call-or-struct (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (struct-info (if (symbol? head) (cg-lookup-struct ctx head) nil)))
    (if (nil? struct-info)
        (codegen-call ctx form)
        (codegen-struct-constructor ctx form struct-info))))

;; Helper to count scons list length
(defun scons-length (lst: ptr) -> i64
  (scons-length-loop lst 0))

(defun scons-length-loop (lst: ptr acc: i64) -> i64
  (if (nil? lst)
      acc
      (scons-length-loop (cdr lst) (+ acc 1))))

;; Helper string for __type_id
(defun str-type-id () -> ptr
  (let ((b (heap-array 10)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95)   ;; __
        (store-byte (ptr+ b 2) 116) (store-byte (ptr+ b 3) 121) ;; ty
        (store-byte (ptr+ b 4) 112) (store-byte (ptr+ b 5) 101) ;; pe
        (store-byte (ptr+ b 6) 95) (store-byte (ptr+ b 7) 105)  ;; _i
        (store-byte (ptr+ b 8) 100) (store-byte (ptr+ b 9) 0) b))) ;; d

;; Helper string for __env
(defun str-env () -> ptr
  (let ((b (heap-array 6)))
    (do (store-byte b 95) (store-byte (ptr+ b 1) 95)   ;; __
        (store-byte (ptr+ b 2) 101) (store-byte (ptr+ b 3) 110) ;; en
        (store-byte (ptr+ b 4) 118) (store-byte (ptr+ b 5) 0) b))) ;; v

;; Helper to build %struct.Name symbol
(defun make-struct-type-sym (syms: ptr name: ptr) -> ptr
  (let ((name-str (symbol-name name))
        (name-len (strlen name-str))
        (buf-len (+ 9 name-len))  ;; "%struct." + name + null
        (buf (heap-array buf-len)))
    (do
      (store-byte buf 37)           ;; %
      (store-byte (ptr+ buf 1) 115) ;; s
      (store-byte (ptr+ buf 2) 116) ;; t
      (store-byte (ptr+ buf 3) 114) ;; r
      (store-byte (ptr+ buf 4) 117) ;; u
      (store-byte (ptr+ buf 5) 99)  ;; c
      (store-byte (ptr+ buf 6) 116) ;; t
      (store-byte (ptr+ buf 7) 46)  ;; .
      (copy-str-loop buf 8 name-str 0 name-len)
      (store-byte (ptr+ buf (+ 8 name-len)) 0)
      (intern syms buf))))

;; Parse defstruct field types (x: i64 y: i64) -> (i64 i64)
(defun parse-struct-fields (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((colon (car rest))
                  (rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2)))
                    (parse-struct-fields rest3 (scons typ acc)))))))))

;; Build field list for struct registry: ((field-name . type) ...)
(defun build-field-info (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-scons acc)
            (let ((colon (car rest))
                  (rest2 (cdr rest)))
              (if (nil? rest2)
                  (reverse-scons acc)
                  (let ((typ (car rest2))
                        (rest3 (cdr rest2)))
                    (build-field-info rest3 (scons (pcons name typ) acc)))))))))

;; Codegen for defstruct: (defstruct Name (x: i64 y: i64))
(defun codegen-defstruct (ctx: ptr form: ptr) -> ptr
  (let ((name (cadr form))
        (raw-fields (caddr form))
        (field-types (parse-struct-fields raw-fields nil))
        (field-info (build-field-info raw-fields nil))
        (syms (cg-syms ctx))
        ;; Prepend i64 for type_id field
        (all-types (scons (sym-i64 syms) field-types))
        ;; Build defstruct form
        (lir-def (scons (sym-defstruct syms) (scons name (scons all-types nil))))
        ;; Register struct with prepended __type_id field
        (type-id-field (pcons (intern syms (str-type-id)) (sym-i64 syms)))
        (all-fields (scons type-id-field field-info))
        (ctx (cg-register-struct ctx name all-fields))
        (ctx (cg-add-struct-def ctx lir-def)))
    (pcons ctx nil)))

;; Helper to codegen a list of args
(defun codegen-args-list (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx (reverse-scons acc))
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args-list ctx (cdr args) (scons v acc)))))

;; Unary op helper: (op arg)
(defun codegen-unary-op (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((arg-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arg-result))
        (arg-v (pcons-tail arg-result)))
    (pcons ctx (scons op (scons arg-v nil)))))

;; Binary op helper: (op a b) where op is a symbol (and/or/xor/shifts)
(defun codegen-binary-op (ctx: ptr form: ptr op: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result)))
    (pcons ctx (lir-binop (cg-syms ctx) op left-v right-v))))

;; Float comparison helper
(defun codegen-fcmp (ctx: ptr form: ptr pred: ptr) -> ptr
  (let ((left-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head left-result))
        (left-v (pcons-tail left-result))
        (right-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head right-result))
        (right-v (pcons-tail right-result)))
    (pcons ctx (lir-fcmp (cg-syms ctx) pred left-v right-v))))

;; Boolean not: (xor (i1 1) (icmp ne arg (i64 0)))
(defun codegen-not (ctx: ptr form: ptr) -> ptr
  (let ((arg-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arg-result))
        (arg-v (pcons-tail arg-result))
        (syms (cg-syms ctx))
        (arg-ty (lir-expr-ret-type ctx arg-v)))
    (pcons ctx
           (lir-binop syms (sym-xor syms) (lir-i1 syms 1)
                      (if (= 1 (sym-eq? arg-ty (sym-i1 syms)))
                          arg-v
                          (lir-icmp syms (sym-ne syms) arg-v (lir-int syms 0)))))))

;; Print/println helper
(defun codegen-print-call (ctx: ptr arg-v: ptr fmt-expr: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (args (scons fmt-expr (scons arg-v nil))))
    (pcons ctx (lir-call syms (sym-printf syms) args))))

;; Array operations
(defun codegen-array-alloc (ctx: ptr form: ptr) -> ptr
  (let ((size-form (cadr form))
        (syms (cg-syms ctx)))
    (if (boxed-int? size-form)
        (pcons ctx (scons (sym-array-alloc syms)
                          (scons (sym-i64 syms) (scons (box-int (unbox-int size-form)) nil))))
        (let ((size-result (codegen-expr ctx size-form))
              (ctx (pcons-head size-result))
              (size-v (pcons-tail size-result)))
          (pcons ctx (scons (sym-array-alloc syms)
                            (scons (sym-i64 syms) (scons size-v nil))))))))

(defun codegen-array-get (ctx: ptr form: ptr) -> ptr
  (let ((arr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arr-result))
        (arr-v (pcons-tail arr-result))
        (idx-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head idx-result))
        (idx-v (pcons-tail idx-result))
        (syms (cg-syms ctx)))
    (pcons ctx (scons (sym-array-get syms)
                      (scons (sym-i64 syms) (scons (box-int 0) (scons arr-v (scons idx-v nil))))))))

(defun codegen-array-set (ctx: ptr form: ptr) -> ptr
  (let ((arr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arr-result))
        (arr-v (pcons-tail arr-result))
        (idx-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head idx-result))
        (idx-v (pcons-tail idx-result))
        (val-result (codegen-expr ctx (cadddr form)))
        (ctx (pcons-head val-result))
        (val-v (pcons-tail val-result))
        (syms (cg-syms ctx)))
    (pcons ctx (scons (sym-array-set syms)
                      (scons (sym-i64 syms)
                             (scons (box-int 0)
                                    (scons arr-v (scons idx-v (scons val-v nil)))))))))

(defun codegen-array-len (ctx: ptr form: ptr) -> ptr
  (let ((arr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arr-result))
        (arr-v (pcons-tail arr-result))
        (syms (cg-syms ctx)))
    (pcons ctx (scons (sym-array-len syms) (scons arr-v nil)))))

(defun codegen-heap-array (ctx: ptr form: ptr) -> ptr
  (let ((size-form (cadr form))
        (syms (cg-syms ctx)))
    (if (boxed-int? size-form)
        (pcons ctx (scons (sym-heap-array syms)
                          (scons (sym-i64 syms) (scons (box-int (unbox-int size-form)) nil))))
        (let ((size-result (codegen-expr ctx size-form))
              (ctx (pcons-head size-result))
              (size-v (pcons-tail size-result)))
          (pcons ctx (scons (sym-heap-array-dyn syms)
                            (scons (sym-i64 syms) (scons size-v nil))))))))

(defun codegen-array-copy (ctx: ptr form: ptr) -> ptr
  (let ((size-form (cadr form))
        (syms (cg-syms ctx)))
    (if (boxed-int? size-form)
        (let ((dest-result (codegen-expr ctx (caddr form)))
              (ctx (pcons-head dest-result))
              (dest-v (pcons-tail dest-result))
              (src-result (codegen-expr ctx (cadddr form)))
              (ctx (pcons-head src-result))
              (src-v (pcons-tail src-result))
              (size-v (box-int (unbox-int size-form))))
          (pcons ctx (scons (sym-array-copy syms)
                            (scons (sym-i64 syms) (scons size-v (scons dest-v (scons src-v nil)))))))
        (let ((size-result (codegen-expr ctx size-form))
              (ctx (pcons-head size-result))
              (size-v (pcons-tail size-result))
              (dest-result (codegen-expr ctx (caddr form)))
              (ctx (pcons-head dest-result))
              (dest-v (pcons-tail dest-result))
              (src-result (codegen-expr ctx (cadddr form)))
              (ctx (pcons-head src-result))
              (src-v (pcons-tail src-result)))
          (pcons ctx (scons (sym-array-copy syms)
                            (scons (sym-i64 syms) (scons size-v (scons dest-v (scons src-v nil))))))))))

(defun codegen-ptr-array-alloc (ctx: ptr form: ptr) -> ptr
  (let ((size-form (cadr form))
        (syms (cg-syms ctx)))
    (if (boxed-int? size-form)
        (pcons ctx (scons (sym-ptr-array-alloc syms)
                          (scons (box-int (unbox-int size-form)) nil)))
        (let ((size-result (codegen-expr ctx size-form))
              (ctx (pcons-head size-result))
              (size-v (pcons-tail size-result)))
          (pcons ctx (scons (sym-heap-array-dyn syms)
                            (scons (sym-i64 syms) (scons size-v nil))))))))

(defun codegen-ptr-array-get (ctx: ptr form: ptr) -> ptr
  (let ((arr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arr-result))
        (arr-v (pcons-tail arr-result))
        (idx-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head idx-result))
        (idx-v (pcons-tail idx-result))
        (syms (cg-syms ctx)))
    (pcons ctx (scons (sym-ptr-array-get syms)
                      (scons (box-int 0) (scons arr-v (scons idx-v nil)))))))

(defun codegen-ptr-array-set (ctx: ptr form: ptr) -> ptr
  (let ((arr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head arr-result))
        (arr-v (pcons-tail arr-result))
        (idx-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head idx-result))
        (idx-v (pcons-tail idx-result))
        (val-result (codegen-expr ctx (cadddr form)))
        (ctx (pcons-head val-result))
        (val-v (pcons-tail val-result))
        (syms (cg-syms ctx)))
    (pcons ctx (scons (sym-ptr-array-set syms)
                      (scons (box-int 0) (scons arr-v (scons idx-v (scons val-v nil))))))))

;; Byte/pointer operations
(defun codegen-store-byte (ctx: ptr form: ptr) -> ptr
  (let ((ptr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head ptr-result))
        (ptr-v (pcons-tail ptr-result))
        (val-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head val-result))
        (val-v (pcons-tail val-result))
        (syms (cg-syms ctx))
        (trunc-v (scons (sym-trunc syms) (scons (sym-i8 syms) (scons val-v nil)))))
    (pcons ctx (scons (sym-store syms) (scons trunc-v (scons ptr-v nil))))))

(defun codegen-load-byte (ctx: ptr form: ptr) -> ptr
  (let ((ptr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head ptr-result))
        (ptr-v (pcons-tail ptr-result))
        (syms (cg-syms ctx))
        (load-v (lir-load syms (sym-i8 syms) ptr-v)))
    (pcons ctx (scons (sym-zext syms) (scons (sym-i64 syms) (scons load-v nil))))))

(defun codegen-ptr-plus (ctx: ptr form: ptr) -> ptr
  (let ((ptr-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head ptr-result))
        (ptr-v (pcons-tail ptr-result))
        (idx-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head idx-result))
        (idx-v (pcons-tail idx-result))
        (syms (cg-syms ctx)))
    (pcons ctx (scons (sym-getelementptr syms)
                      (scons (sym-inbounds syms)
                             (scons (sym-i8 syms) (scons ptr-v (scons idx-v nil))))))))

;; Codegen for share: (share (Point 10 20))
;; Emits: (heap-struct Point type-id arg1 arg2 ...)
(defun codegen-share (ctx: ptr form: ptr) -> ptr
  (let ((inner (cadr form)))
    (if (scons? inner)
        (let ((struct-name (car inner))
              (struct-info (cg-lookup-struct ctx struct-name)))
          (if (nil? struct-info)
              ;; Not a struct constructor - error
              (codegen-error ctx "share requires a struct constructor argument")
              (let ((args (cdr inner))
                    (type-id (struct-entry-type-id struct-info))
                    (syms (cg-syms ctx))
                    ;; Generate argument expressions
                    (args-result (codegen-args-list ctx args nil))
                    (ctx (pcons-head args-result))
                    (arg-vals (pcons-tail args-result))
                    ;; Prepend type-id to field values
                    (all-vals (scons (lir-int syms type-id) arg-vals)))
                (pcons ctx (scons (sym-heap-struct syms)
                                 (scons struct-name all-vals))))))
        (codegen-error ctx "share requires a struct constructor argument"))))

;; Find field index in struct fields list (0-indexed)
(defun find-field-index (fields: ptr field-name: ptr idx: i64) -> i64
  (if (nil? fields)
      -1
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            idx
            (find-field-index (cdr fields) field-name (+ idx 1))))))

;; Find field entry (name . type)
(defun find-field-entry (fields: ptr field-name: ptr) -> ptr
  (if (nil? fields)
      nil
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            entry
            (find-field-entry (cdr fields) field-name)))))

;; Find struct that has a given field
(defun find-struct-with-field (ctx: ptr field-name: ptr) -> ptr
  (find-struct-loop (cg-structs ctx) field-name))

(defun find-struct-loop (structs: ptr field-name: ptr) -> ptr
  (if (nil? structs)
      nil
      (let ((entry (car structs))
            (fields (struct-entry-fields entry)))
        (if (= 1 (struct-has-field? fields field-name))
            entry
            (find-struct-loop (cdr structs) field-name)))))

(defun struct-has-field? (fields: ptr field-name: ptr) -> i64
  (if (nil? fields)
      0
      (let ((entry (car fields))
            (name (pcons-head entry)))
        (if (= 1 (sym-eq? name field-name))
            1
            (struct-has-field? (cdr fields) field-name)))))

;; Codegen for field access: (. obj field)
(defun codegen-field-access (ctx: ptr form: ptr) -> ptr
  (let ((obj-form (cadr form))
        (field-name (caddr form))
        (obj-result (codegen-expr ctx obj-form))
        (ctx (pcons-head obj-result))
        (obj-v (pcons-tail obj-result))
        (syms (cg-syms ctx))
        (struct-info (find-struct-with-field ctx field-name)))
    (if (nil? struct-info)
        (pcons ctx (lir-int syms -999))
        (codegen-field-access-found ctx obj-v field-name struct-info))))

(defun codegen-field-access-found (ctx: ptr obj-v: ptr field-name: ptr struct-info: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (struct-name (car struct-info))
        (fields (struct-entry-fields struct-info))
        (field-idx (find-field-index fields field-name 0))
        (field-entry (find-field-entry fields field-name)))
    (let ((field-ty (pcons-tail field-entry))
          (struct-ty (make-struct-type-sym syms struct-name)))
      ;; Emit: (load i64 (getelementptr inbounds %struct.X obj (i64 0) (i64 idx)))
      (pcons ctx (scons (sym-load syms)
                       (scons field-ty
                              (scons (scons (sym-getelementptr syms)
                                           (scons (sym-inbounds syms)
                                                  (scons struct-ty
                                                         (scons obj-v
                                                                (scons (lir-int syms 0)
                                                                       (scons (lir-int syms field-idx) nil))))))
                                     nil)))))))

;; Codegen for struct constructor: (Point 10 20)
(defun codegen-struct-constructor (ctx: ptr form: ptr struct-info: ptr) -> ptr
  (let ((name (car form))
        (args (cdr form))
        (fields (struct-entry-fields struct-info))
        (type-id (struct-entry-type-id struct-info))
        (num-fields (scons-length fields))
        (syms (cg-syms ctx))
        ;; Generate argument expressions
        (args-result (codegen-args-list ctx args nil))
        (ctx (pcons-head args-result))
        (arg-vals (pcons-tail args-result))
        (struct-ty (make-struct-type-sym syms name))
        (ptr-sym (sym-ptr syms))
        ;; Build the alloca + stores + ptr return expression
        (body (build-struct-stores syms struct-ty arg-vals type-id 1 nil)))
    ;; Wrap in let with alloca
    (pcons ctx (scons (sym-let syms)
                      (scons (scons (scons ptr-sym
                                          (scons (scons (sym-alloca syms)
                                                       (scons (sym-i64 syms)
                                                              (scons (lir-int syms num-fields) nil)))
                                                nil))
                                   nil)
                            (scons (scons (sym-store syms)
                                         (scons (lir-int syms type-id)
                                                (scons (make-gep-idx0 syms struct-ty ptr-sym 0) nil)))
                                   body))))))

;; Helper to generate GEP for field index 0,N
(defun make-gep-idx0 (syms: ptr struct-ty: ptr ptr-sym: ptr idx: i64) -> ptr
  (scons (sym-getelementptr syms)
         (scons (sym-inbounds syms)
                (scons struct-ty
                       (scons ptr-sym
                              (scons (lir-int syms 0)
                                     (scons (lir-int syms idx) nil)))))))

;; Build store expressions for struct fields
(defun build-struct-stores (syms: ptr struct-ty: ptr args: ptr type-id: i64 idx: i64 acc: ptr) -> ptr
  (if (nil? args)
      (reverse-scons (scons (sym-ptr syms) acc))
      (let ((arg (car args))
            (store-expr (scons (sym-store syms)
                              (scons arg
                                     (scons (make-gep-idx0 syms struct-ty (sym-ptr syms) idx) nil)))))
        (build-struct-stores syms struct-ty (cdr args) type-id (+ idx 1) (scons store-expr acc)))))

(defun ensure-instance-check-fn (ctx: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (fn-name (intern (cg-syms ctx) (str-instance-check))))
    (if (= 1 (fn-list-has? (cg-fn-names ctx) fn-name))
        (pcons ctx fn-name)
        (let ((obj-name (intern syms (str-instance-obj)))
              (type-name (intern syms (str-instance-type-id)))
              (null-lbl (intern syms (str-instance-null)))
              (check-lbl (intern syms (str-instance-check-lbl)))
              (cond-v (lir-icmp syms (sym-eq syms) obj-name (lir-null syms)))
              (entry-block (lir-block syms (sym-entry syms)
                                      (scons (lir-br-cond syms cond-v null-lbl check-lbl) nil)))
              (null-block (lir-block syms null-lbl
                                     (scons (lir-ret syms (lir-int syms 0)) nil)))
              (check-ret (scons (sym-zext syms)
                                (scons (sym-i64 syms)
                                       (scons (lir-icmp syms (sym-eq syms)
                                                        (lir-load syms (sym-i64 syms) obj-name)
                                                        type-name)
                                              nil))))
              (check-block (lir-block syms check-lbl
                                      (scons (lir-ret syms check-ret) nil)))
              (fn-sig (scons fn-name (scons (sym-i64 syms) nil)))
              (params (scons (lir-env-param syms)
                             (scons (scons (sym-ptr syms) (scons obj-name nil))
                                    (scons (scons (sym-i64 syms) (scons type-name nil)) nil))))
              (fn-def (scons (sym-define syms)
                             (scons fn-sig
                                    (scons params
                                           (scons entry-block
                                                  (scons null-block (scons check-block nil))))))))
          (pcons (cg-add-fn-def ctx fn-name fn-def) fn-name)))))

;; Codegen for instance?: (instance? obj Type)
(defun codegen-instance? (ctx: ptr form: ptr) -> ptr
  (let ((obj-form (cadr form))
        (type-name (caddr form))
        (struct-info (cg-lookup-struct ctx type-name)))
    (if (nil? struct-info)
        ;; Type not found - return false
        (pcons ctx (lir-int (cg-syms ctx) 0))
        ;; Delegate to helper function to keep phi/branches out of expressions.
        (let ((fn-result (ensure-instance-check-fn ctx))
              (ctx (pcons-head fn-result))
              (fn-name (pcons-tail fn-result))
              (obj-result (codegen-expr ctx obj-form))
              (ctx (pcons-head obj-result))
              (obj-v (pcons-tail obj-result))
              (type-id (struct-entry-type-id struct-info))
              (syms (cg-syms ctx))
              (args (scons (lir-null syms)
                           (scons obj-v (scons (lir-int syms type-id) nil)))))
          (pcons ctx (lir-call syms fn-name args))))))

;; ============================================================
;; Protocols
;; ============================================================

;; Strip generic type args from protocol names (Seq<i64> -> Seq)
(defun find-char (s: ptr idx: i64 target: i64) -> i64
  (let ((c (load-byte (ptr+ s idx))))
    (if (= c 0)
        -1
        (if (= c target)
            idx
            (find-char s (+ idx 1) target)))))

(defun protocol-base (syms: ptr protocol: ptr) -> ptr
  (let ((name (symbol-name protocol))
        (len (strlen name))
        (idx (find-char (symbol-name protocol) 0 60)))  ;; '<'
    (if (< idx 0)
        (let ((buf (heap-array (+ len 1))))
          (do
            (copy-str-loop buf 0 name 0 len)
            (store-byte (ptr+ buf len) 0)
            (intern syms buf)))
        (let ((buf (heap-array (+ idx 1))))
          (do
            (copy-str-loop buf 0 name 0 idx)
            (store-byte (ptr+ buf idx) 0)
            (intern syms buf))))))

;; Check for ASCII alnum or underscore
(defun is-alnum-or-underscore? (b: i64) -> i64
  (if (and (>= b 48) (<= b 57))
      1
      (if (and (>= b 65) (<= b 90))
          1
          (if (and (>= b 97) (<= b 122))
              1
              (if (= b 95) 1 0)))))

;; Sanitize type-arg substring into an identifier-safe suffix
(defun sanitize-args-loop (src: ptr idx: i64 len: i64 dst: ptr out-idx: i64 last-us: i64) -> ptr
  (if (>= idx len)
      (pcons (box-int out-idx) (box-int last-us))
      (let ((b (load-byte (ptr+ src idx)))
            (use (if (= 1 (is-alnum-or-underscore? b)) b 95))
            (is-us (if (= use 95) 1 0))
            (skip (if (and (= is-us 1) (= last-us 1)) 1 0)))
        (if (= skip 1)
            (sanitize-args-loop src (+ idx 1) len dst out-idx last-us)
            (do
              (store-byte (ptr+ dst out-idx) use)
              (sanitize-args-loop src (+ idx 1) len dst (+ out-idx 1) is-us))))))

;; Mangle protocol name with generic args for stable symbol names
(defun protocol-mangled (syms: ptr protocol: ptr) -> ptr
  (let ((name (symbol-name protocol))
        (lt-check (find-char name 0 60)))  ;; '<'
    (if (< lt-check 0)
        (protocol-base syms protocol)
        (let ((base-len (find-char name 0 60))
              (args-start (+ (find-char name 0 60) 1))
              (gt (find-char name (+ (find-char name 0 60) 1) 62)))  ;; '>'
          (if (< gt 0)
              (protocol-base syms protocol)
              (let ((args-len (- gt args-start))
                    (buf (heap-array (+ (+ base-len 1) (+ args-len 1)))))
                (do
                  (copy-str-loop buf 0 name 0 base-len)
                  (store-byte (ptr+ buf base-len) 95) ;; _
                  (let ((result (sanitize-args-loop (ptr+ name args-start) 0 args-len buf (+ base-len 1) 1))
                        (out-idx (unbox-int (pcons-head result))))
                    (do
                      (store-byte (ptr+ buf out-idx) 0)
                      (intern syms buf))))))))))

(defun method-return-sym (lst: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((head (car lst)))
        (if (= 1 (is-arrow-sym? head))
            (car (cdr lst))
            (method-return-sym (cdr lst))))))

(defun method-return-type (syms: ptr method-form: ptr) -> ptr
  (let ((ret-sym (method-return-sym (cdr method-form))))
    (if (nil? ret-sym)
        nil
        (type-sym-to-lir syms ret-sym))))

(defun codegen-defprotocol-loop (ctx: ptr protocol: ptr methods: ptr) -> ptr
  (if (nil? methods)
      ctx
      (let ((method-form (car methods))
            (method-name (car method-form))
            (ret (method-return-type (cg-syms ctx) method-form))
            (ctx (cg-register-proto-method ctx method-name protocol ret)))
        (codegen-defprotocol-loop ctx protocol (cdr methods)))))

(defun codegen-defprotocol (ctx: ptr form: ptr) -> ptr
  (let ((protocol (protocol-base (cg-syms ctx) (cadr form)))
        (methods (cddr form))
        (ctx (codegen-defprotocol-loop ctx protocol methods)))
    (pcons ctx nil)))

;; Integer helpers (binary + only)
(defun add3 (a b c) -> i64
  (+ (+ a b) c))

(defun add4 (a b c d) -> i64
  (+ (+ (+ a b) c) d))

;; Build function name for protocol impl: __Protocol_Type__method
(defun make-method-fn-name (syms: ptr protocol: ptr type-name: ptr method: ptr) -> ptr
  (let ((pname (symbol-name protocol))
        (tname (symbol-name type-name))
        (mname (symbol-name method))
        (plen (strlen pname))
        (tlen (strlen tname))
        (mlen (strlen mname))
        (total (add4 plen tlen mlen 5))  ;; "__" + "_" + "__" = 5
        (buf (heap-array (+ total 1))))
    (do
      (store-byte buf 95) (store-byte (ptr+ buf 1) 95)  ;; __
      (copy-str-loop buf 2 pname 0 plen)
      (store-byte (ptr+ buf (+ 2 plen)) 95)             ;; _
      (copy-str-loop buf (add3 3 plen 0) tname 0 tlen)
      (store-byte (ptr+ buf (add3 3 plen tlen)) 95)        ;; _
      (store-byte (ptr+ buf (add3 4 plen tlen)) 95)        ;; _
      (copy-str-loop buf (add3 5 plen tlen) mname 0 mlen)
      (store-byte (ptr+ buf total) 0)
      (intern syms buf))))

;; Build function name for protocol default: __Target_Source__method
(defun make-default-fn-name (syms: ptr target: ptr source: ptr method: ptr) -> ptr
  (let ((tname (symbol-name target))
        (sname (symbol-name source))
        (mname (symbol-name method))
        (tlen (strlen tname))
        (slen (strlen sname))
        (mlen (strlen mname))
        (total (add4 tlen slen mlen 5))
        (buf (heap-array (+ total 1))))
    (do
      (store-byte buf 95) (store-byte (ptr+ buf 1) 95)
      (copy-str-loop buf 2 tname 0 tlen)
      (store-byte (ptr+ buf (+ 2 tlen)) 95)
      (copy-str-loop buf (add3 3 tlen 0) sname 0 slen)
      (store-byte (ptr+ buf (add3 3 tlen slen)) 95)
      (store-byte (ptr+ buf (add3 4 tlen slen)) 95)
      (copy-str-loop buf (add3 5 tlen slen) mname 0 mlen)
      (store-byte (ptr+ buf total) 0)
      (intern syms buf))))

;; Build protocol method params list (self -> ptr, others -> i64)
(defun build-proto-params (syms: ptr params: ptr acc: ptr) -> ptr
  (if (nil? params)
      (reverse-scons acc)
      (let ((param (car params))
            (name (if (symbol? param) param param))
            (ty (if (= 1 (symbol-name-match? param (str-self)))
                    (sym-ptr syms)
                    (sym-i64 syms)))
            (pair (scons ty (scons name nil))))
        (build-proto-params syms (cdr params) (scons pair acc)))))

(defun build-param-type-list (syms: ptr params: ptr acc: ptr) -> ptr
  (if (nil? params)
      (reverse-pcons acc)
      (let ((param (car params))
            (name (if (symbol? param) param param))
            (ty (if (= 1 (symbol-name-match? param (str-self)))
                    (sym-ptr syms)
                    (sym-i64 syms))))
        (build-param-type-list syms (cdr params) (pcons (pcons name ty) acc)))))

(defun param-type-lookup (lst: ptr sym: ptr) -> ptr
  (if (nil? lst)
      nil
      (let ((entry (pcons-head lst)))
        (if (= 1 (sym-eq? (pcons-head entry) sym))
            (pcons-tail entry)
            (param-type-lookup (pcons-tail lst) sym)))))

(defun normalize-param-list (params: ptr) -> ptr
  (if (symbol? params)
      (if (= 1 (symbol-name-match? params (str-nil)))
          nil
          params)
      params))

(defun lir-expr-ret-type-with-params (ctx: ptr expr: ptr param-types: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    (cond
      ((symbol? expr)
       (let ((ty (param-type-lookup param-types expr)))
         (if (nil? ty) (sym-i64 syms) ty)))
      ((scons? expr)
       (let ((head (car expr)))
         (if (= 1 (sym-eq? head (sym-let syms)))
             (lir-expr-ret-type-with-params ctx (lir-let-body expr) param-types)
             (lir-expr-ret-type ctx expr))))
      (else (lir-expr-ret-type ctx expr)))))

(defun protocol-method-ret-type (ret-ty: ptr inferred: ptr) -> ptr
  (if (nil? ret-ty) inferred ret-ty))

(defun codegen-protocol-method (ctx: ptr fn-name: ptr params: ptr body: ptr ret-ty: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (lir-params (build-proto-params syms params nil))
        (lir-params (scons (lir-env-param syms) lir-params))
        (param-types (build-param-type-list syms params nil))
        (outer-fns (cg-fns ctx))
        (fn-ctx (share (CodegenCtx 0 syms (cg-env ctx) outer-fns 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                   (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                   (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                                   (cg-closure-counter ctx))))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        (body-v (promote-tailcall syms body-v))
        (body-v (promote-tailcall syms body-v))
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        (inferred (lir-expr-ret-type-with-params ctx body-v param-types))
        (method-ret (protocol-method-ret-type ret-ty inferred))
        (fn-sig (scons fn-name (scons method-ret nil)))
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        (inner-fns (fn-defs-since (cg-fns fn-ctx) outer-fns)))
    (let ((ctx (cg-merge-errors ctx fn-ctx)))
      (let ((ctx (cg-merge-fn-defs ctx inner-fns)))
      (let ((ctx (cg-add-fn-def ctx fn-name fn-def)))
        (pcons ctx (pcons fn-def inferred)))))))

(defun codegen-extend-protocol-loop (ctx: ptr protocol: ptr protocol-name: ptr type-name: ptr methods: ptr) -> ptr
  (if (nil? methods)
      ctx
      (let ((method-form (car methods))
            (method-name (car method-form))
            (params (cadr method-form))
            (body (caddr method-form))
            (fn-name (make-method-fn-name (cg-syms ctx) protocol-name type-name method-name))
            (entry (proto-methods-find (cg-proto-methods ctx) method-name protocol))
            (ret-ty (if (nil? entry) nil (proto-method-ret entry)))
            (result (codegen-protocol-method ctx fn-name params body ret-ty))
            (ctx (pcons-head result))
            (info (pcons-tail result))
            (inferred (pcons-tail info))
            (ctx (if (and (nil? ret-ty) (not (nil? inferred)))
                     (cg-update-proto-method-ret ctx method-name protocol inferred)
                     ctx))
            (ctx (cg-register-proto-impl ctx protocol type-name method-name fn-name)))
        (codegen-extend-protocol-loop ctx protocol protocol-name type-name (cdr methods)))))

(defun codegen-extend-protocol (ctx: ptr form: ptr) -> ptr
  (let ((protocol (protocol-base (cg-syms ctx) (cadr form)))
        (protocol-name (protocol-mangled (cg-syms ctx) (cadr form)))
        (type-name (caddr form))
        (methods (cdddr form))
        (ctx (cg-add-type-protocol ctx type-name protocol-name))
        (ctx (codegen-extend-protocol-loop ctx protocol protocol-name type-name methods)))
    (pcons ctx nil)))

(defun codegen-extend-protocol-default-loop (ctx: ptr target: ptr target-name: ptr source-name: ptr methods: ptr) -> ptr
  (if (nil? methods)
      ctx
      (let ((method-form (car methods))
            (method-name (car method-form))
            (params (cadr method-form))
            (body (caddr method-form))
            (fn-name (make-default-fn-name (cg-syms ctx) target-name source-name method-name))
            (entry (proto-methods-find (cg-proto-methods ctx) method-name target))
            (ret-ty (if (nil? entry) nil (proto-method-ret entry)))
            (result (codegen-protocol-method ctx fn-name params body ret-ty))
            (ctx (pcons-head result))
            (info (pcons-tail result))
            (inferred (pcons-tail info))
            (ctx (if (and (nil? ret-ty) (not (nil? inferred)))
                     (cg-update-proto-method-ret ctx method-name target inferred)
                     ctx))
            (ctx (cg-register-proto-default ctx target source-name method-name fn-name)))
        (codegen-extend-protocol-default-loop ctx target target-name source-name (cdr methods)))))

(defun codegen-extend-protocol-default (ctx: ptr form: ptr) -> ptr
  (let ((target (protocol-base (cg-syms ctx) (cadr form)))
        (target-name (protocol-mangled (cg-syms ctx) (cadr form)))
        (source-name (protocol-mangled (cg-syms ctx) (caddr form)))
        (methods (cdddr form))
        (ctx (codegen-extend-protocol-default-loop ctx target target-name source-name methods)))
    (pcons ctx nil)))

;; Protocol dispatch helpers
(defun find-protocol-for-method (entries: ptr method: ptr) -> ptr
  (if (nil? entries)
      nil
      (let ((entry (pcons-head entries)))
        (if (= 1 (sym-eq? (proto-method-name entry) method))
            (proto-method-protocol entry)
            (find-protocol-for-method (pcons-tail entries) method)))))

(defun dispatch-entry (type-id: i64 fn-name: ptr) -> ptr
  (pcons (box-int type-id) fn-name))

(defun dispatch-entry-type-id (entry: ptr) -> i64
  (unbox-int (pcons-head entry)))

(defun dispatch-entry-fn (entry: ptr) -> ptr
  (pcons-tail entry))

(defun type-has-direct-impl? (ctx: ptr protocol: ptr method: ptr type-name: ptr) -> i64
  (type-has-direct-impl-loop (cg-proto-impls ctx) protocol method type-name))

(defun type-has-direct-impl-loop (entries: ptr protocol: ptr method: ptr type-name: ptr) -> i64
  (if (nil? entries)
      0
      (let ((entry (pcons-head entries)))
        (if (and (= 1 (sym-eq? (proto-impl-protocol entry) protocol))
                 (and (= 1 (sym-eq? (proto-impl-method entry) method))
                      (= 1 (sym-eq? (proto-impl-type entry) type-name))))
            1
            (type-has-direct-impl-loop (pcons-tail entries) protocol method type-name)))))

(defun collect-direct-impls (ctx: ptr protocol: ptr method: ptr entries: ptr acc: ptr) -> ptr
  (if (nil? entries)
      (reverse-pcons acc)
      (let ((entry (pcons-head entries)))
        (if (and (= 1 (sym-eq? (proto-impl-protocol entry) protocol))
                 (= 1 (sym-eq? (proto-impl-method entry) method)))
            (let ((type-name (proto-impl-type entry))
                  (struct-info (cg-lookup-struct ctx type-name)))
              (if (nil? struct-info)
                  (collect-direct-impls ctx protocol method (pcons-tail entries) acc)
                  (let ((type-id (struct-entry-type-id struct-info))
                        (dispatch (dispatch-entry type-id (proto-impl-fn entry))))
                    (collect-direct-impls ctx protocol method (pcons-tail entries) (pcons dispatch acc)))))
            (collect-direct-impls ctx protocol method (pcons-tail entries) acc)))))

(defun collect-default-for-source (ctx: ptr protocol: ptr method: ptr source: ptr fn-name: ptr entries: ptr acc: ptr) -> ptr
  (if (nil? entries)
      acc
      (let ((entry (pcons-head entries))
            (type-name (type-proto-name entry))
            (protocols (type-proto-list entry)))
        (if (and (= 1 (proto-list-has? protocols source))
                 (= 0 (type-has-direct-impl? ctx protocol method type-name)))
            (let ((struct-info (cg-lookup-struct ctx type-name)))
              (if (nil? struct-info)
                  (collect-default-for-source ctx protocol method source fn-name (pcons-tail entries) acc)
                  (let ((type-id (struct-entry-type-id struct-info))
                        (dispatch (dispatch-entry type-id fn-name)))
                    (collect-default-for-source ctx protocol method source fn-name (pcons-tail entries) (pcons dispatch acc)))))
            (collect-default-for-source ctx protocol method source fn-name (pcons-tail entries) acc)))))

(defun collect-default-impls (ctx: ptr protocol: ptr method: ptr defaults: ptr acc: ptr) -> ptr
  (if (nil? defaults)
      (reverse-pcons acc)
      (let ((entry (pcons-head defaults)))
        (if (and (= 1 (sym-eq? (proto-default-target entry) protocol))
                 (= 1 (sym-eq? (proto-default-method entry) method)))
            (let ((source (proto-default-source entry))
                  (fn-name (proto-default-fn entry))
                  (acc (collect-default-for-source ctx protocol method source fn-name (cg-type-protocols ctx) acc)))
              (collect-default-impls ctx protocol method (pcons-tail defaults) acc))
            (collect-default-impls ctx protocol method (pcons-tail defaults) acc)))))

(defun build-protocol-dispatch (ctx: ptr entries: ptr type-id-v: ptr args: ptr ret-ty: ptr default-expr: ptr) -> ptr
  (if (nil? entries)
      (pcons ctx default-expr)
      (let ((entry (pcons-head entries))
            (rest (pcons-tail entries))
            (syms (cg-syms ctx))
            (type-id (dispatch-entry-type-id entry))
            (fn-name (dispatch-entry-fn entry))
            (cond-v (lir-icmp syms (sym-eq syms) type-id-v (lir-int syms type-id)))
            (then-v (lir-call syms fn-name (scons (lir-null syms) args)))
            (else-result (build-protocol-dispatch ctx rest type-id-v args ret-ty default-expr))
            (ctx (pcons-head else-result))
            (else-v (pcons-tail else-result)))
        (pcons ctx (lir-select syms cond-v then-v else-v)))))

(defun codegen-protocol-call (ctx: ptr method: ptr args: ptr protocol: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (self-form (car args))
        (rest-args (cdr args))
        (self-result (codegen-expr ctx self-form))
        (ctx (pcons-head self-result))
        (self-v (pcons-tail self-result))
        (args-result (codegen-args-list ctx rest-args nil))
        (ctx (pcons-head args-result))
        (rest-v (pcons-tail args-result))
        (args-v (scons self-v rest-v))
        (type-id-v (lir-load syms (sym-i64 syms) self-v))
        (direct (collect-direct-impls ctx protocol method (cg-proto-impls ctx) nil))
        (defaults (collect-default-impls ctx protocol method (cg-proto-defaults ctx) nil))
        (entries (append-pcons direct defaults))
        (entry (proto-methods-find (cg-proto-methods ctx) method protocol))
        (ret-ty (if (nil? entry)
                    (sym-i64 syms)
                    (let ((ret (proto-method-ret entry)))
                      (if (nil? ret) (sym-i64 syms) ret)))))
    (if (= 1 (sym-eq? ret-ty (sym-ptr syms)))
        (build-protocol-dispatch ctx entries type-id-v args-v ret-ty (lir-null syms))
        (build-protocol-dispatch ctx entries type-id-v args-v ret-ty (lir-int syms 0)))))

;; Indirect calls for closure values (assume ptr return for now)
(defun codegen-indirect-call (ctx: ptr fn-sym: ptr args: ptr) -> ptr
  (let ((args-result (codegen-args ctx args nil))
        (ctx (pcons-head args-result))
        (args-rev (pcons-tail args-result))
        (args-v (reverse-scons args-rev))
        (syms (cg-syms ctx))
        (ret-ty (sym-ptr syms)))
    (pcons ctx (lir-indirect-call syms fn-sym ret-ty args-v))))

(defun codegen-indirect-call-expr (ctx: ptr fn-expr: ptr args: ptr) -> ptr
  (let ((fn-result (codegen-expr ctx fn-expr))
        (ctx (pcons-head fn-result))
        (fn-v (pcons-tail fn-result)))
    (codegen-indirect-call ctx fn-v args)))

;; ============================================================
;; If Expression (with proper branching)
;; ============================================================

;; Infer a simple lIR return type (ptr or i64) from an expression
(defun last-expr (forms: ptr) -> ptr
  (if (nil? forms)
      nil
      (if (nil? (cdr forms))
          (car forms)
          (last-expr (cdr forms)))))

(defun lir-let-body (expr: ptr) -> ptr
  (last-expr (cddr expr)))

(defun lir-expr-ret-type (ctx: ptr expr: ptr) -> ptr
  (let ((syms (cg-syms ctx)))
    (cond
      ((nil? expr) (sym-i64 syms))
      ((boxed-int? expr) (sym-i64 syms))
      ((symbol? expr) (sym-i64 syms))  ;; unknown symbol defaults to i64
      ((scons? expr)
       (let ((head (car expr)))
         (cond
           ((sym-eq? head (sym-ptr syms)) (sym-ptr syms))
           ((sym-eq? head (sym-i1 syms)) (sym-i1 syms))
           ((sym-eq? head (sym-i64 syms)) (sym-i64 syms))
           ((sym-eq? head (sym-double syms)) (sym-double syms))
           ((sym-eq? head (sym-string syms)) (sym-ptr syms))
           ((sym-eq? head (sym-heap-struct syms)) (sym-ptr syms))
           ((sym-eq? head (sym-alloca syms)) (sym-ptr syms))
           ((sym-eq? head (sym-array-alloc syms)) (sym-ptr syms))
           ((sym-eq? head (sym-heap-array syms)) (sym-ptr syms))
           ((sym-eq? head (sym-heap-array-dyn syms)) (sym-ptr syms))
           ((sym-eq? head (sym-ptr-array-alloc syms)) (sym-ptr syms))
           ((sym-eq? head (sym-ptr-array-get syms)) (sym-ptr syms))
           ((sym-eq? head (sym-array-get syms)) (sym-i64 syms))
           ((sym-eq? head (sym-array-len syms)) (sym-i64 syms))
           ((sym-eq? head (sym-array-set syms)) (sym-i64 syms))
           ((sym-eq? head (sym-ptr-array-set syms)) (sym-i64 syms))
           ((sym-eq? head (sym-rc-alloc syms)) (sym-ptr syms))
           ((sym-eq? head (sym-rc-clone syms)) (sym-ptr syms))
           ((sym-eq? head (sym-rc-drop syms)) (sym-i64 syms))
           ((sym-eq? head (sym-drop syms)) (sym-i64 syms))
           ((sym-eq? head (sym-move syms)) (sym-i64 syms))
           ((sym-eq? head (sym-getelementptr syms)) (sym-ptr syms))
           ((sym-eq? head (sym-load syms)) (cadr expr))
           ((sym-eq? head (sym-indirect-call syms)) (caddr expr))
           ((sym-eq? head (sym-indirect-tailcall syms)) (caddr expr))
           ((sym-eq? head (sym-call syms)) (call-ret-type ctx (cadr expr)))
           ((sym-eq? head (sym-fadd syms)) (sym-double syms))
           ((sym-eq? head (sym-fsub syms)) (sym-double syms))
           ((sym-eq? head (sym-fmul syms)) (sym-double syms))
           ((sym-eq? head (sym-fdiv syms)) (sym-double syms))
           ((sym-eq? head (sym-frem syms)) (sym-double syms))
           ((sym-eq? head (sym-icmp syms)) (sym-i1 syms))
           ((sym-eq? head (sym-fcmp syms)) (sym-i1 syms))
           ((sym-eq? head (sym-and syms)) (sym-i64 syms))
           ((sym-eq? head (sym-or syms)) (sym-i64 syms))
           ((sym-eq? head (sym-xor syms)) (sym-i64 syms))
           ((sym-eq? head (sym-shl syms)) (sym-i64 syms))
           ((sym-eq? head (sym-lshr syms)) (sym-i64 syms))
           ((sym-eq? head (sym-ashr syms)) (sym-i64 syms))
           ((sym-eq? head (sym-ctpop syms)) (sym-i64 syms))
           ((sym-eq? head (sym-trunc syms)) (cadr expr))
           ((sym-eq? head (sym-zext syms)) (cadr expr))
           ((sym-eq? head (sym-sext syms)) (cadr expr))
           ((sym-eq? head (sym-fptosi syms)) (cadr expr))
           ((sym-eq? head (sym-fptoui syms)) (cadr expr))
           ((sym-eq? head (sym-sitofp syms)) (cadr expr))
           ((sym-eq? head (sym-uitofp syms)) (cadr expr))
           ((sym-eq? head (sym-fpext syms)) (cadr expr))
           ((sym-eq? head (sym-fptrunc syms)) (cadr expr))
           ((sym-eq? head (sym-let syms))
            (let ((binding (car (cadr expr)))
                  (name (car binding))
                  (val (cadr binding))
                  (body (lir-let-body expr)))
              (if (symbol? body)
                  (if (= 1 (sym-eq? body name))
                      (lir-expr-ret-type ctx val)
                      (lir-expr-ret-type ctx body))
                  (lir-expr-ret-type ctx body))))
           (else (sym-i64 syms)))))
      (else (sym-i64 syms)))))

(defun lir-merge-type (ctx: ptr a: ptr b: ptr) -> ptr
  (let ((syms (cg-syms ctx))
        (ta (lir-expr-ret-type ctx a))
        (tb (lir-expr-ret-type ctx b)))
    (if (= 1 (sym-eq? ta (sym-ptr syms)))
        (sym-ptr syms)
        (if (= 1 (sym-eq? tb (sym-ptr syms)))
            (sym-ptr syms)
            (sym-i64 syms)))))

(defun symbol-at-eq? (a: ptr b: ptr) -> i64
  (let ((aname (symbol-name a))
        (bname (symbol-name b)))
    (if (= (load-byte aname) 64)
        (if (streq (ptr+ aname 1) bname) 1 0)
        (if (streq aname bname) 1 0))))

(defun call-ret-type-loop (syms: ptr callee: ptr fns: ptr) -> ptr
  (if (nil? fns)
      (sym-i64 syms)
      (let ((fn-def (car fns))
            (sig (cadr fn-def))
            (fn-name (car sig))
            (ret-ty (cadr sig)))
        (if (= 1 (symbol-at-eq? callee fn-name))
            ret-ty
            (call-ret-type-loop syms callee (cdr fns))))))

(defun call-ret-type (ctx: ptr callee: ptr) -> ptr
  (call-ret-type-loop (cg-syms ctx) callee (cg-fns ctx)))

(defun fn-defs-since (fns: ptr base: ptr) -> ptr
  (if (nil? fns)
      nil
      (if (= fns base)
          nil
          (scons (car fns) (fn-defs-since (cdr fns) base)))))

(defun infer-defun-ret-type (has-ret: i64 ret-ty0: ptr fn-ctx: ptr body-v: ptr) -> ptr
  (if (= has-ret 1)
      ret-ty0
      (lir-expr-ret-type fn-ctx body-v)))

;; Emit if with explicit result type
(defun wrap-entry-lets (syms: ptr bindings: ptr body: ptr) -> ptr
  (if (nil? bindings)
      body
      (let ((binding (car bindings))
            (name (car binding))
            (val (cadr binding)))
        (lir-let1 syms name val (wrap-entry-lets syms (cdr bindings) body)))))

;; Emit if with explicit result type, optionally wrapping the entry block in lets.
(defun codegen-if-typed (ctx: ptr cond-v: ptr then-v: ptr else-v: ptr result-ty: ptr entry-binds: ptr) -> ptr
  (let ((syms (cg-syms ctx))

        ;; Generate unique block labels
        (then-result (cg-fresh-label ctx (str-then-prefix)))
        (ctx (pcons-head then-result))
        (then-lbl (pcons-tail then-result))

        (else-result (cg-fresh-label ctx (str-else-prefix)))
        (ctx (pcons-head else-result))
        (else-lbl (pcons-tail else-result))

        (merge-result (cg-fresh-label ctx (str-merge-prefix)))
        (ctx (pcons-head merge-result))
        (merge-lbl (pcons-tail merge-result))

        ;; Build entry block: (block entry (let ((a ...)) (br cond then else)))
        (entry-body (wrap-entry-lets syms entry-binds
                                     (lir-br-cond syms cond-v then-lbl else-lbl)))
        (entry-block (lir-block syms (sym-entry syms) (scons entry-body nil)))

        ;; Build then block
        (then-block (lir-block syms then-lbl
                               (scons (lir-let1 syms then-lbl then-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Build else block
        (else-block (lir-block syms else-lbl
                               (scons (lir-let1 syms else-lbl else-v
                                               (lir-br syms merge-lbl)) nil)))

        ;; Add blocks to context (reverse order so they emit correctly)
        (ctx (cg-add-block ctx else-block))
        (ctx (cg-add-block ctx then-block))
        (ctx (cg-add-block ctx entry-block))

        ;; Set merge label for defun to use
        (ctx (cg-set-merge-label ctx merge-lbl))

        ;; Build phi expression in merge block
        (phi-expr (lir-phi syms result-ty then-lbl then-lbl else-lbl else-lbl)))

    (pcons ctx phi-expr)))

;; Emit proper control flow using br/phi for short-circuit evaluation
;; This enables recursion to work correctly (unlike select which evaluates both branches)
;;
;; For (if cond then else), we generate:
;;   (block entry (br cond-v then-label else-label))
;;   (block then-label (let ((then-var then-v)) (br merge-label)))
;;   (block else-label (let ((else-var else-v)) (br merge-label)))
;;   (block merge-label (ret (phi i64 (then-label then-var) (else-label else-var))))
;;
;; The then-var/else-var let bindings ensure values are computed in their blocks
;; before being referenced by phi in the merge block.

(defun codegen-if (ctx: ptr form: ptr) -> ptr
  (let ((cond-result (codegen-expr ctx (cadr form)))
        (ctx (pcons-head cond-result))
        (cond-v (pcons-tail cond-result))
        (then-result (codegen-expr ctx (caddr form)))
        (ctx (pcons-head then-result))
        (then-v (pcons-tail then-result))
        (else-result (codegen-expr ctx (cadddr form)))
        (ctx (pcons-head else-result))
        (else-v (pcons-tail else-result))
        (result-ty (lir-merge-type ctx then-v else-v)))
    (codegen-if-typed ctx cond-v then-v else-v result-ty nil)))

;; ============================================================
;; Let Bindings
;; ============================================================

(defun codegen-let-body (ctx: ptr bindings: ptr body: ptr) -> ptr
  (if (nil? bindings)
      (codegen-expr ctx body)
      (let ((binding (car bindings))
            (name (car binding))
            (val-form (cadr binding))
            (rest (cdr bindings)))
        (if (scons? name)
            (codegen-let-destructure ctx name val-form rest body)
            (let ((val-result (codegen-expr ctx val-form))
                  (ctx (pcons-head val-result))
                  (val-v (pcons-tail val-result))
                  (env (cg-env ctx))
                  (env (env-define-scons env (binding-names binding)))
                  (ctx (cg-set-env ctx env))
                  (rest-result (codegen-let-body ctx rest body))
                  (ctx (pcons-head rest-result))
                  (rest-v (pcons-tail rest-result))
                  (syms (cg-syms ctx)))
              (pcons ctx (lir-let1 syms name val-v rest-v)))))))

(defun codegen-let-bindings (ctx: ptr bindings: ptr acc: ptr) -> ptr
  (if (nil? bindings)
      (pcons ctx (reverse-scons acc))
      (let ((binding (car bindings))
            (name (car binding))
            (val-form (cadr binding))
            (val-result (codegen-expr ctx val-form))
            (ctx (pcons-head val-result))
            (val-v (pcons-tail val-result))
            (pair (scons name (scons val-v nil))))
        (codegen-let-bindings ctx (cdr bindings) (scons pair acc)))))

(defun build-field-lets (ctx: ptr tmp-name: ptr fields: ptr struct-info: ptr body-v: ptr) -> ptr
  (if (nil? fields)
      (pcons ctx body-v)
      (let ((field-name (car fields))
            (field-result (codegen-field-access-found ctx tmp-name field-name struct-info))
            (ctx (pcons-head field-result))
            (field-v (pcons-tail field-result))
            (rest-result (build-field-lets ctx tmp-name (cdr fields) struct-info body-v))
            (ctx (pcons-head rest-result))
            (rest-v (pcons-tail rest-result))
            (syms (cg-syms ctx)))
        (pcons ctx (lir-let1 syms field-name field-v rest-v)))))

(defun codegen-let-destructure (ctx: ptr pattern: ptr val-form: ptr rest-bindings: ptr body: ptr) -> ptr
  (let ((struct-name (car pattern))
        (fields (cdr pattern))
        (struct-info (cg-lookup-struct ctx struct-name)))
    (if (nil? struct-info)
        (codegen-let-body ctx (scons (scons pattern (scons val-form nil)) rest-bindings) body)
        (let ((val-result (codegen-expr ctx val-form))
              (ctx (pcons-head val-result))
              (val-v (pcons-tail val-result))
              (tmp-result (cg-next-temp-name ctx))
              (ctx (pcons-head tmp-result))
              (tmp-name (pcons-tail tmp-result))
              (env (cg-env ctx))
              (env (env-define-scons env fields))
              (ctx (cg-set-env ctx env))
              (rest-result (codegen-let-body ctx rest-bindings body))
              (ctx (pcons-head rest-result))
              (rest-v (pcons-tail rest-result))
              (field-result (build-field-lets ctx tmp-name fields struct-info rest-v))
              (ctx (pcons-head field-result))
              (field-v (pcons-tail field-result))
              (syms (cg-syms ctx)))
          (pcons ctx (lir-let1 syms tmp-name val-v field-v))))))

;; Tail-position let destructuring.
(defun codegen-let-destructure-tail (ctx: ptr pattern: ptr val-form: ptr rest-bindings: ptr body: ptr) -> ptr
  (let ((struct-name (car pattern))
        (fields (cdr pattern))
        (struct-info (cg-lookup-struct ctx struct-name)))
    (if (nil? struct-info)
        (codegen-let-body-tail ctx (scons (scons pattern (scons val-form nil)) rest-bindings) body)
        (let ((val-result (codegen-expr ctx val-form))
              (ctx (pcons-head val-result))
              (val-v (pcons-tail val-result))
              (tmp-result (cg-next-temp-name ctx))
              (ctx (pcons-head tmp-result))
              (tmp-name (pcons-tail tmp-result))
              (env (cg-env ctx))
              (env (env-define-scons env fields))
              (ctx (cg-set-env ctx env))
              (rest-result (codegen-let-body-tail ctx rest-bindings body))
              (ctx (pcons-head rest-result))
              (rest-v (pcons-tail rest-result))
              (field-result (build-field-lets ctx tmp-name fields struct-info rest-v))
              (ctx (pcons-head field-result))
              (field-v (pcons-tail field-result))
              (syms (cg-syms ctx)))
          (pcons ctx (lir-let1 syms tmp-name val-v field-v))))))

(defun codegen-let-if (ctx: ptr bindings: ptr body: ptr) -> ptr
  (let ((bind-result (codegen-let-bindings ctx bindings nil))
        (ctx (pcons-head bind-result))
        (binds (pcons-tail bind-result))
        (cond-result (codegen-expr ctx (cadr body)))
        (ctx (pcons-head cond-result))
        (cond-v (pcons-tail cond-result))
        (then-result (codegen-expr ctx (caddr body)))
        (ctx (pcons-head then-result))
        (then-v (pcons-tail then-result))
        (else-result (codegen-expr ctx (cadddr body)))
        (ctx (pcons-head else-result))
        (else-v (pcons-tail else-result))
        (result-ty (lir-merge-type ctx then-v else-v)))
    (codegen-if-typed ctx cond-v then-v else-v result-ty binds)))

(defun codegen-let (ctx: ptr form: ptr) -> ptr
  (let ((bindings (cadr form))
        (body (caddr form))
        (syms (cg-syms ctx)))
    (if (scons? body)
        (if (symbol? (car body))
            (if (streq (symbol-base-name syms (car body)) (str-if))
                (codegen-let-if ctx bindings body)
                (codegen-let-body ctx bindings body))
            (codegen-let-body ctx bindings body))
        (codegen-let-body ctx bindings body))))

;; Tail-position let body.
(defun codegen-let-body-tail (ctx: ptr bindings: ptr body: ptr) -> ptr
  (if (nil? bindings)
      (codegen-expr-tail ctx body)
      (let ((binding (car bindings))
            (name (car binding))
            (val-form (cadr binding))
            (rest (cdr bindings)))
        (if (scons? name)
            (codegen-let-destructure-tail ctx name val-form rest body)
            (let ((val-result (codegen-expr ctx val-form))
                  (ctx (pcons-head val-result))
                  (val-v (pcons-tail val-result))
                  (env (cg-env ctx))
                  (env (env-define-scons env (binding-names binding)))
                  (ctx (cg-set-env ctx env))
                  (rest-result (codegen-let-body-tail ctx rest body))
                  (ctx (pcons-head rest-result))
                  (rest-v (pcons-tail rest-result))
                  (syms (cg-syms ctx)))
              (pcons ctx (lir-let1 syms name val-v rest-v)))))))

(defun codegen-let-tail (ctx: ptr form: ptr) -> ptr
  (let ((bindings (cadr form))
        (body (caddr form))
        (syms (cg-syms ctx)))
    (if (scons? body)
        (if (symbol? (car body))
            (if (streq (symbol-base-name syms (car body)) (str-if))
                (codegen-let-if ctx bindings body)
                (codegen-let-body-tail ctx bindings body))
            (codegen-let-body-tail ctx bindings body))
        (codegen-let-body-tail ctx bindings body))))

;; ============================================================
;; Do Block
;; ============================================================

(defun codegen-do-loop (ctx: ptr exprs: ptr last-v: ptr) -> ptr
  (if (nil? exprs)
      (pcons ctx last-v)
      (let ((result (codegen-expr ctx (car exprs)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-do-loop ctx (cdr exprs) v))))

(defun codegen-do (ctx: ptr form: ptr) -> ptr
  (codegen-do-loop ctx (cdr form) (box-int 0)))

;; Tail-position do: only the last expression is eligible for tailcall.
(defun codegen-do-loop-tail (ctx: ptr exprs: ptr) -> ptr
  (if (nil? exprs)
      (pcons ctx (box-int 0))
      (if (nil? (cdr exprs))
          (codegen-expr-tail ctx (car exprs))
          (let ((result (codegen-expr ctx (car exprs)))
                (ctx (pcons-head result)))
            (codegen-do-loop-tail ctx (cdr exprs))))))

(defun codegen-do-tail (ctx: ptr form: ptr) -> ptr
  (codegen-do-loop-tail ctx (cdr form)))

;; ============================================================
;; Function Call
;; ============================================================

(defun codegen-args (ctx: ptr args: ptr acc: ptr) -> ptr
  (if (nil? args)
      (pcons ctx acc)
      (let ((result (codegen-expr ctx (car args)))
            (ctx (pcons-head result))
            (v (pcons-tail result)))
        (codegen-args ctx (cdr args) (scons v acc)))))

(defun codegen-call (ctx: ptr form: ptr) -> ptr
  (let ((head (car form))
        (args (cdr form))
        (syms (cg-syms ctx)))
    (if (symbol? head)
        (let ((protocol (find-protocol-for-method (cg-proto-methods ctx) head)))
          (if (nil? protocol)
              (if (= 1 (env-defined? (cg-env ctx) (symbol-id head)))
                  ;; Local variable (closure) - indirect call
                  (codegen-indirect-call-expr ctx head args)
                  ;; Function call - may be local or from required module
                  (let ((args-result (codegen-args ctx args nil))
                        (ctx (pcons-head args-result))
                        (args-rev (pcons-tail args-result))
                        (args-v (reverse-scons args-rev))
                        (args-v (scons (lir-null syms) args-v)))
                    (pcons ctx (lir-call syms head args-v))))
              (codegen-protocol-call ctx head args protocol)))
        (codegen-indirect-call-expr ctx head args))))

;; ============================================================
;; Function Definition
;; ============================================================

;; Get the nth element of a list (0-indexed)
(defun list-nth (lst: ptr n: i64) -> ptr
  (if (<= n 0)
      (car lst)
      (list-nth (cdr lst) (- n 1))))

;; Check if symbol is ->
(defun is-arrow-sym? (sym: ptr) -> i64
  (if (symbol? sym)
      (let ((name (symbol-name sym)))
        (if (= (load-byte name) 45)           ;; '-'
            (if (= (load-byte (ptr+ name 1)) 62) 1 0)
            0))
      0))

;; Check if element at index 3 is the arrow symbol ->
(defun has-return-type? (form: ptr) -> i64
  (let ((elem3 (list-nth form 3)))
    (is-arrow-sym? elem3)))

;; Map a type symbol to an lIR type symbol
(defun type-sym-to-lir (syms: ptr type-sym: ptr) -> ptr
  (if (nil? type-sym)
      (sym-i64 syms)
      (if (symbol? type-sym)
          (if (= 1 (sym-eq? type-sym (sym-ptr syms)))
              (sym-ptr syms)
              (if (= 1 (sym-eq? type-sym (sym-double syms)))
                  (sym-double syms)
                  (if (= 1 (sym-eq? type-sym (sym-float syms)))
                      (sym-float syms)
                      (if (= 1 (sym-eq? type-sym (sym-i1 syms)))
                          (sym-i1 syms)
                          (if (= 1 (sym-eq? type-sym (sym-i8 syms)))
                              (sym-i8 syms)
                              (if (= 1 (sym-eq? type-sym (sym-i16 syms)))
                                  (sym-i16 syms)
                                  (if (= 1 (sym-eq? type-sym (sym-i32 syms)))
                                      (sym-i32 syms)
                                      (if (= 1 (sym-eq? type-sym (sym-string syms)))
                                          (sym-ptr syms)
                                          (sym-i64 syms)))))))))
          (sym-i64 syms))))

;; Extract function body from defun form
(defun get-defun-body (form: ptr) -> ptr
  (if (= (has-return-type? form) 1)
      (list-nth form 5)
      (cadddr form)))

;; Extract return type symbol (defaults to i64)
(defun get-defun-return-type (syms: ptr form: ptr) -> ptr
  (if (= (has-return-type? form) 1)
      (type-sym-to-lir syms (list-nth form 4))
      (sym-i64 syms)))

;; Collect parameter names (handles typed and untyped params)
(defun collect-param-names (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      (reverse-pcons acc)
      (let ((name (car lst))
            (rest (cdr lst)))
        (if (nil? rest)
            (reverse-pcons (pcons name acc))
            (let ((maybe-colon (car rest)))
              (if (= 1 (is-arrow-sym? maybe-colon))
                  (reverse-pcons (pcons name acc))
                  (if (= 1 (symbol-name-match? maybe-colon (str-colon)))
                      (collect-param-names (cdr (cdr rest)) (pcons name acc))
                      (collect-param-names rest (pcons name acc)))))))))

;; Check if param symbol is used in call position
(defun callable-has? (lst: ptr sym: ptr) -> i64
  (if (nil? lst)
      0
      (if (= 1 (sym-eq? (pcons-head lst) sym))
          1
          (callable-has? (pcons-tail lst) sym))))

(defun add-callable (lst: ptr sym: ptr) -> ptr
  (if (= 1 (callable-has? lst sym))
      lst
      (pcons sym lst)))

(defun find-callables-in-list (exprs: ptr params: ptr acc: ptr) -> ptr
  (if (nil? exprs)
      acc
      (let ((acc2 (find-callables-in-expr (car exprs) params acc)))
        (find-callables-in-list (cdr exprs) params acc2))))

(defun find-callables-in-expr (expr: ptr params: ptr acc: ptr) -> ptr
  (if (nil? expr)
      acc
      (if (scons? expr)
          (let ((head (car expr)))
            (let ((tail (cdr expr)))
              (if (symbol? head)
                  (if (= 1 (callable-has? params head))
                      (let ((acc2 (add-callable acc head)))
                        (let ((acc3 (find-callables-in-expr head params acc2)))
                          (find-callables-in-list tail params acc3)))
                      (let ((acc2 (find-callables-in-expr head params acc)))
                        (find-callables-in-list tail params acc2)))
                  (let ((acc2 (find-callables-in-expr head params acc)))
                    (find-callables-in-list tail params acc2)))))
          acc)))

(defun find-callable-params (params: ptr body: ptr) -> ptr
  (let ((param-names (collect-param-names params nil)))
    (find-callables-in-expr body param-names nil)))

;; Transform params from (name : type name : type) to ((type name) (type name))
;; Untyped params default to i64, or ptr when used in call position
(defun param-type-to-lir (ctx: ptr syms: ptr typ: ptr) -> ptr
  (if (nil? typ)
      (sym-i64 syms)
      (if (symbol? typ)
          (let ((struct-info (cg-lookup-struct ctx typ)))
            (if (nil? struct-info)
                (type-sym-to-lir syms typ)
                (sym-ptr syms)))
          (sym-i64 syms))))

(defun transform-params (ctx: ptr syms: ptr lst: ptr acc: ptr callable: ptr) -> ptr
  (if (nil? lst)
      (reverse-scons acc)
      ;; lst is: name : type rest...
      (let ((name (car lst))
            (rest (cdr lst)))  ;; should be (: type rest...)
        (if (nil? rest)
            (let ((typ (if (= 1 (callable-has? callable name)) (sym-ptr syms) (sym-i64 syms)))
                  (pair (scons typ (scons name nil))))
              (reverse-scons (scons pair acc)))
            (let ((colon (car rest))
                  (rest2 (cdr rest)))  ;; should be (type rest...)
              (if (= 1 (symbol-name-match? colon (str-colon)))
                  (if (nil? rest2)
                      (reverse-scons acc)  ;; malformed
                      (let ((typ (car rest2))
                            (rest3 (cdr rest2))
                            (lir-typ (param-type-to-lir ctx syms typ))
                            (pair (scons lir-typ (scons name nil))))
                        (transform-params ctx syms rest3 (scons pair acc) callable)))
                  (let ((typ (if (= 1 (callable-has? callable name)) (sym-ptr syms) (sym-i64 syms)))
                        (pair (scons typ (scons name nil))))
                    (transform-params ctx syms rest (scons pair acc) callable))))))))

;; Build the list of blocks for a function with branching
;; Blocks are already in correct order [entry, then, else], just append merge
(defun build-function-blocks (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (let ((merge-block (lir-block syms merge-lbl
                                (build-terminator syms body-v))))
    ;; Append merge block to the end
    (append-scons blocks (scons merge-block nil))))

;; Append two scons lists
(defun append-scons (lst1: ptr lst2: ptr) -> ptr
  (if (nil? lst1)
      lst2
      (scons (car lst1) (append-scons (cdr lst1) lst2))))

;; Helper to build function body based on whether there are blocks
(defun tailcall-expr? (expr: ptr) -> i64
  (if (scons? expr)
      (let ((head (car expr)))
        (if (symbol? head)
            (let ((name (symbol-name head)))
              (if (= 1 (streq name (str-tailcall)))
                  1
                  (if (= 1 (streq name (str-indirect-tailcall))) 1 0)))
            0))
      0))

(defun build-terminator (syms: ptr body-v: ptr) -> ptr
  (if (= 1 (tailcall-expr? body-v))
      (scons body-v nil)
      (scons (lir-ret syms body-v) nil)))

(defun build-fn-body (syms: ptr blocks: ptr merge-lbl: ptr body-v: ptr) -> ptr
  (if (nil? blocks)
      ;; No branching: simple single-block function
      (scons (scons (sym-block syms)
                    (scons (sym-entry syms)
                           (build-terminator syms body-v)))
             nil)
      ;; Has branching: use accumulated blocks + merge block
      (build-function-blocks syms blocks merge-lbl body-v)))

;; ============================================================
;; Lambda Helpers
;; ============================================================

(defun build-lambda-params (syms: ptr params: ptr acc: ptr) -> ptr
  (if (nil? params)
      (reverse-scons acc)
      (let ((param (car params))
            (pair (scons (sym-ptr syms) (scons param nil))))
        (build-lambda-params syms (cdr params) (scons pair acc)))))

(defun append-digit (buf: ptr idx n: i64) -> i64
  (do (store-byte (ptr+ buf idx) (+ 48 (rem n 10)))
      (+ idx 1)))

(defun int-to-buf-loop (buf: ptr idx n: i64) -> i64
  (if (< n 10)
      (append-digit buf idx n)
      (let ((idx2 (int-to-buf-loop buf idx (/ n 10))))
        (append-digit buf idx2 (rem n 10)))))

(defun gensym-lambda (syms: ptr counter: i64) -> ptr
  (let ((buf (heap-array 20)))
    (do
      ;; __lambda_
      (store-byte buf 95)           ;; _
      (store-byte (ptr+ buf 1) 95)  ;; _
      (store-byte (ptr+ buf 2) 108) ;; l
      (store-byte (ptr+ buf 3) 97)  ;; a
      (store-byte (ptr+ buf 4) 109) ;; m
      (store-byte (ptr+ buf 5) 98)  ;; b
      (store-byte (ptr+ buf 6) 100) ;; d
      (store-byte (ptr+ buf 7) 97)  ;; a
      (store-byte (ptr+ buf 8) 95)  ;; _
      (let ((end (int-to-buf-loop buf 9 counter)))
        (do (store-byte (ptr+ buf end) 0)
            (intern syms buf))))))

(defun gensym-temp (syms: ptr counter: i64) -> ptr
  (let ((buf (heap-array 20)))
    (do
      ;; __tmp_
      (store-byte buf 95)           ;; _
      (store-byte (ptr+ buf 1) 95)  ;; _
      (store-byte (ptr+ buf 2) 116) ;; t
      (store-byte (ptr+ buf 3) 109) ;; m
      (store-byte (ptr+ buf 4) 112) ;; p
      (store-byte (ptr+ buf 5) 95)  ;; _
      (let ((end (int-to-buf-loop buf 6 counter)))
        (do (store-byte (ptr+ buf end) 0)
            (intern syms buf))))))

(defun cg-next-closure-name (ctx: ptr) -> ptr
  (let ((counter (cg-closure-counter ctx))
        (syms (cg-syms ctx))
        (name (gensym-lambda syms counter))
        (ctx (share (CodegenCtx (cg-temp ctx) (cg-syms ctx) (cg-env ctx) (cg-fns ctx)
                                (cg-block-counter ctx) (cg-blocks ctx) (cg-merge-label ctx)
                                (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                                (+ counter 1)))))
    (pcons ctx name)))

(defun cg-next-temp-name (ctx: ptr) -> ptr
  (let ((counter (cg-temp ctx))
        (syms (cg-syms ctx))
        (name (gensym-temp syms counter))
        (ctx (cg-next-temp ctx)))
    (pcons ctx name)))

(defun codegen-defun (ctx: ptr form: ptr) -> ptr
  ;; (defun name (params) body) OR (defun name (params) -> type body)
  (let ((name (cadr form))
        (has-ret (has-return-type? form))
        (raw-params (normalize-param-list (caddr form)))
        (body (get-defun-body form))
        (callable (find-callable-params raw-params body))
        (lir-params (transform-params ctx (cg-syms ctx) raw-params nil callable))
        (ret-ty0 (get-defun-return-type (cg-syms ctx) form))
        (syms (cg-syms ctx))
        (lir-params (scons (lir-env-param syms) lir-params))
        ;; Reset temp and block counters for function body
        (outer-fns (cg-fns ctx))
        (param-names (collect-param-names raw-params nil))
        (fn-env (make-scope (cg-env ctx)))
        (fn-env (env-define-pcons fn-env param-names))
        (fn-ctx (share (CodegenCtx 0 syms fn-env outer-fns 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                   (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                   (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                                   (cg-closure-counter ctx))))
        (fn-ctx (cg-add-fn-name fn-ctx name))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        (body-v (promote-tailcall syms body-v))
        (ret-ty (infer-defun-ret-type has-ret ret-ty0 fn-ctx body-v))
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        ;; Build function signature: (name return-type)
        (fn-sig (scons name (scons ret-ty nil)))
        ;; Build function body - call helper to avoid if in let binding
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        ;; Build complete function definition
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        (inner-fns (fn-defs-since (cg-fns fn-ctx) outer-fns)))
    ;; Add nested fns first, then this function.
    (let ((ctx (cg-merge-errors ctx fn-ctx)))
      (let ((ctx (cg-merge-fn-defs ctx inner-fns)))
        (let ((ctx (cg-add-fn-def ctx name fn-def)))
          (pcons ctx fn-def))))))

;; Lambda - stub for now
(defun codegen-fn (ctx: ptr form: ptr) -> ptr
  (let ((params (normalize-param-list (cadr form)))
        (body (caddr form))
        (name-result (cg-next-closure-name ctx))
        (ctx (pcons-head name-result))
        (fn-name (pcons-tail name-result))
        (syms (cg-syms ctx))
        (lir-params (build-lambda-params syms params nil))
        (lir-params (scons (lir-env-param syms) lir-params))
        (outer-fns (cg-fns ctx))
        (param-names (collect-param-names params nil))
        (fn-env (make-scope (cg-env ctx)))
        (fn-env (env-define-pcons fn-env param-names))
        (fn-ctx (share (CodegenCtx 0 syms fn-env outer-fns 0 nil nil (cg-structs ctx) (cg-type-id ctx) (cg-struct-defs ctx)
                                   (cg-fn-names ctx) (cg-proto-methods ctx) (cg-proto-impls ctx)
                                   (cg-proto-defaults ctx) (cg-type-protocols ctx) (cg-errors ctx)
                                   (cg-closure-counter ctx))))
        (body-result (codegen-expr fn-ctx body))
        (fn-ctx (pcons-head body-result))
        (body-v (pcons-tail body-result))
        (blocks (cg-blocks fn-ctx))
        (merge-lbl (cg-merge-label fn-ctx))
        (ret-ty (lir-expr-ret-type fn-ctx body-v))
        (fn-sig (scons fn-name (scons ret-ty nil)))
        (fn-body (build-fn-body syms blocks merge-lbl body-v))
        (fn-def (scons (sym-define syms)
                       (scons fn-sig
                              (scons lir-params fn-body))))
        (fn-ptr (prepend-at syms (symbol-name fn-name)))
        (inner-fns (fn-defs-since (cg-fns fn-ctx) outer-fns)))
    (let ((ctx (cg-merge-errors ctx fn-ctx)))
      (let ((ctx (cg-merge-fn-defs ctx inner-fns)))
        (let ((ctx (cg-add-fn-def ctx fn-name fn-def)))
          (pcons ctx fn-ptr))))))

;; ============================================================
;; Top-Level
;; ============================================================

(defun codegen-toplevel (ctx: ptr forms: ptr) -> ptr
  (if (nil? forms)
      ctx
      (let ((result (codegen-expr ctx (car forms)))
            (ctx (pcons-head result)))
        (codegen-toplevel ctx (cdr forms)))))

(defun codegen-module (forms: ptr syms: ptr) -> ptr
  (let ((ctx (make-codegen-ctx syms))
        (ctx (codegen-toplevel ctx forms))
        (struct-defs (cg-struct-defs ctx))
        (fn-defs (cg-fns ctx))
        (errors (cg-errors ctx)))
    (if (> errors 0)
        nil
        ;; Combine struct defs and function defs, prepend needed declares.
        (let ((module-forms (append-scons (reverse-scons struct-defs) fn-defs)))
          (scons (lir-declare-printf syms) module-forms)))))
