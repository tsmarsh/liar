#!/bin/bash

# Ensure moth is initialized
if [ ! -d ".moth" ]; then
    moth init
fi

# =============================================================================
# MOTH 0: Coding Standards
# =============================================================================
moth new "Establish coding standards for liar" -s high --stdin << 'EOF'
## Summary

Establish and document coding standards to keep files manageable for agents.

## File Size Limits

| Metric | Limit | Action if exceeded |
|--------|-------|-------------------|
| Lines per file | 500 | Split into modules |
| Functions per file | 15 | Split by responsibility |
| Lines per function | 50 | Extract helpers |
| Nesting depth | 3 | Flatten or extract |

## Key Rules

### One Responsibility Per File
If you need section comments like `// ========== SECTION ==========` to navigate, split the file.

### No Thread-Local State for Pass Data
Bad:
```rust
thread_local! {
    static CAPTURED_VARS: RefCell<HashMap<...>> = ...
}
```

Good:
```rust
struct AnalysisContext {
    captured_vars: HashMap<...>,
}
```

### Passes Take and Return Data
Bad:
```rust
fn analyze(program: &Program) {
    // mutates global state
}
```

Good:
```rust
fn analyze(program: &Program) -> AnalysisResult {
    // returns result
}
```

### Explicit Dependencies
All functions take context explicitly, no hidden globals.

## Acceptance Criteria

- [ ] Standards documented in CONTRIBUTING.md or similar
- [ ] Team agrees on limits
- [ ] Apply during all subsequent moths
EOF

# =============================================================================
# MOTH 1: Split closures.rs
# =============================================================================
moth new "Split closures.rs into modules" -s med --stdin << 'EOF'
## Summary

`liar/src/closures.rs` is ~1400 lines. Split it into focused modules.

## Current State

Contains:
- Capture analysis (which variables a closure captures)
- Closure color determination (thread safety)
- Thread safety checking for plet/async
- Tests for all of the above

## Target State

```
liar/src/closures/
  mod.rs          - public API, re-exports (~30 lines)
  types.rs        - CaptureMode, ClosureColor, Capture, CaptureInfo (~80 lines)
  analysis.rs     - ClosureAnalyzer, capture detection (~300 lines)
  safety.rs       - ThreadSafetyChecker (~200 lines)
  tests.rs        - all tests (~400 lines)
```

## Steps

1. Create `liar/src/closures/` directory
2. Extract types to `types.rs`
3. Extract analysis to `analysis.rs`
4. Extract safety checking to `safety.rs`
5. Move tests to `tests.rs`
6. Create `mod.rs` with re-exports
7. Update `lib.rs` (should work unchanged due to mod.rs)
8. Run `cargo test -p liar`

## Acceptance Criteria

- [ ] No file in closures/ exceeds 400 lines
- [ ] All existing tests pass
- [ ] Public API unchanged (same imports work)
- [ ] No thread-local state
EOF

# =============================================================================
# MOTH 2: Add Closure Conversion Pass
# =============================================================================
moth new "Add closure conversion pass" -s crit --stdin << 'EOF'
## Summary

Add a dedicated closure conversion pass that transforms lambdas in the AST BEFORE codegen. This keeps codegen simple.

## Pipeline Position

```
Parse → Resolve → Infer → Ownership → Closures Analysis → Closures Conversion → Codegen
                                              ↑                    ↑
                                          (exists)              (THIS)
```

## Design Decision: Uniform Calling Convention

ALL functions take `env` as first parameter:

```lisp
;; User writes
(defun inc (x) (+ x 1))

;; Conversion emits
(defun inc (__env x) (+ x 1))  ;; env ignored but present
```

This means:
- Function reference `inc` → `{ @inc, null }`
- Lambda `(fn (x) (+ x n))` → `{ @__lambda_0, env_ptr }`
- All calls uniform: `(indirect-call fn_ptr env_ptr args...)`
- NO thunks needed

## Create liar/src/closures/conversion.rs

### Main Entry Point

```rust
pub fn convert(
    program: &mut Program,
    capture_info: HashMap<Span, CaptureInfo>,
) -> Result<()>
```

### What It Does

**Input:**
```lisp
(defun make-adder (n)
  (fn (x) (+ x n)))
```

**Output:**
```lisp
;; Environment struct for lambda
(defstruct __env_0 (n))

;; Lifted lambda with env parameter
(defun __lambda_0 (__env x)
  (+ x (. __env n)))

;; Original function - now takes __env, lambda replaced
(defun make-adder (__env n)
  (let ((env (rc-alloc __env_0)))
    (set! (. env n) n)
    { @__lambda_0, env }))
```

### Closure Representation

All closures are: `{ fn_ptr: ptr, env_ptr: ptr }`

## AST Extensions Needed

Add to `liar/src/ast.rs`:

```rust
/// A closure struct literal (generated by conversion pass)
ClosureStruct {
    fn_name: String,
    env: Option<Box<Spanned<Expr>>>,  // None = null env
},

/// An indirect call through a closure
ClosureCall {
    closure: Box<Spanned<Expr>>,
    args: Vec<Spanned<Expr>>,
},
```

## Update lib.rs Pipeline

```rust
let capture_info = closures::analyze(&program)?;
closures::convert(&mut program, capture_info)?;  // NEW
codegen::generate(&program)
```

## Tests

```rust
#[test]
fn test_convert_lambda_no_captures() {
    // (defun f () (fn (x) x)) should generate __lambda_0
}

#[test]
fn test_convert_lambda_with_capture() {
    // (defun f (n) (fn (x) (+ x n))) should generate __env_0 and __lambda_0
}

#[test]
fn test_all_functions_get_env_param() {
    // Every defun should have __env as first param after conversion
}
```

## Acceptance Criteria

- [ ] conversion.rs < 400 lines
- [ ] No thread-local state
- [ ] All lambdas converted before codegen
- [ ] All functions have __env parameter
- [ ] No thunks generated
- [ ] Integration: `(let ((f (fn (x) x))) (f 5))` evaluates to 5
EOF

# =============================================================================
# MOTH 3: Simplify Codegen
# =============================================================================
moth new "Simplify codegen after closure conversion" -s high --stdin << 'EOF'
## Summary

Once closure conversion runs before codegen, remove all closure-related complexity from codegen.

## Prerequisites

- Closure conversion pass (MOTH 002) must be complete
- Lambdas are converted to ClosureStruct before codegen sees them

## Remove From codegen.rs

Delete thread-local tables:
- `CLOSURE_INFO`
- `GENERATED_LAMBDAS`
- `GENERATED_ENV_STRUCTS`
- `LAMBDA_COUNTER`
- `NEEDS_MALLOC`
- `FUNC_PARAM_TYPES`
- `GENERATED_THUNKS`
- `THUNK_CACHE`

Delete related functions:
- All `reset_*`, `set_*`, `lookup_*`, `take_*` for closure state
- `generate_lambda()`
- `generate_closure_call()`
- `generate_closure_call_expr()`
- `get_or_create_thunk()`

## Simplify Cases

### Expr::Lambda
```rust
Expr::Lambda(_, _) => {
    // Should never reach here
    Err(CompileError::codegen(
        expr.span,
        "internal error: lambda should have been converted",
    ))
}
```

### Expr::ClosureStruct (NEW)
```rust
Expr::ClosureStruct { fn_name, env } => {
    let fn_ptr = lir::Expr::GlobalRef(fn_name.clone());
    let env_ptr = match env {
        Some(e) => generate_expr(e)?,
        None => lir::Expr::NullPtr,
    };
    Ok(lir::Expr::StructLit(vec![fn_ptr, env_ptr]))
}
```

### Expr::ClosureCall (NEW)
```rust
Expr::ClosureCall { closure, args } => {
    // Extract fn_ptr and env_ptr, do indirect call
}
```

### Expr::Var
```rust
// Before: complex logic checking for function references
// After: just emit LocalRef
Expr::Var(name) => Ok(lir::Expr::LocalRef(name.clone()))
```

## Expected Result

codegen.rs should shrink by ~300-400 lines and have no closure-specific logic.

## Acceptance Criteria

- [ ] codegen.rs has no thread-local closure state
- [ ] Expr::Lambda case is unreachable error
- [ ] No thunk generation code
- [ ] All tests pass
- [ ] `(let ((f (fn (x) x))) (f 5))` still works
EOF

# =============================================================================
# MOTH 4: Split Codegen Into Modules
# =============================================================================
moth new "Split codegen.rs into modules" -s med --stdin << 'EOF'
## Summary

`liar/src/codegen.rs` is ~1100+ lines. Split into focused modules.

## Target State

```
liar/src/codegen/
  mod.rs          - generate(), generate_expr() dispatch (~150 lines)
  context.rs      - CodegenContext struct (~100 lines)
  types.rs        - type conversion utilities (~150 lines)
  builtins.rs     - arithmetic, comparison, boolean ops (~200 lines)
  structs.rs      - struct construction, field access (~150 lines)
  protocols.rs    - protocol method dispatch (~100 lines)
  atoms.rs        - atom operations (~150 lines)
  collections.rs  - vector, map, keyword literals (~100 lines)
  tests.rs        - all codegen tests (~300 lines)
```

## Key Change: Explicit Context

Replace thread-local state with explicit context:

```rust
pub struct CodegenContext {
    var_counter: usize,
    func_return_types: HashMap<String, lir::ReturnType>,
    struct_defs: HashMap<String, StructInfo>,
    // etc.
}

impl CodegenContext {
    pub fn fresh_var(&mut self, prefix: &str) -> String { ... }
    pub fn lookup_struct(&self, name: &str) -> Option<&StructInfo> { ... }
}
```

All functions take `&mut CodegenContext`:

```rust
fn generate_struct_constructor(
    ctx: &mut CodegenContext,
    ...
) -> Result<lir::Expr>
```

## Steps

1. Create `CodegenContext` in `context.rs`
2. Extract type utilities to `types.rs`
3. Extract builtins to `builtins.rs`
4. Extract struct handling to `structs.rs`
5. Extract protocol dispatch to `protocols.rs`
6. Extract atom ops to `atoms.rs`
7. Extract collections to `collections.rs`
8. Simplify `mod.rs` to just dispatch
9. Thread context through all functions
10. Move tests to `tests.rs`

## Acceptance Criteria

- [ ] No file in codegen/ exceeds 300 lines
- [ ] No thread-local state (all in CodegenContext)
- [ ] All existing tests pass
- [ ] Context passed explicitly everywhere
EOF

# =============================================================================
# MOTH 5: Document lIR Boundary
# =============================================================================
moth new "Document and enforce lIR boundary" -s low --stdin << 'EOF'
## Summary

lIR is a stable, complete compilation target. Document and enforce the boundary.

## The Boundary

```
┌─────────────────────────────────────────┐
│                liar                      │
│  All abstractions: closures, protocols,  │
│  atoms, type inference, etc.             │
│                                          │
│  Codegen just emits lIR nodes            │
└────────────────┬────────────────────────┘
                 │ lIR AST
                 ▼
┌─────────────────────────────────────────┐
│                lIR                       │
│  Generic primitives only                 │
│  No liar concepts                        │
│  Standalone, testable without liar       │
└─────────────────────────────────────────┘
```

## Enforcement Rules

### In lir-core and lir-codegen:
1. No liar imports
2. No liar terminology ("closure", "protocol", "atom")
3. Generic primitives only (IndirectCall, not ClosureCall)

### In liar:
1. No lIR modification
2. All abstraction in liar
3. Codegen is dumb - just translates

## Verification

lIR should be testable without liar:

```rust
// In lir-core tests
#[test]
fn test_closure_pattern_without_liar() {
    let source = r#"
        (defstruct env (i64))
        (define (lambda_0 i64) ((ptr env) (i64 x))
          (block entry ...))
    "#;
    // Compiles without liar
}
```

## Documentation

Add to `lir-core/README.md`:
- Design principles
- Relationship to liar
- What lIR does NOT know about

## Acceptance Criteria

- [ ] lir-core has no liar dependency
- [ ] lir-codegen has no liar dependency
- [ ] lir-core tests cover patterns without liar
- [ ] README documents boundary
- [ ] No liar terminology in lIR codebase
EOF

echo ""
echo "Created moths. Run 'moth ls' to see them."
echo ""
echo "Suggested order:"
echo "  1. Coding standards (high) - reference throughout"
echo "  2. Closure conversion (crit) - the core work"
echo "  3. Simplify codegen (high) - depends on #2"
echo "  4. Split closures (med) - prep work"
echo "  5. Split codegen (med) - final cleanup"
echo "  6. Document boundary (low) - verification"
