;; liar Standard Library
;;
;; Core functions and utilities

;; Core

(defun identity (x) x)

;; Arithmetic

(defun inc (x) (+ x 1))

(defun dec (x) (- x 1))

(defun square (x) (* x x))

(defun abs (x) (if (< x 0) (- 0 x) x))

(defun neg (x) (- 0 x))

(defun min (a b) (if (< a b) a b))

(defun max (a b) (if (> a b) a b))

(defun cube (x) (* x (* x x)))

(defun sign (x) (if (< x 0) -1 (if (> x 0) 1 0)))

(defun clamp (x lo hi) (max lo (min x hi)))

;; Predicates

(defun zerop (x) (= x 0))

(defun posp (x) (> x 0))

(defun negp (x) (< x 0))

(defun evenp (x) (= 0 (rem x 2)))

(defun oddp (x) (= 1 (rem x 2)))

(defun divisible (d n) (= 0 (rem n d)))

(defun in-range (x lo hi) (if (<= lo x) (<= x hi) false))

;; Math

(defun gcd (a b) (if (= b 0) a (gcd b (rem a b))))

(defun lcm (a b) (/ (* a b) (gcd a b)))

(defun factorial (n) (if (<= n 1) 1 (* n (factorial (- n 1)))))

(defun fib (n) (if (<= n 1) n (+ (fib (- n 1)) (fib (- n 2)))))

(defun pow (base exp) (if (= exp 0) 1 (* base (pow base (- exp 1)))))

(defun sum-to (n) (if (<= n 0) 0 (+ n (sum-to (- n 1)))))

;; Higher-order functions

;; Returns a function that always returns v, ignoring its argument
(defun constantly (v)
  (fn (x) v))

;; Returns composition of two functions: (comp f g) returns fn that does (f (g x))
(defun comp (f g)
  (fn (x) (f (g x))))

;; Returns a function with arguments flipped: (flip f) returns (fn (a b) (f b a))
(defun flip (f)
  (fn (a b) (f b a)))

;; Returns a function that negates the result of predicate f
;; Works with predicates returning i64 (0 = false, non-zero = true)
(defun complement (f)
  (fn (x) (if (= 0 (f x)) 1 0)))

;; Composition of three functions: (f (g (h x)))
(defun comp3 (f g h)
  (fn (x) (f (g (h x)))))

;; Variadic composition macro - composes any number of functions
(defmacro comp* (... fns)
  (if (nil? fns)
      `identity
      (if (nil? (rest fns))
          (first fns)
          `(fn (x) (,(first fns) ((comp* ,@(rest fns)) x))))))
