;; reader.liar - S-expression reader for liar
;;
;; Parses source text into SCons structures (native AST).
;; Uses load-byte and ptr+ for character-by-character parsing.
;;
;; Dependencies: value.liar (SCons, BoxedInt, LiarString, pcons)
;;               symbols.liar (intern)
;;
;; Note: All functions that take 'src' or 'name' use ptr type, not string.
;; String literals in liar have type 'string', which is incompatible with ptr.
;; The reader expects ptr to raw byte data (from slurp or heap-array).

;; ============================================================================
;; Lexer State (Mutable)
;; ============================================================================

;; Lexer uses an array for mutable state: [pos, line, col]
;; Struct fields src/len are immutable, state array is mutated in place
(defstruct Lexer (lex-src: ptr lex-len: i64 lex-state: ptr))

;; State array indices
(defun state-pos-idx () 0)
(defun state-line-idx () 1)
(defun state-col-idx () 2)

;; Create a new lexer from source bytes
;; Note: src must be ptr (from slurp or heap-array), not string literal
(defun make-lexer (src len: i64) -> ptr
  (let ((state (heap-array 3))
        (s0 (aset state 0 0))    ;; pos = 0
        (s1 (aset state 1 1))    ;; line = 1
        (s2 (aset state 2 1)))   ;; col = 1
    (share (Lexer src len state))))

;; Accessors
(defun lexer-src (lex: ptr) -> ptr (. lex lex-src))
(defun lexer-len (lex: ptr) -> i64 (. lex lex-len))
(defun lexer-pos (lex: ptr) -> i64 (aget (. lex lex-state) 0))
(defun lexer-line (lex: ptr) -> i64 (aget (. lex lex-state) 1))
(defun lexer-col (lex: ptr) -> i64 (aget (. lex lex-state) 2))

;; Mutators
(defun set-lexer-pos! (lex: ptr val: i64) (aset (. lex lex-state) 0 val))
(defun set-lexer-line! (lex: ptr val: i64) (aset (. lex lex-state) 1 val))
(defun set-lexer-col! (lex: ptr val: i64) (aset (. lex lex-state) 2 val))

;; ============================================================================
;; Character Operations
;; ============================================================================

;; Peek at current character without consuming
;; Returns -1 for EOF
(defun peek-char (lex: ptr) -> i64
  (if (>= (lexer-pos lex) (lexer-len lex))
      -1
      (zext i64 (load-byte (ptr+ (lexer-src lex) (lexer-pos lex))))))

;; Peek at character at offset from current position
(defun peek-char-at (lex: ptr offset: i64) -> i64
  (let ((pos (+ (lexer-pos lex) offset)))
    (if (>= pos (lexer-len lex))
        -1
        (zext i64 (load-byte (ptr+ (lexer-src lex) pos))))))

;; Advance lexer by one character, updating line/col in place
;; Returns the character that was consumed (for convenience)
(defun advance-char! (lex: ptr) -> i64
  (let ((c (peek-char lex))
        (new-pos (+ (lexer-pos lex) 1))
        (s0 (set-lexer-pos! lex new-pos)))
    (if (= c 10)  ;; newline
        (let ((s1 (set-lexer-line! lex (+ (lexer-line lex) 1)))
              (s2 (set-lexer-col! lex 1)))
          c)
        (let ((s1 (set-lexer-col! lex (+ (lexer-col lex) 1))))
          c))))

;; Advance lexer by n characters (mutating)
(defun advance-n! (lex: ptr n: i64)
  (if (<= n 0)
      0
      (let ((c (advance-char! lex)))
        (advance-n! lex (- n 1)))))

;; ============================================================================
;; Character Classification
;; ============================================================================

;; Note: predicate functions don't specify return type - compiler infers bool (i1)

(defun eof? (c: i64) (= c -1))

(defun whitespace? (c: i64)
  (cond
    ((= c 32) true)   ;; space
    ((= c 10) true)   ;; newline
    ((= c 9)  true)   ;; tab
    ((= c 13) true)   ;; carriage return
    (else false)))

(defun digit? (c: i64)
  (if (>= c 48) (if (<= c 57) true false) false))

(defun alpha? (c: i64)
  (if (>= c 97)
      (if (<= c 122) true (if (>= c 65) (if (<= c 90) true false) false))
      (if (>= c 65) (if (<= c 90) true false) false)))

;; Symbol start: alpha, _, +, -, *, /, <, >, =, ?, !, &
(defun symbol-start? (c: i64)
  (cond
    ((alpha? c) true)
    ((= c 95) true)   ;; _
    ((= c 43) true)   ;; +
    ((= c 45) true)   ;; -
    ((= c 42) true)   ;; *
    ((= c 47) true)   ;; /
    ((= c 60) true)   ;; <
    ((= c 62) true)   ;; >
    ((= c 61) true)   ;; =
    ((= c 63) true)   ;; ?
    ((= c 33) true)   ;; !
    ((= c 38) true)   ;; &
    (else false)))

;; Symbol continue: symbol-start, digit, or .
(defun symbol-char? (c: i64)
  (cond
    ((symbol-start? c) true)
    ((digit? c) true)
    ((= c 46) true)   ;; .
    (else false)))

;; ============================================================================
;; Whitespace and Comment Skipping
;; ============================================================================

;; Skip to end of line (for comments) - mutates lexer
(defun skip-to-eol! (lex: ptr)
  (let ((c (peek-char lex)))
    (cond
      ((eof? c) 0)
      ((= c 10) (advance-char! lex))  ;; consume newline and done
      (else (let ((s (advance-char! lex))) (skip-to-eol! lex))))))

;; Skip whitespace and comments - mutates lexer
(defun skip-ws! (lex: ptr)
  (let ((c (peek-char lex)))
    (cond
      ((eof? c) 0)
      ((whitespace? c) (let ((s (advance-char! lex))) (skip-ws! lex)))
      ((= c 59) (let ((s (skip-to-eol! lex))) (skip-ws! lex)))  ;; comment
      (else 0))))

;; ============================================================================
;; Number Parsing
;; ============================================================================

;; Accumulate digits into a number (mutates lexer)
;; Returns the accumulated integer value
(defun read-digits! (lex: ptr acc: i64) -> i64
  (let ((c (peek-char lex)))
    (if (digit? c)
        (let ((s (advance-char! lex)))
          (read-digits! lex (+ (* acc 10) (- c 48))))
        acc)))

;; Read fractional digits (mutates lexer)
;; Returns icons (frac, box-int(scale)) - scale boxed since icons needs ptr tail
(defun read-frac-digits! (lex: ptr frac: i64 scale: i64) -> ptr
  (let ((c (peek-char lex)))
    (if (digit? c)
        (let ((s (advance-char! lex)))
          (read-frac-digits! lex (+ (* frac 10) (- c 48)) (* scale 10)))
        (icons frac (box-int scale)))))

;; Helper to negate if needed
(defun negate-if (is-negative: i64 val: i64) -> i64
  (if (= is-negative 1) (- 0 val) val))

;; Helper for float part of read-number!
(defun read-number-float! (lex: ptr int-val: i64 is-neg: i64) -> ptr
  (let ((s2 (advance-char! lex))            ;; consume .
        (frac-result (read-frac-digits! lex 0 1))
        (frac-val (icons-head frac-result))
        (scale-box (icons-tail frac-result))
        (scale (unbox-int scale-box))
        (final-int (negate-if is-neg int-val))
        (final-frac (negate-if is-neg frac-val)))
    (box-float final-int final-frac scale)))

;; Helper to dispatch on float vs int
(defun read-number-dispatch! (lex: ptr int-val: i64 is-neg: i64 next-c: i64) -> ptr
  (if (= next-c 46)  ;; . - float
      (read-number-float! lex int-val is-neg)
      (box-int (negate-if is-neg int-val))))

;; Check if char is minus sign
(defun is-minus? (c: i64) -> i64 (if (= c 45) 1 0))

;; Consume minus if present
(defun maybe-consume-minus! (lex: ptr is-neg: i64) -> i64
  (if (= is-neg 1) (advance-char! lex) 0))

;; Read a number - mutates lexer, returns BoxedInt or BoxedFloat
(defun read-number! (lex: ptr) -> ptr
  (let ((c (peek-char lex))
        (is-neg (is-minus? c))
        (s (maybe-consume-minus! lex is-neg))
        (int-val (read-digits! lex 0))
        (next-c (peek-char lex)))
    (read-number-dispatch! lex int-val is-neg next-c)))

;; ============================================================================
;; Symbol Parsing
;; ============================================================================

;; Count symbol length from current position (non-mutating lookahead)
(defun count-symbol-len (lex: ptr len: i64) -> i64
  (let ((c (peek-char-at lex len)))
    (if (symbol-char? c)
        (count-symbol-len lex (+ len 1))
        len)))

;; Copy n bytes from source to dest
(defun copy-bytes-loop (src: ptr dest: ptr n: i64 idx: i64) -> i64
  (if (>= idx n)
      n
      (let ((b (load-byte (ptr+ src idx)))
            (s (store-byte (ptr+ dest idx) b)))
        (copy-bytes-loop src dest n (+ idx 1)))))

(defun copy-bytes (src: ptr dest: ptr n: i64) -> i64
  (copy-bytes-loop src dest n 0))

;; Read a symbol and intern it - mutates lexer, returns Symbol
(defun read-symbol! (lex: ptr table: ptr) -> ptr
  (let ((start-pos (lexer-pos lex))
        (len (count-symbol-len lex 0))
        ;; Allocate buffer for symbol name + null terminator
        (buf (heap-array (+ len 1)))
        (c (copy-bytes (ptr+ (lexer-src lex) start-pos) buf len))
        ;; Null-terminate
        (s (store-byte (ptr+ buf len) 0))
        ;; Advance lexer past the symbol
        (s2 (advance-n! lex len)))
    ;; Intern and return the symbol
    (intern table buf)))

;; ============================================================================
;; String Parsing
;; ============================================================================

;; Count string length (stopping at closing quote or EOF)
;; Handles escape sequences for length calculation
(defun count-string-len (lex: ptr len: i64) -> i64
  (let ((c (peek-char-at lex len)))
    (if (eof? c) len  ;; unclosed string
        (if (= c 34) len  ;; closing quote
            (if (= c 92)  ;; backslash escape
                (count-string-len lex (+ len 2))  ;; skip escape sequence
                (count-string-len lex (+ len 1)))))))

;; Decode escape character
(defun decode-escape (next: i64) -> i64
  (cond
    ((= next 110) 10)    ;; \n -> newline
    ((= next 116) 9)     ;; \t -> tab
    ((= next 114) 13)    ;; \r -> CR
    ((= next 34) 34)     ;; \" -> "
    ((= next 92) 92)     ;; \\ -> \
    (else next)))        ;; unknown: keep as-is

;; Copy string with escape processing
(defun copy-string-loop (src: ptr dest: ptr src-idx dest-idx end) -> i64
  (if (>= src-idx end)
      dest-idx  ;; return final length
      (let ((c (zext i64 (load-byte (ptr+ src src-idx)))))
        (if (= c 92)  ;; backslash
            (let ((next (zext i64 (load-byte (ptr+ src (+ src-idx 1)))))
                  (escaped (decode-escape next))
                  (s (store-byte (ptr+ dest dest-idx) (trunc i8 escaped))))
              (copy-string-loop src dest (+ src-idx 2) (+ dest-idx 1) end))
            (let ((s (store-byte (ptr+ dest dest-idx) (trunc i8 c))))
              (copy-string-loop src dest (+ src-idx 1) (+ dest-idx 1) end))))))

;; Read a string literal - mutates lexer, returns LiarString
(defun read-string! (lex: ptr) -> ptr
  (let ((s0 (advance-char! lex))  ;; skip opening quote
        (start-pos (lexer-pos lex))
        (raw-len (count-string-len lex 0))
        ;; Allocate buffer (may be smaller after escape processing)
        (buf (heap-array (+ raw-len 1)))
        (actual-len (copy-string-loop (lexer-src lex)
                                       buf start-pos (+ start-pos raw-len) 0))
        ;; Null-terminate
        (s1 (store-byte (ptr+ buf actual-len) 0))
        ;; Advance past string content and closing quote
        (s2 (advance-n! lex (+ raw-len 1))))
    (liar-string buf actual-len)))

;; ============================================================================
;; List Parsing
;; ============================================================================

;; Read list elements until ) - mutates lexer, returns scons-list
(defun read-list-elements! (lex: ptr table: ptr) -> ptr
  (let ((s0 (skip-ws! lex))
        (c (peek-char lex))
        (line (lexer-line lex))
        (col (lexer-col lex)))
    (cond
      ((= c 41) (let ((s (advance-char! lex))) nil))  ;; ) - end of list
      ((eof? c) nil)  ;; unclosed list (error case)
      (else
        (let ((elem (read-value! lex table))
              (rest (read-list-elements! lex table)))
          (scons-loc elem rest line col))))))

;; Read a list: ( ... ) - mutates lexer, returns scons-list
(defun read-list! (lex: ptr table: ptr) -> ptr
  (let ((s (advance-char! lex)))  ;; skip (
    (read-list-elements! lex table)))

;; ============================================================================
;; Vector Parsing - produces actual PersistentVector
;; ============================================================================

;; Read vector elements until ] - mutates lexer, returns PersistentVector
(defun read-vector-elements! (lex: ptr table: ptr acc: ptr) -> ptr
  (let ((s0 (skip-ws! lex))
        (c (peek-char lex)))
    (cond
      ((= c 93) (let ((s (advance-char! lex))) acc))  ;; ] - done
      ((eof? c) acc)  ;; unclosed vector
      (else
        (let ((elem (read-value! lex table)))
          (read-vector-elements! lex table (vec-conj acc elem)))))))

;; Read a vector: [ ... ] - mutates lexer, returns PersistentVector
(defun read-vector! (lex: ptr table: ptr) -> ptr
  (let ((s (advance-char! lex)))  ;; skip [
    (read-vector-elements! lex table (vector))))

;; ============================================================================
;; Quote Handling
;; ============================================================================

;; Create the "quote" string as a ptr (since string literals are type 'string', not 'ptr')
;; "quote" = 113, 117, 111, 116, 101, 0
(defun make-quote-str () -> ptr
  (let ((buf (heap-array 6))
        (s1 (store-byte buf 113))         ;; q
        (s2 (store-byte (ptr+ buf 1) 117)) ;; u
        (s3 (store-byte (ptr+ buf 2) 111)) ;; o
        (s4 (store-byte (ptr+ buf 3) 116)) ;; t
        (s5 (store-byte (ptr+ buf 4) 101)) ;; e
        (s6 (store-byte (ptr+ buf 5) 0)))  ;; null
    buf))

;; Read 'x -> (quote x) - mutates lexer, returns (quote x) as scons
(defun read-quote! (lex: ptr table: ptr) -> ptr
  (let ((line (lexer-line lex))
        (col (lexer-col lex))
        (s (advance-char! lex))  ;; skip '
        ;; Create "quote" string as ptr
        (quote-str (make-quote-str))
        (quote-sym (intern table quote-str))
        ;; Read the quoted value
        (val (read-value! lex table)))
    (scons-loc quote-sym (scons-loc val nil line col) line col)))

;; ============================================================================
;; Keyword Parsing
;; ============================================================================

;; Read :keyword - mutates lexer, returns keyword Symbol
(defun read-keyword! (lex: ptr table: ptr) -> ptr
  (let ((s0 (advance-char! lex))  ;; skip :
        (start-pos (lexer-pos lex))
        (len (count-symbol-len lex 0))
        ;; Allocate buffer with : prefix
        (buf (heap-array (+ len 2)))
        (s1 (store-byte buf 58))  ;; :
        (c (copy-bytes (ptr+ (lexer-src lex) start-pos) (ptr+ buf 1) len))
        (s2 (store-byte (ptr+ buf (+ len 1)) 0))  ;; null terminate
        (s3 (advance-n! lex len)))
    (intern table buf)))

;; ============================================================================
;; Map Parsing - produces actual PersistentHashMap
;; ============================================================================

;; Read map entries until } - mutates lexer, returns PersistentHashMap
(defun read-map-elements! (lex: ptr table: ptr acc: ptr) -> ptr
  (let ((s0 (skip-ws! lex))
        (c (peek-char lex)))
    (cond
      ((= c 125) (let ((s (advance-char! lex))) acc))  ;; } - done
      ((eof? c) acc)  ;; unclosed map
      (else
        (let ((key (read-value! lex table))
              (val (read-value! lex table)))
          (read-map-elements! lex table (hm-assoc acc key val)))))))

;; Read a map: { k1 v1 k2 v2 ... } - mutates lexer, returns PersistentHashMap
(defun read-map! (lex: ptr table: ptr) -> ptr
  (let ((s (advance-char! lex)))  ;; skip {
    (read-map-elements! lex table (hash-map))))

;; ============================================================================
;; Quasiquote / Unquote Handling
;; ============================================================================

;; Create "quasiquote" string as ptr
;; "quasiquote" = 113 117 97 115 105 113 117 111 116 101 0
(defun make-quasiquote-str () -> ptr
  (let ((buf (heap-array 11))
        (s0 (store-byte buf 113))          ;; q
        (s1 (store-byte (ptr+ buf 1) 117)) ;; u
        (s2 (store-byte (ptr+ buf 2) 97))  ;; a
        (s3 (store-byte (ptr+ buf 3) 115)) ;; s
        (s4 (store-byte (ptr+ buf 4) 105)) ;; i
        (s5 (store-byte (ptr+ buf 5) 113)) ;; q
        (s6 (store-byte (ptr+ buf 6) 117)) ;; u
        (s7 (store-byte (ptr+ buf 7) 111)) ;; o
        (s8 (store-byte (ptr+ buf 8) 116)) ;; t
        (s9 (store-byte (ptr+ buf 9) 101)) ;; e
        (sa (store-byte (ptr+ buf 10) 0))) ;; null
    buf))

;; Create "unquote" string as ptr
;; "unquote" = 117 110 113 117 111 116 101 0
(defun make-unquote-str () -> ptr
  (let ((buf (heap-array 8))
        (s0 (store-byte buf 117))          ;; u
        (s1 (store-byte (ptr+ buf 1) 110)) ;; n
        (s2 (store-byte (ptr+ buf 2) 113)) ;; q
        (s3 (store-byte (ptr+ buf 3) 117)) ;; u
        (s4 (store-byte (ptr+ buf 4) 111)) ;; o
        (s5 (store-byte (ptr+ buf 5) 116)) ;; t
        (s6 (store-byte (ptr+ buf 6) 101)) ;; e
        (s7 (store-byte (ptr+ buf 7) 0)))  ;; null
    buf))

;; Create "unquote-splicing" string as ptr
;; "unquote-splicing" = 117 110 113 117 111 116 101 45 115 112 108 105 99 105 110 103 0
(defun make-unquote-splicing-str () -> ptr
  (let ((buf (heap-array 17))
        (s00 (store-byte buf 117))          ;; u
        (s01 (store-byte (ptr+ buf 1) 110)) ;; n
        (s02 (store-byte (ptr+ buf 2) 113)) ;; q
        (s03 (store-byte (ptr+ buf 3) 117)) ;; u
        (s04 (store-byte (ptr+ buf 4) 111)) ;; o
        (s05 (store-byte (ptr+ buf 5) 116)) ;; t
        (s06 (store-byte (ptr+ buf 6) 101)) ;; e
        (s07 (store-byte (ptr+ buf 7) 45))  ;; -
        (s08 (store-byte (ptr+ buf 8) 115)) ;; s
        (s09 (store-byte (ptr+ buf 9) 112)) ;; p
        (s10 (store-byte (ptr+ buf 10) 108)) ;; l
        (s11 (store-byte (ptr+ buf 11) 105)) ;; i
        (s12 (store-byte (ptr+ buf 12) 99))  ;; c
        (s13 (store-byte (ptr+ buf 13) 105)) ;; i
        (s14 (store-byte (ptr+ buf 14) 110)) ;; n
        (s15 (store-byte (ptr+ buf 15) 103)) ;; g
        (s16 (store-byte (ptr+ buf 16) 0)))  ;; null
    buf))

;; Read `x -> (quasiquote x) - mutates lexer, returns (quasiquote x)
(defun read-quasiquote! (lex: ptr table: ptr) -> ptr
  (let ((line (lexer-line lex))
        (col (lexer-col lex))
        (s (advance-char! lex))  ;; skip `
        (qq-str (make-quasiquote-str))
        (qq-sym (intern table qq-str))
        (val (read-value! lex table)))
    (scons-loc qq-sym (scons-loc val nil line col) line col)))

;; Read ~x -> (unquote x) or ~@x -> (unquote-splicing x) - mutates lexer
(defun read-unquote! (lex: ptr table: ptr) -> ptr
  (let ((line (lexer-line lex))
        (col (lexer-col lex))
        (s0 (advance-char! lex))  ;; skip ~
        (next-c (peek-char lex)))
    (if (= next-c 64)  ;; @ - unquote-splicing
        (let ((s1 (advance-char! lex))  ;; skip @
              (us-str (make-unquote-splicing-str))
              (us-sym (intern table us-str))
              (val (read-value! lex table)))
          (scons-loc us-sym (scons-loc val nil line col) line col))
        ;; Regular unquote
        (let ((uq-str (make-unquote-str))
              (uq-sym (intern table uq-str))
              (val (read-value! lex table)))
          (scons-loc uq-sym (scons-loc val nil line col) line col)))))

;; ============================================================================
;; Main Dispatcher
;; ============================================================================

;; Read a single value from the lexer - mutates lexer, returns value
(defun read-value! (lex: ptr table: ptr) -> ptr
  (let ((s0 (skip-ws! lex))
        (c (peek-char lex)))
    (cond
      ((eof? c)          nil)
      ((= c 40)          (read-list! lex table))        ;; (
      ((= c 91)          (read-vector! lex table))      ;; [
      ((= c 123)         (read-map! lex table))         ;; {
      ((= c 34)          (read-string! lex))            ;; "
      ((= c 58)          (read-keyword! lex table))     ;; :
      ((= c 39)          (read-quote! lex table))       ;; '
      ((= c 96)          (read-quasiquote! lex table))  ;; `
      ((= c 126)         (read-unquote! lex table))     ;; ~
      ((digit? c)        (read-number! lex))
      ((= c 45)          (if (digit? (peek-char-at lex 1))   ;; - number or symbol
                             (read-number! lex)
                             (read-symbol! lex table)))
      ((symbol-start? c) (read-symbol! lex table))
      (else              (let ((s (advance-char! lex))) nil)))))  ;; Unknown - skip

;; ============================================================================
;; Top-Level Interface
;; ============================================================================

;; Read all expressions from source text - mutates lexer
;; Returns a list of SCons expressions (in reverse order)
(defun read-all-loop! (lex: ptr table: ptr acc: ptr) -> ptr
  (let ((s0 (skip-ws! lex))
        (c (peek-char lex)))
    (if (eof? c)
        acc  ;; done - return accumulated list
        (let ((val (read-value! lex table)))
          (if (nil? val)
              acc  ;; no value read, done
              (read-all-loop! lex table (scons val acc)))))))

;; Reverse a list
(defun reverse-list-loop (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      acc
      (reverse-list-loop (scons-tail lst)
                         (scons (scons-head lst) acc))))

(defun reverse-list (lst: ptr) -> ptr
  (reverse-list-loop lst nil))

;; Read all expressions from source
;; Returns a list of SCons expressions in correct order
(defun read-all (src: ptr len: i64 table: ptr) -> ptr
  (let ((lex (make-lexer src len))
        (exprs (read-all-loop! lex table nil)))
    (reverse-list exprs)))

;; String length helper (count until null byte)
(defun strlen-loop (s: ptr idx: i64) -> i64
  (if (= 0 (load-byte (ptr+ s idx)))
      idx
      (strlen-loop s (+ idx 1))))

(defun strlen (s: ptr) -> i64
  (strlen-loop s 0))
