;; value.liar - Typed cons cells for homogeneous and heterogeneous lists
;;
;; Architecture: Monomorphized typed collections instead of generic tagged pointers.
;; Each value type gets its own cons cell type for type-safe lists.
;;
;; Type prefixes:
;;   i  - i64 (integers)
;;   p  - ptr (pointers to any struct)
;;   s  - ptr (S-expressions specifically)
;;
;; Note: Float cons (FCons) deferred until struct field type support is verified.
;; Note: Field names are prefixed to avoid ambiguity (icons-hd vs pcons-hd).

;; --- Integer cons (for homogeneous integer lists) ---
;; [1 2 3] â†’ (icons 1 (icons 2 (icons 3 nil)))

(defstruct ICons (icons-hd: i64 icons-tl: ptr))

(defun icons (h icons-tl: ptr) -> ptr
  (share (ICons h icons-tl)))

(defun icons-head (c: ptr) -> i64
  (. c icons-hd))

(defun icons-tail (c: ptr) -> ptr
  (. c icons-tl))

(defun icons? (x: ptr) -> i64
  (instance? x ICons))


;; --- Pointer cons (for heterogeneous pointer lists) ---
;; General-purpose list of any struct pointers
;; [(Box 1) (Box 2)] â†’ (pcons box1 (pcons box2 nil))

(defstruct PCons (pcons-hd: ptr pcons-tl: ptr))

(defun pcons (h: ptr pcons-tl: ptr) -> ptr
  (share (PCons h pcons-tl)))

(defun pcons-head (c: ptr) -> ptr
  (. c pcons-hd))

(defun pcons-tail (c: ptr) -> ptr
  (. c pcons-tl))

(defun pcons? (x: ptr) -> i64
  (instance? x PCons))


;; --- S-expression cons (for parsed source code) ---
;; Separate type from PCons so instance? can distinguish AST from data.
;; Includes source location for error messages.
;;
;; (defun foo (x) (+ x 1))
;; â†’ (scons sym-defun (scons sym-foo (scons (scons sym-x nil) (scons ...))))

(defstruct SCons (scons-hd: ptr scons-tl: ptr scons-line: i64 scons-col: i64))

(defun scons (h: ptr scons-tl: ptr) -> ptr
  (share (SCons h scons-tl 0 0)))

(defun scons-loc (h: ptr scons-tl: ptr line col) -> ptr
  (share (SCons h scons-tl line col)))

(defun scons-head (c: ptr) -> ptr
  (. c scons-hd))

(defun scons-tail (c: ptr) -> ptr
  (. c scons-tl))

(defun scons-line (c: ptr) -> i64
  (. c scons-line))

(defun scons-col (c: ptr) -> i64
  (. c scons-col))

(defun scons? (x: ptr) -> i64
  (instance? x SCons))


;; --- Boxed primitives for uniform treatment ---
;; When you need to put an integer in a pointer list

(defstruct BoxedInt (boxed-int-val: i64))

(defun box-int (v) -> ptr
  (share (BoxedInt v)))

(defun unbox-int (b: ptr) -> i64
  (. b boxed-int-val))

(defun boxed-int? (x: ptr) -> i64
  (instance? x BoxedInt))


;; BoxedFloat deferred until struct field type support for double is verified


;; --- String wrapper (ptr to null-terminated bytes) ---
;; Strings are already pointers in liar, but this provides a distinct type

(defstruct LiarString (liar-str-data: ptr liar-str-len: i64))

(defun liar-string (liar-str-data: ptr liar-str-len) -> ptr
  (share (LiarString liar-str-data liar-str-len)))

(defun liar-string? (x: ptr) -> i64
  (instance? x LiarString))

(defun liar-string-data (s: ptr) -> ptr
  (. s liar-str-data))

(defun liar-string-len (s: ptr) -> i64
  (. s liar-str-len))
