(ns liar.seq
  (:require [liar.prelude :refer :all]))

;; liar Sequence Library
;;
;; Core protocols and implementations for sequential data structures

;;; ============================================================
;;; Protocols
;;; ============================================================

;; Seq - sequential access (lists, lazy seqs)
(defprotocol Seq
  (first [self])      ; returns the head element
  (rest [self]))      ; returns the tail (Seq or nil)

;; Countable - collections with a count
(defprotocol Countable
  (count [self]))     ; returns number of elements

;; Indexable - random access by index
(defprotocol Indexable
  (nth [self idx]))   ; returns element at index (0-based)

;; Collection - basic collection operations
(defprotocol Collection
  (conj [self x])     ; returns collection with x added
  (pop [self]))

;; Mappable - transform elements
(defprotocol Mappable
  (map [self f]))

;; Filterable - select elements
(defprotocol Filterable
  (filter [self pred]))

;; Reducible - fold elements
(defprotocol Reducible
  (reduce [self f init]))

;; Traversable - iterate for side effects
(defprotocol Traversable
  (for-each [self f]))

;; Searchable - search and membership tests
(defprotocol Searchable
  (any [self pred])      ; true if pred is true for any element
  (all [self pred])      ; true if pred is true for all elements
  (member [self x]))     ; true if x is in self

;; SeqTransform - sequence transformations
(defprotocol SeqTransform
  (seq-reverse [self])   ; reverse the sequence
  (seq-append [self other])  ; concatenate two sequences
  (seq-take [self n])    ; first n elements
  (seq-drop [self n]))   ; skip first n elements

;;; ============================================================
;;; New Protocols (Clojure-inspired)
;;; ============================================================

;; Seqable - convert anything to a sequence
(defprotocol Seqable
  (seq [self]))          ; returns a Seq or nil

;; Lookup - key-value access (maps, vectors by index, sets by membership)
(defprotocol Lookup
  (get [self key])           ; returns value for key, or nil
  (get-default [self key default]))  ; returns value for key, or default

;; Associative - map-like operations
(defprotocol Associative
  (assoc [self key val])     ; returns collection with key set to val
  (dissoc [self key])        ; returns collection without key
  (contains-key? [self key])) ; true if key is present

;; Named - for symbols and keywords
(defprotocol Named
  (get-name [self])          ; returns the name as a string ptr
  (get-namespace [self]))    ; returns the namespace as a string ptr, or nil

;; Meta - get metadata
(defprotocol Meta
  (meta [self]))             ; returns metadata map or nil

;; WithMeta - set metadata
(defprotocol WithMeta
  (with-meta [self m]))      ; returns copy with new metadata

;; Callable - for function dispatch
(defprotocol Callable
  (invoke [self args]))      ; call with args list

;; Emptyable - get empty collection of same type
(defprotocol Emptyable
  (empty [self]))            ; returns empty collection of same type

;; Derefable - dereference (for atoms, delays, futures)
;; Note: method is named 'dereference' to avoid conflict with 'deref' keyword
(defprotocol Derefable
  (dereference [self]))      ; returns the referenced value

;; Reversible - efficient reverse iteration
(defprotocol Reversible
  (rseq [self]))             ; returns reverse seq without copying

;;; ============================================================
;;; Protocol Defaults - Seq provides Countable, Indexable, and HOFs
;;; ============================================================

(extend-protocol-default Countable Seq
  (count [self]
    (let ((tail (rest self)))
      (if (nil? tail) 1 (+ 1 (count tail))))))

(extend-protocol-default Indexable Seq
  (nth [self idx]
    (if (= idx 0)
        (first self)
        (if (nil? (rest self))
            0
            (nth (rest self) (- idx 1))))))

(extend-protocol-default Mappable Seq
  (map [self f]
    (if (nil? (rest self))
        (cons (f (first self)) nil)
        (cons (f (first self)) (map (rest self) f)))))

(extend-protocol-default Filterable Seq
  (filter [self pred]
    (if (nil? (rest self))
        (if (pred (first self))
            (cons (first self) nil)
            nil)
        (if (pred (first self))
            (cons (first self) (filter (rest self) pred))
            (filter (rest self) pred)))))

(extend-protocol-default Reducible Seq
  (reduce [self f init]
    (if (nil? (rest self))
        (f init (first self))
        (reduce (rest self) f (f init (first self))))))

(extend-protocol-default Traversable Seq
  (for-each [self f]
    (if (nil? (rest self))
        (let ((_ (f (first self)))) 0)
        (let ((_ (f (first self)))) (for-each (rest self) f)))))

(extend-protocol-default Searchable Seq
  (any [self pred]
    (if (nil? (rest self))
        (if (pred (first self)) 1 0)
        (if (pred (first self)) 1 (any (rest self) pred))))
  (all [self pred]
    (if (nil? (rest self))
        (if (pred (first self)) 1 0)
        (if (pred (first self)) (all (rest self) pred) 0)))
  (member [self x]
    (if (nil? (rest self))
        (if (= x (first self)) 1 0)
        (if (= x (first self)) 1 (member (rest self) x)))))

(extend-protocol-default SeqTransform Seq
  (seq-reverse [self]
    (seq-reverse-acc self nil))
  (seq-append [self other]
    (if (nil? (rest self))
        (cons (first self) other)
        (cons (first self) (seq-append (rest self) other))))
  (seq-take [self n]
    (if (= n 0) nil
        (if (nil? (rest self))
            (cons (first self) nil)
            (cons (first self) (seq-take (rest self) (- n 1))))))
  (seq-drop [self n]
    (if (= n 0) self
        (if (nil? (rest self))
            nil
            (seq-drop (rest self) (- n 1))))))

;;; ============================================================
;;; Cons - the fundamental list building block
;;; ============================================================

;; Note: head is i64 for simplicity - stores values directly, not boxed
;; For pointer values, cast to i64 first
(defstruct Cons (head: i64 tail: ptr))

(extend-protocol Seq Cons
  (first [self] (. self head))
  (rest [self] (. self tail)))

;; Cons gets Countable and Indexable automatically via Seq default

(extend-protocol Collection Cons
  (conj [self x] (share (Cons x self)))
  (pop [self] (. self tail)))

;; Seqable - Cons is already a Seq, return self
(extend-protocol Seqable Cons
  (seq [self] self))

;; Emptyable - empty list is nil
(extend-protocol Emptyable Cons
  (empty [self] nil))

;; Reversible - delegate to seq-reverse (O(n) for lists)
(extend-protocol Reversible Cons
  (rseq [self] (seq-reverse self)))

;;; ============================================================
;;; PtrCons - cons cell with pointer head (for S-expressions, ASTs, etc.)
;;;
;;; NOTE: PtrCons does NOT implement Seq protocol because Seq.first returns
;;; different types for Cons (i64) vs PtrCons (ptr), and protocol dispatch
;;; can't currently handle heterogeneous return types. Use direct accessors.
;;; ============================================================

;; Note: Fields named phead/ptail to avoid collision with Cons.head/tail
(defstruct PtrCons (phead: ptr ptail: ptr))

;; Direct accessors (not protocol methods)
(defun pfirst (lst: ptr) -> ptr
  (. lst phead))

(defun prest (lst: ptr) -> ptr
  (. lst ptail))

;; Constructor
(defun pcons (head: ptr tail: ptr) -> ptr
  (share (PtrCons head tail)))

;; List constructors
(defun plist1 (a: ptr) -> ptr
  (pcons a nil))

(defun plist2 (a: ptr b: ptr) -> ptr
  (pcons a (pcons b nil)))

(defun plist3 (a: ptr b: ptr c: ptr) -> ptr
  (pcons a (pcons b (pcons c nil))))

(defun plist4 (a: ptr b: ptr c: ptr d: ptr) -> ptr
  (pcons a (pcons b (pcons c (pcons d nil)))))

;; Accessors
(defun psecond (lst: ptr) -> ptr
  (pfirst (prest lst)))

(defun pthird (lst: ptr) -> ptr
  (pfirst (prest (prest lst))))

(defun pfourth (lst: ptr) -> ptr
  (pfirst (prest (prest (prest lst)))))

;; Count
(defun pcount (lst: ptr) -> i64
  (if (nil? lst) 0 (+ 1 (pcount (prest lst)))))

;; Reverse
(defun preverse-acc (lst: ptr acc: ptr) -> ptr
  (if (nil? lst)
      acc
      (preverse-acc (prest lst) (pcons (pfirst lst) acc))))

(defun preverse (lst: ptr) -> ptr
  (preverse-acc lst nil))

;;; ============================================================
;;; MutVector - a mutable, growable vector
;;; ============================================================

(defstruct MutVector (data: ptr))

;; Internal helpers for MutVector
;; data layout: [len, cap, elem0, elem1, ...]
(defun mv-get-len (data: ptr) (aget data 0))
(defun mv-set-len! (data: ptr len) (aset data 0 len))
(defun mv-data-idx (idx) (+ idx 2))

;; Constructor - creates an empty mutable vector
(defun mut-vector () -> ptr
  (let ((cap 8)
        (data (heap-array (+ cap 2)))
        (s0 (aset data 0 0))
        (s1 (aset data 1 cap)))
    (share (MutVector data))))

(extend-protocol Countable MutVector
  (count [self]
    (mv-get-len (. self data))))

(extend-protocol Indexable MutVector
  (nth [self idx]
    (aget (. self data) (mv-data-idx idx))))

(extend-protocol Collection MutVector
  (conj [self x]
    (let ((data (. self data))
          (len (mv-get-len data))
          (s1 (aset data (mv-data-idx len) x))
          (s2 (mv-set-len! data (+ len 1))))
      self))
  (pop [self]
    (let ((data (. self data))
          (len (mv-get-len data)))
      (if (= len 0)
          0
          (let ((last-idx (- len 1))
                (val (aget data (mv-data-idx last-idx)))
                (s (mv-set-len! data last-idx)))
            val)))))

;; Lookup - get by index
(extend-protocol Lookup MutVector
  (get [self key]
    (let ((len (mv-get-len (. self data))))
      (if (>= key len)
          nil
          (aget (. self data) (mv-data-idx key)))))
  (get-default [self key default]
    (let ((len (mv-get-len (. self data))))
      (if (>= key len)
          default
          (aget (. self data) (mv-data-idx key))))))

;; Emptyable - return new empty MutVector
(extend-protocol Emptyable MutVector
  (empty [self] (mut-vector)))

;;; ============================================================
;;; List constructors
;;; ============================================================

;; cons - construct a new list node
(defun cons (head tail: ptr) -> ptr
  (share (Cons head tail)))

;; list - construct a list from elements
(defun list1 (a)
  (cons a nil))

(defun list2 (a b)
  (cons a (cons b nil)))

(defun list3 (a b c)
  (cons a (cons b (cons c nil))))

(defun list4 (a b c d)
  (cons a (cons b (cons c (cons d nil)))))

(defun list5 (a b c d e)
  (cons a (cons b (cons c (cons d (cons e nil))))))

(defun list6 (a b c d e f)
  (cons a (cons b (cons c (cons d (cons e (cons f nil)))))))

(defun list7 (a b c d e f g)
  (cons a (cons b (cons c (cons d (cons e (cons f (cons g nil))))))))

(defun list8 (a b c d e f g h)
  (cons a (cons b (cons c (cons d (cons e (cons f (cons g (cons h nil)))))))))

;;; ============================================================
;;; Sequence operations (work on any Seq)
;;; ============================================================

;; Helper for seq-reverse (avoids reduce type issues)
(defun seq-reverse-acc (seq: ptr acc: ptr) -> ptr
  (if (nil? seq) acc
      (if (nil? (rest seq))
          (cons (first seq) acc)
          (seq-reverse-acc (rest seq) (cons (first seq) acc)))))

;; last - get last element
(defun last (seq: ptr)
  (if (nil? seq)
      0
      (if (nil? (rest seq))
          (first seq)
          (last (rest seq)))))

;;; ============================================================
;;; Higher-order sequence functions (now via protocols)
;;; ============================================================

;; map, filter, reduce, for-each are now protocol methods
;; Call style: (map seq f), (filter seq pred), (reduce seq f init), (for-each seq f)

;;; ============================================================
;;; List transformations
;;; ============================================================

;; reverse - reverse a list
(defun reverse (seq: ptr)
  (if (nil? seq) nil
      (reduce seq (fn (acc x) (cons x acc)) nil)))

;; append - concatenate two lists
(defun append (seq1: ptr seq2: ptr)
  (if (nil? seq1)
      seq2
      (cons (first seq1) (append (rest seq1) seq2))))

;; take - first n elements
(defun take (n seq: ptr)
  (if (= n 0)
      nil
      (if (nil? seq)
          nil
          (cons (first seq) (take (- n 1) (rest seq))))))

;; skip-n - skip first n elements (renamed to avoid conflict with builtin 'drop' and protocol 'seq-drop')
(defun skip-n (n seq: ptr)
  (if (= n 0)
      seq
      (if (nil? seq)
          nil
          (skip-n (- n 1) (rest seq)))))

;;; ============================================================
;;; Predicates on sequences (use protocol methods: any, all, member)
;;; ============================================================

;;; ============================================================
;;; Numeric reductions
;;; ============================================================

;; sum - sum of all elements
(defun sum (seq: ptr)
  (if (nil? seq) 0
      (reduce seq (fn (acc x) (+ acc x)) 0)))

;; product - product of all elements
(defun product (seq: ptr)
  (if (nil? seq) 1
      (reduce seq (fn (acc x) (* acc x)) 1)))

;; minimum - smallest element
(defun minimum (seq: ptr)
  (if (nil? seq)
      0
      (if (nil? (rest seq))
          (first seq)
          (reduce (rest seq) (fn (acc x) (if (< x acc) x acc)) (first seq)))))

;; maximum - largest element
(defun maximum (seq: ptr)
  (if (nil? seq)
      0
      (if (nil? (rest seq))
          (first seq)
          (reduce (rest seq) (fn (acc x) (if (> x acc) x acc)) (first seq)))))

;;; ============================================================
;;; Sequence Accessors
;;; ============================================================

;; second - get second element
(defun second (seq: ptr)
  (first (rest seq)))

;; third - get third element
(defun third (seq: ptr)
  (first (rest (rest seq))))

;; fourth - get fourth element
(defun fourth (seq: ptr)
  (first (rest (rest (rest seq)))))

;; fifth - get fifth element
(defun fifth (seq: ptr)
  (first (rest (rest (rest (rest seq))))))

;;; ============================================================
;;; Search and Find Functions
;;; ============================================================

;; find - find first element matching predicate (returns element or nil)
(defun find (pred seq: ptr)
  (if (nil? seq)
      nil
      (if (pred (first seq))
          (first seq)
          (find pred (rest seq)))))

;; some - find first truthy result of (f elem)
;; Returns the first non-nil result, or nil if none
(defun some (f seq: ptr) -> ptr
  (if (nil? seq)
      nil
      (let ((result (f (first seq))))
        (if (nil? result)
            (some f (rest seq))
            result))))

;; find-index - find index of first element matching predicate
(defun find-index-acc (pred seq: ptr idx)
  (if (nil? seq)
      -1
      (if (pred (first seq))
          idx
          (find-index-acc pred (rest seq) (+ idx 1)))))

(defun find-index (pred seq: ptr)
  (find-index-acc pred seq 0))

;;; ============================================================
;;; Sequence Transformations
;;; ============================================================

;; mapcat - map then concatenate results
(defun mapcat (f seq: ptr)
  (if (nil? seq)
      nil
      (append (f (first seq)) (mapcat f (rest seq)))))

;; Note: flatten and flatten-all are commented out because they require
;; nested lists (Cons containing Cons pointers), but Cons.head is i64.
;; TODO: Implement when we have tagged unions or polymorphic types.

;; (defun flatten (seq: ptr)
;;   (mapcat (fn (x) (if (= 1 (instance? x Cons)) x (list1 x))) seq))

;; (defun flatten-all (seq: ptr)
;;   (if (nil? seq)
;;       nil
;;       (if (= 1 (instance? (first seq) Cons))
;;           (append (flatten-all (first seq)) (flatten-all (rest seq)))
;;           (cons (first seq) (flatten-all (rest seq))))))

;; interpose - insert separator between elements
(defun interpose (sep seq: ptr)
  (if (nil? seq)
      nil
      (if (nil? (rest seq))
          seq
          (cons (first seq) (cons sep (interpose sep (rest seq)))))))

;; intersperse - alias for interpose
(defun intersperse (sep seq: ptr)
  (interpose sep seq))

;;; ============================================================
;;; Zipping Functions
;;; ============================================================

;; Note: zip is commented out because it creates nested lists (pairs),
;; but Cons.head is i64 and can't store Cons pointers.

;; (defun zip (seq1: ptr seq2: ptr)
;;   (if (nil? seq1)
;;       nil
;;       (if (nil? seq2)
;;           nil
;;           (cons (list2 (first seq1) (first seq2))
;;                 (zip (rest seq1) (rest seq2))))))

;; zip-with - combine with function (works because f returns i64)
(defun zip-with (f seq1: ptr seq2: ptr) -> ptr
  (if (nil? seq1)
      nil
      (if (nil? seq2)
          nil
          (cons (f (first seq1) (first seq2))
                (zip-with f (rest seq1) (rest seq2))))))

;;; ============================================================
;;; Partitioning Functions
;;; ============================================================

;; Note: partition, partition-by, split-at, split-with are commented out
;; because they create nested lists (lists of lists), but Cons.head is i64.

;; (defun partition (n seq: ptr)
;;   (if (nil? seq)
;;       nil
;;       (cons (take n seq) (partition n (skip-n n seq)))))

;; (defun partition-by-acc (f seq: ptr current: ptr last-val)
;;   ...)

;; (defun partition-by (f seq: ptr)
;;   ...)

;; (defun split-at (n seq: ptr)
;;   (list2 (take n seq) (skip-n n seq)))

;; (defun split-with-acc (pred seq: ptr acc: ptr)
;;   ...)

;; (defun split-with (pred seq: ptr)
;;   ...)

;;; ============================================================
;;; Range and Repeat Functions
;;; ============================================================

;; range - generate sequence of integers [start, end)
(defun range (start end) -> ptr
  (if (>= start end)
      nil
      (cons start (range (+ start 1) end))))

;; range-step - generate sequence with step
(defun range-step (start end step) -> ptr
  (if (>= start end)
      nil
      (cons start (range-step (+ start step) end step))))

;; repeat-n - n copies of value
(defun repeat-n (n x)
  (if (<= n 0)
      nil
      (cons x (repeat-n (- n 1) x))))

;; iterate-n - generate sequence by repeated application
(defun iterate-n (n f x)
  (if (<= n 0)
      nil
      (cons x (iterate-n (- n 1) f (f x)))))

;; cycle-n - repeat sequence n times
(defun cycle-n (n seq: ptr)
  (if (<= n 0)
      nil
      (append seq (cycle-n (- n 1) seq))))

;;; ============================================================
;;; Concatenation
;;; ============================================================

;; concat2 - concatenate two sequences (alias for append)
(defun concat2 (a: ptr b: ptr)
  (append a b))

;; concat3 - concatenate three sequences
(defun concat3 (a: ptr b: ptr c: ptr)
  (append a (append b c)))

;; concat4 - concatenate four sequences
(defun concat4 (a: ptr b: ptr c: ptr d: ptr)
  (append a (append b (append c d))))

;;; ============================================================
;;; Distinct and Deduplication
;;; ============================================================

;; dedupe - remove consecutive duplicates
(defun dedupe-acc (seq: ptr prev acc: ptr)
  (if (nil? seq)
      (reverse acc)
      (if (= (first seq) prev)
          (dedupe-acc (rest seq) prev acc)
          (dedupe-acc (rest seq) (first seq) (cons (first seq) acc)))))

(defun dedupe (seq: ptr)
  (if (nil? seq)
      nil
      (dedupe-acc (rest seq) (first seq) (list1 (first seq)))))

;;; ============================================================
;;; Function Combinators
;;; ============================================================

;; partial1 - partial application with 1 arg fixed
(defun partial1 (f a)
  (fn (x) (f a x)))

;; partial2 - partial application with 2 args fixed
(defun partial2 (f a b)
  (fn (x) (f a b x)))

;; juxt2 - apply multiple functions, return list of results
(defun juxt2 (f g)
  (fn (x) (list2 (f x) (g x))))

;; juxt3 - apply three functions
(defun juxt3 (f g h)
  (fn (x) (list3 (f x) (g x) (h x))))

;; pipe - compose functions left-to-right (opposite of comp)
(defun pipe (f g)
  (fn (x) (g (f x))))

;; pipe3 - compose three functions left-to-right
(defun pipe3 (f g h)
  (fn (x) (h (g (f x)))))
