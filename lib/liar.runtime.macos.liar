(ns liar.runtime.macos
  (:require [liar.core :refer :all]
            [liar.runtime.core :refer :all]))

;; liar Runtime - macOS Reactor (kqueue)
;;
;; This module implements the macOS-specific reactor using kqueue.
;; It is only included when compiling with --target macos.

;; ============================================================
;; kqueue Constants
;; ============================================================

;; kevent filters
(def EVFILT_READ -1)
(def EVFILT_WRITE -2)
(def EVFILT_TIMER -7)

;; kevent flags
(def EV_ADD 1)        ; Add event to kqueue
(def EV_DELETE 2)     ; Delete event from kqueue
(def EV_ENABLE 4)     ; Enable event
(def EV_DISABLE 8)    ; Disable event
(def EV_ONESHOT 16)   ; Only report one occurrence
(def EV_CLEAR 32)     ; Clear state after reporting
(def EV_EOF 32768)    ; EOF detected
(def EV_ERROR 16384)  ; Error detected

;; Error codes
(def EAGAIN 35)
(def EWOULDBLOCK 35)  ; Same as EAGAIN on macOS
(def EINPROGRESS 36)

;; ============================================================
;; kqueue Syscall FFI
;; ============================================================

;; Create a new kqueue
;; returns: kqueue fd on success, -1 on error
(extern kqueue i32 ())

;; Register or modify events in kqueue
;; kq: kqueue file descriptor
;; changelist: pointer to array of kevent structs to register
;; nchanges: number of kevents in changelist
;; eventlist: pointer to array of kevent structs for output
;; nevents: max number of events to return
;; timeout: pointer to timespec (NULL for infinite wait)
;; returns: number of events, or -1 on error
(extern kevent i32 (i32 ptr i32 ptr i32 ptr))

;; close(2) - close a file descriptor
(extern close i32 (i32))

;; ============================================================
;; kevent Structure
;; ============================================================

;; struct kevent {
;;     uintptr_t  ident;     // offset 0, 8 bytes (fd on macOS)
;;     int16_t    filter;    // offset 8, 2 bytes
;;     uint16_t   flags;     // offset 10, 2 bytes
;;     uint32_t   fflags;    // offset 12, 4 bytes
;;     intptr_t   data;      // offset 16, 8 bytes
;;     void      *udata;     // offset 24, 8 bytes (user data)
;; }
;; Total size: 32 bytes

(def KEVENT_SIZE 32)

;; Create a kevent struct
;; ident: identifier (fd)
;; filter: EVFILT_READ or EVFILT_WRITE
;; flags: EV_ADD, EV_DELETE, etc.
;; udata: user data (waker pointer)
;; returns: pointer to kevent
(defun kevent-new (ident: i64 filter: i16 flags: i16 udata: ptr) -> ptr
  (let ((ev (malloc KEVENT_SIZE)))
    (memset ev 0 KEVENT_SIZE)
    ;; Store ident (8 bytes at offset 0)
    (store-byte ev 0 ident)
    ;; Store filter (2 bytes at offset 8) and flags (2 bytes at offset 10)
    ;; Pack filter and flags into a 4-byte value
    (let ((filter-flags (+ (band filter 65535) (* (band flags 65535) 65536))))
      (store-byte (ptr+ ev 8) 0 filter-flags))
    ;; Store udata (8 bytes at offset 24)
    (store-byte (ptr+ ev 24) 0 udata)
    ev))

;; Get ident from kevent
(defun kevent-ident (ev: ptr) -> i64
  (load-byte ev 0))

;; Get filter from kevent
(defun kevent-filter (ev: ptr) -> i16
  (band (load-byte (ptr+ ev 8) 0) 65535))

;; Get flags from kevent
(defun kevent-flags (ev: ptr) -> i16
  (ashr (load-byte (ptr+ ev 8) 0) 16))

;; Get udata from kevent
(defun kevent-udata (ev: ptr) -> ptr
  (load-byte (ptr+ ev 24) 0))

;; ============================================================
;; timespec Structure
;; ============================================================

;; struct timespec {
;;     time_t tv_sec;   // offset 0, 8 bytes
;;     long tv_nsec;    // offset 8, 8 bytes
;; }

(def TIMESPEC_SIZE 16)

;; Create a timespec for timeout (in milliseconds)
(defun timespec-new (ms: i64) -> ptr
  (let ((ts (malloc TIMESPEC_SIZE)))
    (store-byte ts 0 (/ ms 1000))            ; tv_sec
    (store-byte (ptr+ ts 8) 0 (* (% ms 1000) 1000000)) ; tv_nsec
    ts))

;; ============================================================
;; Reactor Structure
;; ============================================================

;; The reactor manages the kqueue instance and tracks registered fds.
;;
;; Fields:
;;   kq: the kqueue file descriptor
;;   events: pre-allocated array for kevent results
;;   max_events: size of events array

(defstruct Reactor
  (kq: i32
   events: ptr
   max-events: i32))

(def DEFAULT_MAX_EVENTS 64)

;; Create a new reactor
(defun reactor-new () -> ptr
  (let ((kq (kqueue)))
    (if (< kq 0)
        nil  ; Failed to create kqueue
        (let ((r (malloc 24))
              (events (malloc (* DEFAULT_MAX_EVENTS KEVENT_SIZE))))
          (store-byte r 0 kq)                ; kq
          (store-byte (ptr+ r 8) 0 events)    ; events buffer
          (store-byte (ptr+ r 16) 0 DEFAULT_MAX_EVENTS) ; max-events
          r))))

;; Destroy a reactor
(defun reactor-destroy (r: ptr)
  (let ((kq (load-byte r 0))
        (events (load-byte (ptr+ r 8) 0)))
    (close kq)
    (free events)
    (free r)))

;; ============================================================
;; Reactor Operations
;; ============================================================

;; Register a file descriptor for read readiness
;; fd: file descriptor to watch
;; waker: waker to call when ready
;; returns: 0 on success, -1 on error
(defun reactor-register-read (r: ptr fd: i32 waker: ptr) -> i32
  (let ((kq (load-byte r 0))
        (ev (kevent-new fd EVFILT_READ (+ EV_ADD EV_CLEAR) waker)))
    (let ((result (kevent kq ev 1 nil 0 nil)))
      (free ev)
      (if (>= result 0) 0 -1))))

;; Register a file descriptor for write readiness
;; fd: file descriptor to watch
;; waker: waker to call when ready
;; returns: 0 on success, -1 on error
(defun reactor-register-write (r: ptr fd: i32 waker: ptr) -> i32
  (let ((kq (load-byte r 0))
        (ev (kevent-new fd EVFILT_WRITE (+ EV_ADD EV_CLEAR) waker)))
    (let ((result (kevent kq ev 1 nil 0 nil)))
      (free ev)
      (if (>= result 0) 0 -1))))

;; Deregister a file descriptor from read events
(defun reactor-deregister-read (r: ptr fd: i32) -> i32
  (let ((kq (load-byte r 0))
        (ev (kevent-new fd EVFILT_READ EV_DELETE nil)))
    (let ((result (kevent kq ev 1 nil 0 nil)))
      (free ev)
      (if (>= result 0) 0 -1))))

;; Deregister a file descriptor from write events
(defun reactor-deregister-write (r: ptr fd: i32) -> i32
  (let ((kq (load-byte r 0))
        (ev (kevent-new fd EVFILT_WRITE EV_DELETE nil)))
    (let ((result (kevent kq ev 1 nil 0 nil)))
      (free ev)
      (if (>= result 0) 0 -1))))

;; Deregister a file descriptor from all events
(defun reactor-deregister (r: ptr fd: i32) -> i32
  (reactor-deregister-read r fd)
  (reactor-deregister-write r fd))

;; Poll the reactor for events
;; timeout: timeout in milliseconds (-1 = block, 0 = poll)
;; This wakes tasks when their I/O is ready
(defun reactor-poll (r: ptr timeout: i32)
  (let ((kq (load-byte r 0))
        (events (load-byte (ptr+ r 8) 0))
        (max-events (load-byte (ptr+ r 16) 0)))
    (let ((ts (if (>= timeout 0) (timespec-new timeout) nil))
          (n (kevent kq nil 0 events max-events ts)))
      (if (> ts 0) (free ts) nil)
      (if (> n 0)
          (reactor-process-events r events n)
          nil))))

;; Process events returned by kevent
(defun reactor-process-events (r: ptr events: ptr n: i32)
  (reactor-process-events-loop events n 0))

(defun reactor-process-events-loop (events: ptr n: i32 i: i32)
  (if (>= i n)
      nil
      (let ((ev (ptr+ events (* i KEVENT_SIZE)))
            (waker (kevent-udata ev)))
        (if (> waker 0)
            (waker-wake waker)
            nil)
        (reactor-process-events-loop events n (+ i 1)))))

;; ============================================================
;; Non-blocking I/O Helpers
;; ============================================================

;; fcntl constants for making fd non-blocking
(def F_GETFL 3)
(def F_SETFL 4)
(def O_NONBLOCK 4)  ; Different from Linux!

(extern fcntl i32 (i32 i32 ...))

;; Set a file descriptor to non-blocking mode
(defun set-nonblocking (fd: i32) -> i32
  (let ((flags (fcntl fd F_GETFL)))
    (if (< flags 0)
        -1
        (fcntl fd F_SETFL (+ flags O_NONBLOCK)))))
