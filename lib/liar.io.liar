(ns liar.io
  (:require [liar.core :refer :all]
            [liar.runtime :refer :all]))

;; liar Async I/O Library
;;
;; All I/O operations are async-native, using the liar-runtime.
;; Blocking wrappers poll until completion for convenience.

;;; ============================================
;;; libc FFI declarations (for open/close/seek)
;;; ============================================

;; File operations (sync syscalls - that's fine for metadata)
(extern open i32 (ptr i32 i32))
(extern close i32 (i32))
(extern lseek i64 (i32 i64 i32))

;; Memory
(extern malloc ptr (i64))
(extern free void (ptr))

;; String ops
(extern strlen i64 (ptr))

;; Pipes
(extern pipe i32 (ptr))

;; Sockets
(extern socket i32 (i32 i32 i32))
(extern bind i32 (i32 ptr i32))
(extern listen i32 (i32 i32))
(extern accept i32 (i32 ptr ptr))
(extern connect i32 (i32 ptr i32))
(extern setsockopt i32 (i32 i32 i32 ptr i32))
(extern getsockname i32 (i32 ptr ptr))
(extern getpeername i32 (i32 ptr ptr))
(extern shutdown i32 (i32 i32))

;; For non-blocking mode
(extern fcntl i32 (i32 i32 i32))


;;; ============================================
;;; Constants
;;; ============================================

;; Seek
(defun SEEK_SET () 0)
(defun SEEK_CUR () 1)
(defun SEEK_END () 2)

;; Standard fds
(defun STDIN_FD () 0)
(defun STDOUT_FD () 1)
(defun STDERR_FD () 2)

;; Open flags
(defun O_RDONLY () 0)
(defun O_WRONLY () 1)
(defun O_RDWR () 2)
(defun O_CREAT () 64)
(defun O_TRUNC () 512)
(defun O_APPEND () 1024)
(defun O_NONBLOCK () 2048)

;; fcntl commands
(defun F_GETFL () 3)
(defun F_SETFL () 4)

;; Socket domains
(defun AF_UNIX () 1)
(defun AF_INET () 2)
(defun AF_INET6 () 10)

;; Socket types
(defun SOCK_STREAM () 1)
(defun SOCK_DGRAM () 2)

;; Socket options
(defun SOL_SOCKET () 1)
(defun SO_REUSEADDR () 2)
(defun SO_REUSEPORT () 15)

;; Shutdown modes
(defun SHUT_RD () 0)
(defun SHUT_WR () 1)
(defun SHUT_RDWR () 2)


;;; ============================================
;;; Low-Level Async Operations
;;; ============================================

(defun read-async (fd buf len)
  ;; Start an async read. Returns a ReadFuture ptr.
  (liar_io_read fd buf len))

(defun write-async (fd buf len)
  ;; Start an async write. Returns a WriteFuture ptr.
  (liar_io_write fd buf len))

(defun poll-read (future waker)
  ;; Poll a read future. Returns bytes read or negative if pending/error.
  (liar_io_read_poll future waker))

(defun poll-write (future waker)
  ;; Poll a write future. Returns bytes written or negative if pending/error.
  (liar_io_write_poll future waker))

(defun free-read-future (future)
  (liar_io_read_free future))

(defun free-write-future (future)
  (liar_io_write_free future))


;;; ============================================
;;; Blocking Wrappers (poll until ready)
;;; ============================================

;; Poll result encoding from liar-runtime:
;; >= 0: Ready with that many bytes
;; -1: Error
;; i64::MIN (-9223372036854775808): Pending

(defun POLL_PENDING () -> i64
  ;; Sentinel value for pending (i64::MIN).
  -9223372036854775808)

(defun pending? (poll-result)
  ;; Check if poll result indicates pending.
  (= poll-result (POLL_PENDING)))

(defun poll-until-ready (future poll-fn) -> i64
  ;; Spin-poll until future is ready. Returns result.
  (let ((result (poll-fn future nil)))
    (if (pending? result)
        (poll-until-ready future poll-fn)
        result)))

(defun read-blocking (fd buf len) -> i64
  ;; Read from fd, blocking until complete. Returns bytes read or -1.
  (let ((future (read-async fd buf len)))
    (let ((result (poll-until-ready future poll-read)))
      (let ((_ (free-read-future future)))
        result))))

(defun write-blocking (fd buf len) -> i64
  ;; Write to fd, blocking until complete. Returns bytes written or -1.
  (let ((future (write-async fd buf len)))
    (let ((result (poll-until-ready future poll-write)))
      (let ((_ (free-write-future future)))
        result))))


;;; ============================================
;;; File Operations
;;; ============================================

(defun file-open (path flags mode) -> i64
  ;; Open a file. Returns fd or -1 on error.
  (open path flags mode))

(defun file-open-read (path) -> i64
  ;; Open file for reading.
  (file-open path (O_RDONLY) 0))

(defun file-open-write (path) -> i64
  ;; Open file for writing (create/truncate). Mode 0644.
  (file-open path (bit-or (O_WRONLY) (bit-or (O_CREAT) (O_TRUNC))) 420))

(defun file-open-append (path) -> i64
  ;; Open file for appending.
  (file-open path (bit-or (O_WRONLY) (bit-or (O_CREAT) (O_APPEND))) 420))

(defun file-close (fd) -> i64
  ;; Close a file descriptor.
  (close fd))

(defun file-size (fd) -> i64
  ;; Get file size by seeking to end.
  (let ((pos (lseek fd 0 (SEEK_CUR))))
    (let ((size (lseek fd 0 (SEEK_END))))
      (let ((_ (lseek fd pos (SEEK_SET))))
        size))))


;;; ============================================
;;; Read/Write Helpers
;;; ============================================

(defun read-all-loop (fd buf: ptr offset remaining) -> i64
  ;; Read loop handling partial reads.
  (if (<= remaining 0)
      offset
      (let ((n (read-blocking fd (ptr+ buf offset) remaining)))
        (if (<= n 0)
            (if (= n 0) offset -1)  ; EOF vs error
            (read-all-loop fd buf (+ offset n) (- remaining n))))))

(defun read-all-blocking (fd buf size) -> i64
  ;; Read all bytes, handling partial reads.
  (read-all-loop fd buf 0 size))

(defun write-all-loop (fd buf: ptr offset remaining) -> i64
  ;; Write loop handling partial writes.
  (if (<= remaining 0)
      offset
      (let ((n (write-blocking fd (ptr+ buf offset) remaining)))
        (if (<= n 0)
            -1
            (write-all-loop fd buf (+ offset n) (- remaining n))))))

(defun write-all-blocking (fd buf len) -> i64
  ;; Write all bytes, handling partial writes.
  (write-all-loop fd buf 0 len))


;;; ============================================
;;; High-Level Conveniences
;;; ============================================

;; Read entire file as null-terminated string. Returns ptr or nil.
;; Caller is responsible for freeing the returned buffer.
;; This is async-native but blocks the current task until complete.
(defun slurp (path) -> ptr
  (let ((fd (file-open-read path)))
    (if (< fd 0)
        nil
        (let ((size (file-size fd)))
          (let ((buf (malloc (+ size 1))))
            (if (nil? buf)
                (let ((_ (close fd))) nil)
                (let ((_ (lseek fd 0 (SEEK_SET))))
                  (let ((bytes-read (read-all-blocking fd buf size)))
                    (if (< bytes-read 0)
                        (let ((_ (free buf)))
                          (let ((_ (close fd))) nil))
                        (let ((_ (store-byte (ptr+ buf bytes-read) 0)))
                          (let ((_ (close fd)))
                            buf)))))))))))

(defun spit (path contents) -> i64
  ;; Write null-terminated string to file. Returns bytes written or -1.
  (let ((fd (file-open-write path)))
    (if (< fd 0)
        -1
        (let ((len (strlen contents)))
          (let ((written (write-all-blocking fd contents len)))
            (let ((_ (close fd)))
              written))))))

(defun spit-append (path contents) -> i64
  ;; Append null-terminated string to file. Returns bytes written or -1.
  (let ((fd (file-open-append path)))
    (if (< fd 0)
        -1
        (let ((len (strlen contents)))
          (let ((written (write-all-blocking fd contents len)))
            (let ((_ (close fd)))
              written))))))


;;; ============================================
;;; Standard Streams
;;; ============================================

(defun print-str (s) -> i64
  ;; Write string to stdout.
  (write-blocking (STDOUT_FD) s (strlen s)))

(defun println-str (s) -> i64
  ;; Write string + newline to stdout.
  (let ((_ (print-str s)))
    (write-blocking (STDOUT_FD) "\n" 1)))

(defun eprint (s) -> i64
  ;; Write string to stderr.
  (write-blocking (STDERR_FD) s (strlen s)))

(defun eprintln (s) -> i64
  ;; Write string + newline to stderr.
  (let ((_ (eprint s)))
    (write-blocking (STDERR_FD) "\n" 1)))


;;; ============================================
;;; Line Reading
;;; ============================================

(defun read-line-check (fd buf: ptr pos n max-len) -> i64
  ;; Helper: check if we found newline or should continue.
  (if (<= n 0)
      pos
      (if (= (load-byte (ptr+ buf pos)) 10)
          (+ pos 1)
          (read-line-loop fd buf (+ pos 1) max-len))))

(defun read-line-loop (fd buf: ptr pos max-len) -> i64
  ;; Read one byte at a time until newline or max-len.
  (if (>= pos max-len)
      pos
      (let ((n (read-blocking fd (ptr+ buf pos) 1)))
        (read-line-check fd buf pos n max-len))))

;; Read a line from fd into buf. Stops at newline or max-len.
;; Returns bytes read (including newline if present).
(defun read-line (fd buf: ptr max-len) -> i64
  (read-line-loop fd buf 0 max-len))


;;; ============================================
;;; Pipes
;;; ============================================

;; Create a pipe. Returns ptr to 2-element i32 array [read-fd, write-fd].
;; Returns nil on error. Caller must free the returned array.
(defun make-pipe () -> ptr
  (let ((fds (heap-array 2)))
    (if (nil? fds)
        nil
        (if (< (pipe fds) 0)
            (let ((_ (free fds))) nil)
            fds))))

(defun pipe-read-fd (pipe-fds: ptr) -> i64
  ;; Get the read end of a pipe.
  (aget pipe-fds 0))

(defun pipe-write-fd (pipe-fds: ptr) -> i64
  ;; Get the write end of a pipe.
  (aget pipe-fds 1))

(defun pipe-close (pipe-fds: ptr) -> i64
  ;; Close both ends of a pipe and free the array.
  (let ((_ (close (pipe-read-fd pipe-fds))))
    (let ((_ (close (pipe-write-fd pipe-fds))))
      (let ((_ (free pipe-fds)))
        0))))


;;; ============================================
;;; Non-blocking Mode
;;; ============================================

(defun set-nonblocking (fd) -> i64
  ;; Set a file descriptor to non-blocking mode. Returns 0 on success.
  (let ((flags (fcntl fd (F_GETFL) 0)))
    (if (< flags 0)
        -1
        (fcntl fd (F_SETFL) (bit-or flags (O_NONBLOCK))))))

(defun set-blocking (fd) -> i64
  ;; Set a file descriptor to blocking mode. Returns 0 on success.
  (let ((flags (fcntl fd (F_GETFL) 0)))
    (if (< flags 0)
        -1
        (fcntl fd (F_SETFL) (bit-and flags (bit-not (O_NONBLOCK)))))))


;;; ============================================
;;; Sockets
;;; ============================================

(defun tcp-socket () -> i64
  ;; Create a TCP socket. Returns fd or -1 on error.
  (socket (AF_INET) (SOCK_STREAM) 0))

(defun tcp6-socket () -> i64
  ;; Create a TCP IPv6 socket. Returns fd or -1 on error.
  (socket (AF_INET6) (SOCK_STREAM) 0))

(defun udp-socket () -> i64
  ;; Create a UDP socket. Returns fd or -1 on error.
  (socket (AF_INET) (SOCK_DGRAM) 0))

(defun unix-socket () -> i64
  ;; Create a Unix domain stream socket. Returns fd or -1 on error.
  (socket (AF_UNIX) (SOCK_STREAM) 0))

(defun socket-set-reuseaddr (fd) -> i64
  ;; Enable SO_REUSEADDR on socket. Returns 0 on success.
  (let ((one (heap-array 1)))
    (let ((_ (aset one 0 1)))
      (let ((result (setsockopt fd (SOL_SOCKET) (SO_REUSEADDR) one 4)))
        (let ((_ (free one)))
          result)))))

(defun socket-listen (fd backlog) -> i64
  ;; Start listening on socket. Returns 0 on success.
  (listen fd backlog))

(defun socket-shutdown (fd how) -> i64
  ;; Shutdown socket. how: SHUT_RD, SHUT_WR, or SHUT_RDWR.
  (shutdown fd how))

(defun socket-close (fd) -> i64
  ;; Close a socket.
  (close fd))

;;; ============================================
;;; Async Socket Operations
;;; ============================================

(defun accept-async (fd)
  ;; Start an async accept. Returns an AcceptFuture ptr.
  (liar_io_accept fd))

(defun poll-accept (future waker)
  ;; Poll an accept future. Returns client fd or negative if pending/error.
  (liar_io_accept_poll future waker))

(defun free-accept-future (future)
  (liar_io_accept_free future))

(defun connect-async (fd addr addr-len)
  ;; Start an async connect. Returns a ConnectFuture ptr.
  (liar_io_connect fd addr addr-len))

(defun poll-connect (future waker)
  ;; Poll a connect future. Returns 0 (success), -1 (error), or pending.
  (liar_io_connect_poll future waker))

(defun free-connect-future (future)
  (liar_io_connect_free future))

(defun accept-blocking (fd) -> i64
  ;; Accept a connection, blocking until one arrives. Returns client fd or -1.
  (let ((future (accept-async fd)))
    (let ((result (poll-until-ready future poll-accept)))
      (let ((_ (free-accept-future future)))
        result))))

(defun connect-blocking (fd addr addr-len) -> i64
  ;; Connect to address, blocking until complete. Returns 0 on success, -1 on error.
  (let ((future (connect-async fd addr addr-len)))
    (let ((result (poll-until-ready future poll-connect)))
      (let ((_ (free-connect-future future)))
        result))))


;;; ============================================
;;; IPv4 Address Helpers
;;; ============================================

;; sockaddr_in layout (16 bytes):
;;   u16 sin_family  (offset 0)
;;   u16 sin_port    (offset 2, network byte order)
;;   u32 sin_addr    (offset 4, network byte order)
;;   u8[8] padding   (offset 8)

;; Create a sockaddr_in structure. port in host order, addr as u32.
;; Use INADDR_ANY (0) for any address, or pack-ipv4 for specific.
;; Caller must free the returned buffer.
(defun make-sockaddr-in (port addr) -> ptr
  (let ((sa (malloc 16)))
    (if (nil? sa)
        nil
        (let ((_ (store-byte sa 2)))                    ; AF_INET family (low byte)
          (let ((_ (store-byte (ptr+ sa 1) 0)))         ; AF_INET family (high byte)
            (let ((_ (store-byte (ptr+ sa 2) (bit-and (bit-shift-right port 8) 255))))  ; port high byte
              (let ((_ (store-byte (ptr+ sa 3) (bit-and port 255))))                     ; port low byte
                (let ((_ (store-byte (ptr+ sa 4) (bit-and (bit-shift-right addr 24) 255))))
                  (let ((_ (store-byte (ptr+ sa 5) (bit-and (bit-shift-right addr 16) 255))))
                    (let ((_ (store-byte (ptr+ sa 6) (bit-and (bit-shift-right addr 8) 255))))
                      (let ((_ (store-byte (ptr+ sa 7) (bit-and addr 255))))
                        sa)))))))))))

(defun INADDR_ANY () 0)
(defun INADDR_LOOPBACK () 2130706433)  ; 127.0.0.1

(defun pack-ipv4 (a b c d) -> i64
  ;; Pack IPv4 address bytes into u32. E.g., (pack-ipv4 192 168 1 1)
  (bit-or (bit-shift-left a 24)
          (bit-or (bit-shift-left b 16)
                  (bit-or (bit-shift-left c 8) d))))

(defun sockaddr-in-size () 16)
