;; liar Sequence Library
;;
;; Core protocols and implementations for sequential data structures

;;; ============================================================
;;; Protocols
;;; ============================================================

;; Seq - sequential access (lists, lazy seqs)
(defprotocol Seq
  (first [self])      ; returns the head element
  (rest [self]))      ; returns the tail (Seq or nil)

;; Countable - collections with a count
(defprotocol Countable
  (count [self]))     ; returns number of elements

;; Indexable - random access by index
(defprotocol Indexable
  (nth [self idx]))   ; returns element at index (0-based)

;; Collection - basic collection operations
(defprotocol Collection
  (conj [self x])     ; returns collection with x added
  (pop [self]))

;; Mappable - transform elements
(defprotocol Mappable
  (map [self f]))

;; Filterable - select elements
(defprotocol Filterable
  (filter [self pred]))

;; Reducible - fold elements
(defprotocol Reducible
  (reduce [self f init]))

;; Traversable - iterate for side effects
(defprotocol Traversable
  (for-each [self f]))

;; Searchable - search and membership tests
(defprotocol Searchable
  (any [self pred])      ; true if pred is true for any element
  (all [self pred])      ; true if pred is true for all elements
  (member [self x]))     ; true if x is in self

;; SeqTransform - sequence transformations
(defprotocol SeqTransform
  (seq-reverse [self])   ; reverse the sequence
  (seq-append [self other])  ; concatenate two sequences
  (seq-take [self n])    ; first n elements
  (seq-drop [self n]))   ; skip first n elements

;;; ============================================================
;;; Protocol Defaults - Seq provides Countable, Indexable, and HOFs
;;; ============================================================

(extend-protocol-default Countable Seq
  (count [self]
    (let ((tail (rest self)))
      (if (nil? tail) 1 (+ 1 (count tail))))))

(extend-protocol-default Indexable Seq
  (nth [self idx]
    (if (= idx 0)
        (first self)
        (if (nil? (rest self))
            0
            (nth (rest self) (- idx 1))))))

(extend-protocol-default Mappable Seq
  (map [self f]
    (if (nil? (rest self))
        (cons (f (first self)) nil)
        (cons (f (first self)) (map (rest self) f)))))

(extend-protocol-default Filterable Seq
  (filter [self pred]
    (if (nil? (rest self))
        (if (pred (first self))
            (cons (first self) nil)
            nil)
        (if (pred (first self))
            (cons (first self) (filter (rest self) pred))
            (filter (rest self) pred)))))

(extend-protocol-default Reducible Seq
  (reduce [self f init]
    (if (nil? (rest self))
        (f init (first self))
        (reduce (rest self) f (f init (first self))))))

(extend-protocol-default Traversable Seq
  (for-each [self f]
    (if (nil? (rest self))
        (let ((_ (f (first self)))) 0)
        (let ((_ (f (first self)))) (for-each (rest self) f)))))

(extend-protocol-default Searchable Seq
  (any [self pred]
    (if (nil? (rest self))
        (if (pred (first self)) 1 0)
        (if (pred (first self)) 1 (any (rest self) pred))))
  (all [self pred]
    (if (nil? (rest self))
        (if (pred (first self)) 1 0)
        (if (pred (first self)) (all (rest self) pred) 0)))
  (member [self x]
    (if (nil? (rest self))
        (if (= x (first self)) 1 0)
        (if (= x (first self)) 1 (member (rest self) x)))))

(extend-protocol-default SeqTransform Seq
  (seq-reverse [self]
    (seq-reverse-acc self nil))
  (seq-append [self other]
    (if (nil? (rest self))
        (cons (first self) other)
        (cons (first self) (seq-append (rest self) other))))
  (seq-take [self n]
    (if (= n 0) nil
        (if (nil? (rest self))
            (cons (first self) nil)
            (cons (first self) (seq-take (rest self) (- n 1))))))
  (seq-drop [self n]
    (if (= n 0) self
        (if (nil? (rest self))
            nil
            (seq-drop (rest self) (- n 1))))))

;;; ============================================================
;;; Cons - the fundamental list building block
;;; ============================================================

(defstruct Cons (head: i64 tail: ptr))

(extend-protocol Seq Cons
  (first [self] (. self head))
  (rest [self] (. self tail)))

;; Cons gets Countable and Indexable automatically via Seq default

(extend-protocol Collection Cons
  (conj [self x] (share (Cons x self)))
  (pop [self] (. self tail)))

;;; ============================================================
;;; MutVector - a mutable, growable vector
;;; ============================================================

(defstruct MutVector (data: ptr))

;; Internal helpers for MutVector
;; data layout: [len, cap, elem0, elem1, ...]
(defun mv-get-len (data: ptr) (aget data 0))
(defun mv-set-len! (data: ptr len) (aset data 0 len))
(defun mv-data-idx (idx) (+ idx 2))

;; Constructor - creates an empty mutable vector
(defun mut-vector () -> ptr
  (let ((cap 8)
        (data (heap-array (+ cap 2)))
        (s0 (aset data 0 0))
        (s1 (aset data 1 cap)))
    (share (MutVector data))))

(extend-protocol Countable MutVector
  (count [self]
    (mv-get-len (. self data))))

(extend-protocol Indexable MutVector
  (nth [self idx]
    (aget (. self data) (mv-data-idx idx))))

(extend-protocol Collection MutVector
  (conj [self x]
    (let ((data (. self data))
          (len (mv-get-len data))
          (s1 (aset data (mv-data-idx len) x))
          (s2 (mv-set-len! data (+ len 1))))
      self))
  (pop [self]
    (let ((data (. self data))
          (len (mv-get-len data)))
      (if (= len 0)
          0
          (let ((last-idx (- len 1))
                (val (aget data (mv-data-idx last-idx)))
                (s (mv-set-len! data last-idx)))
            val)))))

;;; ============================================================
;;; List constructors
;;; ============================================================

;; cons - construct a new list node
(defun cons (head tail: ptr)
  (share (Cons head tail)))

;; list - construct a list from elements
(defun list1 (a)
  (cons a nil))

(defun list2 (a b)
  (cons a (cons b nil)))

(defun list3 (a b c)
  (cons a (cons b (cons c nil))))

(defun list4 (a b c d)
  (cons a (cons b (cons c (cons d nil)))))

(defun list5 (a b c d e)
  (cons a (cons b (cons c (cons d (cons e nil))))))

;;; ============================================================
;;; Sequence operations (work on any Seq)
;;; ============================================================

;; Helper for seq-reverse (avoids reduce type issues)
(defun seq-reverse-acc (seq: ptr acc: ptr) -> ptr
  (if (nil? seq) acc
      (if (nil? (rest seq))
          (cons (first seq) acc)
          (seq-reverse-acc (rest seq) (cons (first seq) acc)))))

;; last - get last element
(defun last (seq: ptr)
  (if (nil? seq)
      0
      (if (nil? (rest seq))
          (first seq)
          (last (rest seq)))))

;;; ============================================================
;;; Higher-order sequence functions (now via protocols)
;;; ============================================================

;; map, filter, reduce, for-each are now protocol methods
;; Call style: (map seq f), (filter seq pred), (reduce seq f init), (for-each seq f)

;;; ============================================================
;;; List transformations
;;; ============================================================

;; reverse - reverse a list
(defun reverse (seq: ptr)
  (if (nil? seq) nil
      (reduce seq (fn (acc x) (cons x acc)) nil)))

;; append - concatenate two lists
(defun append (seq1: ptr seq2: ptr)
  (if (nil? seq1)
      seq2
      (cons (first seq1) (append (rest seq1) seq2))))

;; take - first n elements
(defun take (n seq: ptr)
  (if (= n 0)
      nil
      (if (nil? seq)
          nil
          (cons (first seq) (take (- n 1) (rest seq))))))

;; drop - skip first n elements
(defun drop (n seq: ptr)
  (if (= n 0)
      seq
      (if (nil? seq)
          nil
          (drop (- n 1) (rest seq)))))

;;; ============================================================
;;; Predicates on sequences
;;; ============================================================

;; any - true if pred is true for any element
(defun any (pred seq: ptr)
  (if (nil? seq)
      0  ; false
      (if (pred (first seq))
          1  ; true
          (any pred (rest seq)))))

;; all - true if pred is true for all elements
(defun all (pred seq: ptr)
  (if (nil? seq)
      1  ; true (vacuous)
      (if (pred (first seq))
          (all pred (rest seq))
          0)))  ; false

;; member - true if x is in seq
(defun member (x seq: ptr)
  (if (nil? seq)
      0
      (if (= x (first seq))
          1
          (member x (rest seq)))))

;;; ============================================================
;;; Numeric reductions
;;; ============================================================

;; sum - sum of all elements
(defun sum (seq: ptr)
  (if (nil? seq) 0
      (reduce seq (fn (acc x) (+ acc x)) 0)))

;; product - product of all elements
(defun product (seq: ptr)
  (if (nil? seq) 1
      (reduce seq (fn (acc x) (* acc x)) 1)))

;; minimum - smallest element
(defun minimum (seq: ptr)
  (if (nil? seq)
      0
      (if (nil? (rest seq))
          (first seq)
          (reduce (rest seq) (fn (acc x) (if (< x acc) x acc)) (first seq)))))

;; maximum - largest element
(defun maximum (seq: ptr)
  (if (nil? seq)
      0
      (if (nil? (rest seq))
          (first seq)
          (reduce (rest seq) (fn (acc x) (if (> x acc) x acc)) (first seq)))))
