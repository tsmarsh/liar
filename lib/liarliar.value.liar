(ns liarliar.value
  (:require [liar.core :refer :all]
            [liar.seq :as seq]))

;; liarliar Value Representation
;;
;; Tagged values are (tag . data) using seq/cons.

;;; Tag Constants
(defun TAG_INT () 0)
(defun TAG_SYMBOL () 1)
(defun TAG_STRING () 2)
(defun TAG_KEYWORD () 3)
(defun TAG_LIST () 4)
(defun TAG_NIL () 5)

;;; Constructors
;; For integers, we box the value in a Cons cell: (TAG_INT . (n . nil))
(defun tv-int (n)
  (seq/cons (TAG_INT) (seq/cons n nil)))

(defun tv-symbol (s: ptr)
  (seq/cons (TAG_SYMBOL) s))

(defun tv-string (s: ptr)
  (seq/cons (TAG_STRING) s))

(defun tv-keyword (s: ptr)
  (seq/cons (TAG_KEYWORD) s))

(defun tv-list (lst: ptr)
  (seq/cons (TAG_LIST) lst))

(defun tv-nil ()
  (seq/cons (TAG_NIL) nil))

;;; Accessors
(defun tv-tag (v: ptr)
  (seq/first v))

(defun tv-data (v: ptr)
  (seq/rest v))

;;; Type Predicates
(defun tv-int? (v: ptr)
  (= (tv-tag v) (TAG_INT)))

(defun tv-symbol? (v: ptr)
  (= (tv-tag v) (TAG_SYMBOL)))

(defun tv-string? (v: ptr)
  (= (tv-tag v) (TAG_STRING)))

(defun tv-keyword? (v: ptr)
  (= (tv-tag v) (TAG_KEYWORD)))

(defun tv-list? (v: ptr)
  (= (tv-tag v) (TAG_LIST)))

(defun tv-nil? (v: ptr)
  (= (tv-tag v) (TAG_NIL)))

;;; List Operations
;; NOTE: List operations on tagged values require ptr<->i64 conversion
;; which isn't currently supported. For now, use the raw list pointer
;; from tv-data for list manipulation, then wrap result with tv-list.
;;
;; Example: to cons two tagged values into a tagged list:
;;   (tv-list (seq/cons (tv-int-value a) (tv-list-data b)))
;; where tv-list-data gets the raw list pointer

;;; Value Extraction
;; Extract integer from boxed form: (TAG_INT . (n . nil)) -> n
(defun tv-int-value (v: ptr)
  (seq/first (tv-data v)))
